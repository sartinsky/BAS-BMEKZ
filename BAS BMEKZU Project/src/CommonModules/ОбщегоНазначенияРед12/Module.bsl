

// Выполняет движение по регистру.
//
// Параметры:
//  НаборДвижений   - набор движений регистра. 
//
Процедура ВыполнитьДвижениеПоРегистру(НаборДвижений, ВидДвижения = Неопределено) Экспорт

	ТаблицаДвижений = НаборДвижений.мТаблицаДвижений;
	Если ТаблицаДвижений.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
    Если ТаблицаДвижений.Колонки.Найти("Период") = Неопределено Тогда
		ТаблицаДвижений.Колонки.Добавить("Период", ОбщегоНазначенияБПКлиентСервер.ПолучитьОписаниеТиповДаты(ЧастиДаты.ДатаВремя))
	КонецЕсли;
	
	МетаРег = НаборДвижений.Метаданные();
	ИзмеренияСостТипа = Новый Структура;

	Для Каждого МетаИзм Из МетаРег.Измерения Цикл
		Если МетаИзм.Тип.Типы().Количество() > 1 Тогда
			ИзмеренияСостТипа.Вставить(МетаИзм.Имя);
		КонецЕсли;
	КонецЦикла;

	Для Каждого МетаИзм Из МетаРег.Реквизиты Цикл
		Если МетаИзм.Тип.Типы().Количество() > 1 Тогда
			ИзмеренияСостТипа.Вставить(МетаИзм.Имя);
		КонецЕсли;
	КонецЦикла;

	Для Каждого МетаРес Из МетаРег.Ресурсы Цикл
		Если МетаРес.Тип.Типы().Количество() > 1 Тогда
			ИзмеренияСостТипа.Вставить(МетаРес.Имя);
		КонецЕсли;
	КонецЦикла;

	// Откопируем остальные колонки (структура таблиц совпадает).
	ПерваяКолонка = Истина;
	МассивСтрок   = Новый Массив(ТаблицаДвижений.Количество());

	Для каждого Колонка Из ТаблицаДвижений.Колонки Цикл

		ИмяКолонки = Колонка.Имя;

		Если ИмяКолонки <> "Период"
		   И ИмяКолонки <> "Активность"
		   И ИмяКолонки <> "НомерСтроки"
		   И ИмяКолонки <> ""
		   И ?(ИмяКолонки = "ВидДвижения", ВидДвижения = Неопределено, Истина)
		   И ИмяКолонки <> "МоментВремени" Тогда

			ФлагКолонкиСостТипа = (ИзмеренияСостТипа.Свойство(ИмяКолонки));

			Индекс = 0;

			Для каждого СтрокаТаблицы Из ТаблицаДвижений Цикл

				Если ПерваяКолонка Тогда

					Если ВидДвижения = ВидДвиженияНакопления.Приход Тогда
						СтрокаДвижения = НаборДвижений.ДобавитьПриход();
					ИначеЕсли ВидДвижения = ВидДвиженияНакопления.Расход Тогда
						СтрокаДвижения = НаборДвижений.ДобавитьРасход();
					Иначе
						СтрокаДвижения = НаборДвижений.Добавить(); // Для оборотных регистров
					КонецЕсли;

					МассивСтрок[Индекс] = СтрокаДвижения;
					Если СтрокаТаблицы.Период = '00010101' Тогда
						СтрокаДвижения.Период = НаборДвижений.мПериод;
					Иначе
						СтрокаДвижения.Период = СтрокаТаблицы.Период;
					КонецЕсли; 

				Иначе

					СтрокаДвижения = МассивСтрок[Индекс];

				КонецЕсли;

				Индекс = Индекс + 1;

				ЗначКолонки = СтрокаТаблицы[ИмяКолонки];
				Если ФлагКолонкиСостТипа Тогда
					Если ЗначКолонки = Неопределено ИЛИ НЕ ЗначениеЗаполнено(ЗначКолонки) Тогда
						СтрокаДвижения[ИмяКолонки] = Неопределено;
					Иначе
						СтрокаДвижения[ИмяКолонки] = ЗначКолонки;
					КонецЕсли;
				Иначе
					СтрокаДвижения[ИмяКолонки] = ЗначКолонки;
				КонецЕсли;

			КонецЦикла;

			ПерваяКолонка = Ложь;

		КонецЕсли;

	КонецЦикла;

КонецПроцедуры // ВыполнитьДвижениеПоРегистру()

// Формирует структуру, содержащую значения реквизитов шапки документа.
//
// Параметры: 
//  ДокументОбъект - объект документа для формирования структуры шапки, 
//
// Возвращаемое значение:
//  Сформированная структура.
//
Функция СформироватьСтруктуруШапкиДокумента(ДокументОбъект) Экспорт

	ВалютаРегламентированногоУчета = ОбщегоНазначенияБПВызовСервераПовтИсп.ПолучитьВалютуРегламентированногоУчета();

	//Первоначальные данные о документе
	СтруктураШапкиДокумента = Новый Структура;
	СтруктураШапкиДокумента.Вставить("Ссылка", ДокументОбъект.Ссылка);
	СтруктураШапкиДокумента.Вставить("Дата",   ДокументОбъект.Дата);
	СтруктураШапкиДокумента.Вставить("Номер",  ДокументОбъект.Номер);

	МетаданныеДокумента = ДокументОбъект.Метаданные();
	СтруктураШапкиДокумента.Вставить("ВидДокумента",  МетаданныеДокумента.Имя);
	СтруктураШапкиДокумента.Вставить("ПредставлениеВидаДокумента",  МетаданныеДокумента.Представление());
	СтруктураШапкиДокумента.Вставить("ПредставлениеДокумента", СокрЛП(ДокументОбъект));
    
	Для каждого Реквизит из МетаданныеДокумента.Реквизиты Цикл
		СтруктураШапкиДокумента.Вставить(Реквизит.Имя, ДокументОбъект[Реквизит.Имя]);
	КонецЦикла;

	//Отображение данных о валютах
	СтруктураШапкиДокумента.Вставить("ВалютаРегламентированногоУчета", ВалютаРегламентированногоУчета);	

	Если СтруктураШапкиДокумента.Свойство("ВалютаДокумента") Тогда
		СтруктураШапкиДокумента.Вставить("КурсДокумента",      ЗаполнениеДокументов.КурсДокумента(ДокументОбъект, ВалютаРегламентированногоУчета));
		СтруктураШапкиДокумента.Вставить("КратностьДокумента", ЗаполнениеДокументов.КратностьДокумента(ДокументОбъект, ВалютаРегламентированногоУчета));

	КонецЕсли;
	
	Если СтруктураШапкиДокумента.Свойство("Организация") Тогда
		СтруктураШапкиДокумента.Вставить("Префикс", СтруктураШапкиДокумента.Организация.Префикс);
	КонецЕсли;
	
	//Отображение обязательных данных о договоре
	Если СтруктураШапкиДокумента.Свойство("ДоговорКонтрагента") Тогда

		Если ТипЗнч(СтруктураШапкиДокумента.ДоговорКонтрагента) = Тип("СправочникСсылка.ДоговорыКонтрагентов") тогда

			СтруктураШапкиДокумента.Вставить("ВедениеВзаиморасчетов",    СтруктураШапкиДокумента.ДоговорКонтрагента.ВедениеВзаиморасчетов);
			СтруктураШапкиДокумента.Вставить("ВалютаВзаиморасчетов",     СтруктураШапкиДокумента.ДоговорКонтрагента.ВалютаВзаиморасчетов);
		КонецЕсли;

	КонецЕсли;

	Возврат СтруктураШапкиДокумента;

КонецФункции // СформироватьСтруктуруШапкиДокумента()

// Формирует структуру дерева значений, содержащего имена полей, которые
// нужно заполнить в запросе по шапке документа.
//
// Параметры: 
//  Нет.
//
// Возвращаемое значение:
//  Дерево значений.
//
Функция СформироватьДеревоПолейЗапросаПоШапке()  Экспорт

	ДеревоПолейЗапросаПоШапке = Новый ДеревоЗначений;
	ОписаниеТиповСтрока       = ОбщегоНазначенияБПКлиентСервер.ПолучитьОписаниеТиповСтроки(100);

	ДеревоПолейЗапросаПоШапке.Колонки.Добавить("Объект"   , ОписаниеТиповСтрока);
	ДеревоПолейЗапросаПоШапке.Колонки.Добавить("Поле"     , ОписаниеТиповСтрока);
	ДеревоПолейЗапросаПоШапке.Колонки.Добавить("Псевдоним", ОписаниеТиповСтрока);

	Возврат ДеревоПолейЗапросаПоШапке;

КонецФункции // СформироватьДеревоПолейЗапросаПоШапке()

// Вставляет строку в дерево полей запроса по шапке, если ее там еще нет,
// если есть, то ничего не делает.
//
// Параметры:
//  ДеревоПолейЗапросаПоШапке - дерево значений, содержащего имена полей, 
//                              которые нужно заполнить в запросе по шапке документа, 
//  ИмяОбъекта                - строка, имя объекта (справочник, регистр и т.д.), 
//  ИмяПоля                   - строка, имя поля объекта,
//  ИмяПсевдонима             - строка, имя псевдонима в запросе поля объекта (необязательный).
//
Процедура ДобавитьСтрокуВДеревоПолейЗапросаПоШапке(ДеревоПолейЗапросаПоШапке, ИмяОбъекта, ИмяПоля, ИмяПсевдонима = Неопределено) Экспорт

	// Поищем нужную строку.
	// Вначале ищем объект.
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти(ИмяОбъекта, "Объект");

	Если СтрокаОбъекта = Неопределено Тогда // нужно добавить.

		СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Добавить();

		СтрокаОбъекта.Объект    = ИмяОбъекта;
		СтрокаОбъекта.Поле      = ИмяПоля;
		СтрокаОбъекта.Псевдоним = ИмяПсевдонима;

	КонецЕсли;

	// Ищем поле.
	СтрокаПоля = СтрокаОбъекта.Строки. Найти(ИмяПоля,"Поле");

	Если СтрокаПоля = Неопределено Тогда // нужно добавить

		СтрокаПоля = СтрокаОбъекта.Строки.Добавить();

		СтрокаПоля.Поле      = ИмяПоля;
		СтрокаПоля.Псевдоним = ИмяПсевдонима;

	КонецЕсли;

	// Ищем псевдоним.
	СтрокаПоля = СтрокаОбъекта.Строки.Найти( ИмяПсевдонима, "Псевдоним");

	Если СтрокаПоля = Неопределено Тогда // нужно добавить

		СтрокаПоля = СтрокаОбъекта.Строки.Добавить();

		СтрокаПоля.Поле      = ИмяПоля;
		СтрокаПоля.Псевдоним = ИмяПсевдонима;

	КонецЕсли;

КонецПроцедуры // ДобавитьСтрокуВДеревоПолейЗапросаПоШапке()

// По переданной структуре полей формирует запрос по табличной части документа.
//
// Параметры: 
//  ДокументОбъект    - объект проводимого документа, 
//  ИмяТабличнойЧасти - строка, имя табличной части,
//  СтруктураПолей    - структура, ключ структуры содержит псевдоним поля запроса, значение - строку запроса,
//  СтруктураПростыхПолей - структура, ключ структуры содержит псевдоним поля запроса, значение - выражение, значением
//							которого будет заполнена колонка в результате запросе.
//
// Возвращаемое значение:
//  Результат запроса.
//
Функция СформироватьЗапросПоТабличнойЧасти(ДокументОбъект, ИмяТабличнойЧасти, СтруктураПолей,
											СтруктураПростыхПолей = Неопределено, 
											СтруктураСложныхПолей = Неопределено) Экспорт
 	Запрос = Новый Запрос;

	ТекстЗапроса = "";

	Для Каждого Реквизит Из СтруктураПолей Цикл

		ТекстЗапроса  = ТекстЗапроса + ",
		|Док." + Реквизит.Значение + 
		?(НЕ ЗначениеЗаполнено(Реквизит.Ключ), "", " КАК " + СокрЛП(Реквизит.Ключ));

	КонецЦикла;

 	Если ТипЗнч(СтруктураПростыхПолей) = Тип("Структура") Тогда // Добавим к запросу конструкции.
 		НомерПараметра = 0;
 		Для Каждого Элемент Из СтруктураПростыхПолей Цикл
 			Если НЕ ЗначениеЗаполнено(Элемент.Ключ) Тогда
 				Продолжить;
 			КонецЕсли;
 			НомерПараметра = НомерПараметра + 1;

			ТекстЗапроса  = ТекстЗапроса + ",
 			| &ПараметрЗапроса" + НомерПараметра + " КАК " + СокрЛП(Элемент.Ключ);
 			Запрос.УстановитьПараметр("ПараметрЗапроса" + НомерПараметра, Элемент.Значение);
		КонецЦикла;

	КонецЕсли;
	
	Если ТипЗнч(СтруктураСложныхПолей) = Тип("Структура") Тогда // Добавим к запросу конструкции.
		
		Для Каждого Элемент Из СтруктураСложныхПолей Цикл
			
			ТекстЗапроса  = ТекстЗапроса + ",
			| " + Элемент.Значение + 
			" КАК " + СокрЛП(Элемент.Ключ);
		
		КонецЦикла;
		
	КонецЕсли;		
	
//	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ // ИНАГРО 
	                | Док.НомерСтроки " + ТекстЗапроса + "
	                | ИЗ 
	                |      Документ." + ДокументОбъект.Метаданные().Имя + "."+ СокрЛП(ИмяТабличнойЧасти) + 
	                " КАК Док 
	                |     ГДЕ Док.Ссылка = &ДокументСсылка";


	// Установим параметры запроса.
	Запрос.УстановитьПараметр("ДокументСсылка" , ДокументОбъект.Ссылка);

	Возврат Запрос.Выполнить();

КонецФункции // СформироватьЗапросПоТабличнойЧасти()

// Функция возвращает массив документов в периоде, соответствующем
// дате переданного документа и того же типа.
// Данную функцию можно использовать, например для проверки
// уникальности документа данного типа в указанном периоде
// Выбираются проведенные и не помеченые на удаление документы.
// Переданный в качестве параметра документ не попадает в выборку.
//
//	Параметры:
//		Док - документ
//  	Периодичность - период интервала. Например
//			Док.Дата = '15.01.2004', периодичность = "Месяц", тогда
//			будут выбиратся документы за январь 2004 года.
//	  		Возможные значения периодичности = "Год", "Квартал", "Месяц", "Неделя", "День"
//	  		По умолчанию - "Месяц"
//  	СтруктРеквизитов - структура в которой в качестве ключа - имя реквизита
//			документа, в качестве значения - значение, которое должен содержать реквизит документа.
//			Будут выбираться документы в которых значение реквизита совпадает с указанным
//		 	значением.
//
//	Возврат:
//		Массив документов.
Функция ДокументыВПериоде(Док, Периодичность = "Месяц", СтруктРеквизитов = Неопределено) Экспорт
	Перем НачДата;
	Перем КонДата;
	Перем Запрос;
	
	// определим период в котором будем искать
	Если Периодичность = "Год" Тогда
		НачДата = НачалоГода(Док.Дата);
		КонДата = КонецГода (Док.Дата);
	ИначеЕсли Периодичность = "Квартал" Тогда
		НачДата = НачалоКвартала(Док.Дата);
		КонДата = КонецКвартала (Док.Дата);
	ИначеЕсли Периодичность = "Месяц"   Тогда
		НачДата = НачалоМесяца(Док.Дата);
		КонДата = КонецМесяца (Док.Дата);
	ИначеЕсли Периодичность = "Неделя"  Тогда
		НачДата = НачалоНедели(Док.Дата);
		КонДата = КонецНедели (Док.Дата);
	ИначеЕсли Периодичность = "День"  Тогда
		НачДата = НачалоДня(Док.Дата);
		КонДата = КонецДня (Док.Дата);
	Иначе
		Возврат Новый Массив;
	КонецЕсли;
	
	ТекстЗапроса = "
		|ВЫБРАТЬ
		|	Док.Ссылка КАК Док
		|
		|ИЗ
		|   Документ." + Док.Метаданные().Имя + " КАК Док
		|
		|ГДЕ
		|   Док.Дата МЕЖДУ &НачДата И &КонДата И
		|   Док.Проведен И НЕ Док.ПометкаУдаления И
		|   НЕ Док.Ссылка = &ДокСсылка
		|";
		
	Запрос = Новый Запрос;
	
	Если Не СтруктРеквизитов = Неопределено Тогда
		Для Каждого Ключ Из СтруктРеквизитов Цикл
			Запрос.УстановитьПараметр(Ключ.Ключ, Ключ.Значение);
			ТекстЗапроса = ТекстЗапроса + " И
				|Док." + Ключ.Ключ + " = &" + Ключ.Ключ;
		КонецЦикла;
	КонецЕсли;
	
	Запрос.Текст = ТекстЗапроса;
		
	Запрос.УстановитьПараметр("НачДата",   НачДата);
	Запрос.УстановитьПараметр("КонДата",   КонДата);
	Запрос.УстановитьПараметр("ДокСсылка", Док.Ссылка);
	
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Док");
	
КонецФункции // ДокументыВПериоде()

// Выполняет округление числовых значений с накоплением погрешностей округления, образовавшихся
//		в результате предыдущих вызовов функции
//
// Параметры
//  Число 		– Число. Округляемое значение
//  Точность	– Число. Точность округления
//	Погрешность	- Число. Переменная, в которой накапливается погрешность с предыдущих вызовов
//
// Возвращаемое значение:
//   Число   – округленное значение
//
Функция ОкруглитьСУчетомПогрешности(Число, Точность, Погрешность = 0, 
	               СоответствиеПогрешностей = Неопределено, Ключ = Неопределено) Экспорт

	Если НЕ СоответствиеПогрешностей = Неопределено  И ЗначениеЗаполнено(Ключ) Тогда
	
		// считываем погрешность округления, накопленную ранее при расчетах
		Погрешность = СоответствиеПогрешностей[Ключ];
		// погрешности округления еще нет -- первая сумма
		Если Погрешность = Неопределено Тогда
			Погрешность = 0;
		КонецЕсли;
		// округлим с учетом погрешности
		Округленное = ОкруглитьСУчетомПогрешности(Число, Точность, Погрешность);
		// сохраним погрешность округления
		СоответствиеПогрешностей.Вставить(Ключ, Погрешность);
	
	Иначе
		
		Если Число = 0 Тогда
			Возврат 0;
		КонецЕсли; 
	
		// выравнивание разрядности
		Число = Окр(Число, 27, ?(Число<0, РежимОкругления.Окр15как10, РежимОкругления.Окр15как20));
		
		// сумма с учетом погрешности предыдущих вычислений
		Округляемое = Число + Погрешность;

		// для отрицательного числа меняем направление округления, чтобы избежать ошибки Окр(-0.5) = -1
		Округленное	= Окр(Округляемое, Точность, ?(Округляемое<0, РежимОкругления.Окр15как10, РежимОкругления.Окр15как20));
		
		// рассчитаем новую погрешность округления
		Погрешность	= Округляемое - Округленное;
		
	КонецЕсли;
	
	Возврат Округленное;

КонецФункции // ОкруглитьСУчетомПогрешности()

// Преобразует таблицу значений в дерево значений, группируя значения по колонкам, формирование итога по строкам
Функция ТаблицуЗначенийВДеревоСГруппировкой(ТаблицаРезультатов, знач ГруппировочныеКолонки= "",знач КолонкиИтогов = "") экспорт
	
	ДеревоРезультатов  = Новый ДеревоЗначений();
	Для каждого Колонка из ТаблицаРезультатов.Колонки Цикл
		ДеревоРезультатов.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения,Колонка.Заголовок,Колонка.Ширина);
	КонецЦикла; 
	
	Если ПустаяСтрока(ГруппировочныеКолонки) Тогда
		Для каждого СтрокаТаблицы Из ТаблицаРезультатов Цикл
			СтрокаДерева = ДеревоРезультатов.Строки.Добавить();
			Для каждого Колонка из ДеревоРезультатов.Колонки Цикл
				СтрокаДерева[Колонка.Имя] = СтрокаТаблицы[Колонка.Имя]
			КонецЦикла; 
		КонецЦикла; 
		
		Возврат ДеревоРезультатов;
	КонецЕсли;
	
	ТаблицаГруппировок = ТаблицаРезультатов.Скопировать();
	ТаблицаГруппировок.Свернуть(ГруппировочныеКолонки,КолонкиИтогов);

	Для каждого СтрокаТаблицы Из ТаблицаГруппировок Цикл
		СтрокаДерева = ДеревоРезультатов.Строки.Добавить();
		Для каждого Колонка из ТаблицаГруппировок.Колонки Цикл
			СтрокаДерева[Колонка.Имя] = СтрокаТаблицы[Колонка.Имя]
		КонецЦикла; 
	КонецЦикла; 
	
	ЗначенияОтбора = Новый Структура(ГруппировочныеКолонки);
	Для каждого СтрокаДерева из  ДеревоРезультатов.Строки Цикл
		//Формирование структуры отбора
		Для каждого ПараметрОтбора Из ЗначенияОтбора Цикл
			ЗначенияОтбора.Вставить(ПараметрОтбора.Ключ, СтрокаДерева[ПараметрОтбора.Ключ]);
		КонецЦикла; 
		
		//Поиск и заполнение подчиненными колонками
		МассивПодчиненныйхСтрок = ТаблицаРезультатов.НайтиСтроки(ЗначенияОтбора);
		Для каждого СтрокаТаблицы Из МассивПодчиненныйхСтрок Цикл
			ПодчиненнаяСтрокаДерева = СтрокаДерева.Строки.Добавить();
			Для каждого Колонка из ДеревоРезультатов.Колонки Цикл
				ПодчиненнаяСтрокаДерева[Колонка.Имя] = СтрокаТаблицы[Колонка.Имя];
			КонецЦикла; 
		КонецЦикла; 
	КонецЦикла;
		
	Возврат ДеревоРезультатов;
КонецФункции

#Область ЗакомментированныйКод
// Служебная функция, предназначенная для получения описания типов набора записей по объекту метаданных
// Параметры:
//	Значение - Null, Булево, Строка
//
// Возвращаемое значение:
// Число, полученное в результате преобразования
//



////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ДВИЖЕНИЯМИ ДОКУМЕНТОВ


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ ДОКУМЕНТАМИ

#КонецОбласти 
