#Область ПрограммныйИнтерфейс

// Функция возвращает список подключенного в справочнике ПО
//
Функция ПолучитьСписокОборудования(ТипыПО = Неопределено, Идентификатор = Неопределено, РабочееМесто = Неопределено) Экспорт
	
	Возврат Справочники.ИНАГРО_ПодключаемоеОборудование.ПолучитьСписокОборудования(ТипыПО, Идентификатор, РабочееМесто);
	
КонецФункции

// Функция возвращает по идентификатору устройства его параметры
//
Функция ПолучитьПараметрыУстройства(Идентификатор) Экспорт
	
	Возврат Справочники.ИНАГРО_ПодключаемоеОборудование.ПолучитьПараметрыУстройства(Идентификатор);
	
КонецФункции

// Процедура предназначена для сохранения параметров устройства
// в реквизит Параметры типа хранилище значения в элементе справочника
Функция СохранитьПараметрыУстройства(Идентификатор, Параметры) Экспорт

	Возврат Справочники.ИНАГРО_ПодключаемоеОборудование.СохранитьПараметрыУстройства(Идентификатор, Параметры);

КонецФункции

// Функция возвращает структуру с данными устройства
//
Функция ПолучитьДанныеУстройства(Идентификатор) Экспорт

	Возврат Справочники.ИНАГРО_ПодключаемоеОборудование.ПолучитьДанныеУстройства(Идентификатор);

КонецФункции

// Функция возвращает структуру с данными драйвера
// 
Функция ПолучитьДанныеДрайвера(Идентификатор) Экспорт

	Возврат Справочники.ИНАГРО_ДрайверыОборудования.ПолучитьДанныеДрайвера(Идентификатор);

КонецФункции

// Функция возвращает имя драйвера по наименованию обработчика
//
Функция ПолучитьИмяДрайвераЭкземпляра(НаименованиеОбработчикаДрайвера) Экспорт

	Результат = "";
	
	Для каждого ИмяПеречисления Из Метаданные.Перечисления.ИНАГРО_ОбработчикиДрайверовПодключаемогоОборудования.ЗначенияПеречисления Цикл
		Если НаименованиеОбработчикаДрайвера = ИмяПеречисления.Синоним Тогда
			Результат = ИмяПеречисления.Имя;
			Прервать;
		КонецЕсли;
	КонецЦикла;

	Возврат Результат;

КонецФункции

// Функция возвращает параметры драйвера по наименованию обработчика
//
Функция ПолучитьПараметрыДрайвераПоОбработчику(НаименованиеОбработчикаДрайвера) Экспорт

	Результат = Новый Структура;
	
	Для каждого ИмяПеречисления Из Метаданные.Перечисления.ИНАГРО_ОбработчикиДрайверовПодключаемогоОборудования.ЗначенияПеречисления Цикл
		Если НаименованиеОбработчикаДрайвера = ИмяПеречисления.Синоним Тогда
			Результат.Вставить("Имя"            , ИмяПеречисления.Имя);
			Результат.Вставить("Наименование"   , ИмяПеречисления.Синоним);
			Результат.Вставить("ТипОборудования", Перечисления["ИНАГРО_ТипыПодключаемогоОборудования"][ИмяПеречисления.Комментарий]);
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;

КонецФункции

// Функция возвращает из переменной сеанса имя компьютера клиента
//
Функция ПолучитьРабочееМестоКлиента() Экспорт

	УстановитьПривилегированныйРежим(Истина);
	Возврат ПараметрыСеанса.ИНАГРО_РабочееМестоКлиента;

КонецФункции

// Функция возвращает список рабочих мест, соответствующих указанному имени компьютера
//
Функция НайтиРабочиеМестаПоИД(ИдентификаторКлиента) Экспорт
	
	Если Не ИНАГРО_МенеджерОборудованияВызовСервераПереопределяемый.ДоступноИспользованиеРазделенныхДанных() Тогда
		Возврат Новый Массив();
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос("
	|ВЫБРАТЬ
	|	РабочиеМеста.Ссылка
	|ИЗ
	|	Справочник.ИНАГРО_РабочиеМеста КАК РабочиеМеста
	|ГДЕ
	|	РабочиеМеста.Код = &Код
	|	И РабочиеМеста.ПометкаУдаления = ЛОЖЬ
	|");
	
	Запрос.УстановитьПараметр("Код", ИдентификаторКлиента);
	СписокКомпьютеров = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	
	Возврат СписокКомпьютеров;
	
КонецФункции

// Функция устанавливает в переменную сеанса имя компьютера клиента
//
Процедура УстановитьРабочееМестоКлиента(РабочееМестоКлиента) Экспорт

	УстановитьПривилегированныйРежим(Истина);
	ПараметрыСеанса.ИНАГРО_РабочееМестоКлиента = РабочееМестоКлиента;
	ОбновитьПовторноИспользуемыеЗначения();

КонецПроцедуры

// Функция получает макет драйвера и сохраняет его во временное хранилище,
// возвращая ссылку на временное хранилище
Функция ПолучитьМакетССервера(ИмяМакета) Экспорт

	Ссылка = ПоместитьВоВременноеХранилище(ПолучитьОбщийМакет(ИмяМакета));
	Возврат Ссылка;

КонецФункции

// Функция возвращает макет слип чека по наименованию макета
//
Функция ПолучитьСлипЧек(ИмяМакета, ШиринаСлипЧека, Параметры, АвторизацияПИН = Ложь) Экспорт
	
	СлипЧек  = "";  
	
	Документ = Новый ТекстовыйДокумент();
	
	Макет    = ПолучитьОбщийМакет(ИмяМакета);
	Область  = Макет.ПолучитьОбласть("Чек" + ШиринаСлипЧека + ?(АвторизацияПИН, "пин", ""));
	
	Для Каждого Параметр Из Параметры Цикл
		Область.Параметры[Параметр.Ключ] = Параметр.Значение;
	КонецЦикла;
	
	Если Область <> Неопределено Тогда
		Документ.Вывести(Область);
		
		Для Индекс = 1 По Документ.КоличествоСтрок() Цикл
			СлипЧек = СлипЧек + Документ.ПолучитьСтроку(Индекс)
			        + ?(Индекс = Документ.КоличествоСтрок(), "", Символ(13) + Символ(10));
		КонецЦикла;
	КонецЕсли;
	
	Возврат СлипЧек;
	
КонецФункции

// Функция возвращает значение константы
//
Функция ПолучитьКонстанту(ИмяКонстанты) Экспорт
	
	Константа = Константы[ИмяКонстанты].Получить();
	Возврат Константа;
	
КонецФункции           

// Получает ссылку предопределенного элемента по его полному имени.
//
Функция ПредопределенныйЭлемент(Знач ПолноеИмяПредопределенного) Экспорт
	
	ИмяПредопределенного = ВРег(ПолноеИмяПредопределенного);
	
	Точка = Найти(ИмяПредопределенного, ".");
	ИмяКоллекции = Лев(ИмяПредопределенного, Точка - 1);
	ИмяПредопределенного = Сред(ИмяПредопределенного, Точка + 1);
	
	Точка = Найти(ИмяПредопределенного, ".");
	ИмяТаблицы = Лев(ИмяПредопределенного, Точка - 1);
	ИмяПредопределенного = Сред(ИмяПредопределенного, Точка + 1);
	
	ТекстЗапроса = "ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1 Ссылка ИЗ &ПолноеИмяТаблицы ГДЕ ИмяПредопределенныхДанных = &ИмяПредопределенного";
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПолноеИмяТаблицы", ИмяКоллекции + "." + ИмяТаблицы);
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("ИмяПредопределенного", ИмяПредопределенного);
	
	Результат = Запрос.Выполнить();
	Если Результат.Пустой() Тогда
		Возврат Неопределено;
	Иначе
		Возврат Результат.Выгрузить()[0].Ссылка;
	КонецЕсли;
	
КонецФункции

// Функция возвращает доступность сохранение данных пользователя
//
Функция ПравоДоступаСохранениеДанныхПользователя() Экспорт
	
	Возврат ПравоДоступа("СохранениеДанныхПользователя", Метаданные);
	
КонецФункции

// Функция возвращает имя перечисления из его метаданных
//
Функция ПолучитьИмяТипаОборудования(ТипОборудования) Экспорт

	Результат = Неопределено;
	
	МетаОбъект = ТипОборудования.Метаданные();
	Индекс = Перечисления.ИНАГРО_ТипыПодключаемогоОборудования.Индекс(ТипОборудования);
	Результат = МетаОбъект.ЗначенияПеречисления[Индекс].Имя;

	Возврат Результат;

КонецФункции

// Функция возвращает перечисление по имени
//
Функция ПолучитьТипОборудования(ТипОборудованияИмя) Экспорт
	
	Попытка
		Результат = Перечисления["ИНАГРО_ТипыПодключаемогоОборудования"][ТипОборудованияИмя]; 
	Исключение
		Результат = Перечисления.ИНАГРО_ТипыПодключаемогоОборудования.ПустаяСсылка();
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Функция возвращает созданное рабочее место клиента
//
Функция СоздатьРабочееМестоКлиента(Параметры) Экспорт

	УстановитьПривилегированныйРежим(Истина);
	
	РабочееМесто = Справочники.ИНАГРО_РабочиеМеста.СоздатьЭлемент();

	РабочееМесто.Код           = Параметры.ИдентификаторКлиента;
	РабочееМесто.ИмяКомпьютера = Параметры.ИмяКомпьютера;


	ИНАГРО_МенеджерОборудованияКлиентСервер.ЗаполнитьНаименованиеРабочегоМеста(РабочееМесто, ПользователиИнформационнойБазы.ТекущийПользователь());

	РабочееМесто.Записать();

	УстановитьПривилегированныйРежим(Ложь);
	
	Возврат РабочееМесто.Ссылка;

КонецФункции // СоздатьРабочееМестоКлиентаПоИД()

// Процедура устанавливает значения параметров сеанса, относящихся к подключаемому оборудованию
//
Процедура УстановитьПараметрыСеансаПодключаемогоОборудования(ИмяПараметра, УстановленныеПараметры) Экспорт

	Если ИмяПараметра = "ИНАГРО_РабочееМестоКлиента" Тогда
		
		// Если с идентификатором клиента текущего сеанса связано одно рабочее место,
		// то его сразу и запишем в параметры сеанса
		ТекущееРМ           = Справочники.ИНАГРО_РабочиеМеста.ПустаяСсылка();
		СистемнаяИнформация = Новый СистемнаяИнформация();
		
		СписокРМ = НайтиРабочиеМестаПоИД(ВРег(СистемнаяИнформация.ИдентификаторКлиента));
		Если СписокРМ.Количество() = 0 Тогда
			// Будет создано с клиента.
		Иначе
			ТекущееРМ = СписокРМ[0];
		КонецЕсли;
		
		УстановитьРабочееМестоКлиента(ТекущееРМ);
		
		Если ТипЗнч(УстановленныеПараметры) = Тип("Структура") Тогда
			УстановленныеПараметры.Вставить("РабочееМестоКлиента");
		Иначе
			УстановленныеПараметры.Добавить("РабочееМестоКлиента");
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Возвращает список оборудования для которого необходима переустановка компоненты
//
Функция ПолучитьСписокДрайверовДляПереустановки(РабочееМесто) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	Список = Новый Массив;
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ РАЗЛИЧНЫЕ 
	|	ПодключаемоеОборудование.ДрайверОборудования
	|ИЗ
	|	Справочник.ИНАГРО_ПодключаемоеОборудование КАК ПодключаемоеОборудование
	|ГДЕ
	|	ПодключаемоеОборудование.РабочееМесто = &РабочееМесто 
	|	И ПодключаемоеОборудование.ТребуетсяПереустановка");
	Запрос.УстановитьПараметр("РабочееМесто", РабочееМесто);
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Строка = Новый Структура("ДрайверОборудования, ДанныеДрайвера", Выборка.ДрайверОборудования, ПолучитьДанныеДрайвера(Выборка.ДрайверОборудования)); 
		Список.Добавить(Строка);
	КонецЦикла;
	
	Возврат Список;
	
КонецФункции

// Возвращает список оборудования для которого необходима установка компоненты
//
Функция ПолучитьСписокДрайверовДляУстановки(РабочееМесто) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	Список = Новый Массив;
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ РАЗЛИЧНЫЕ 
	|	ПодключаемоеОборудование.ДрайверОборудования
	|ИЗ
	|	Справочник.ИНАГРО_ПодключаемоеОборудование КАК ПодключаемоеОборудование
	|ГДЕ
	|	ПодключаемоеОборудование.РабочееМесто = &РабочееМесто 
	|	И ПодключаемоеОборудование.ТребуетсяУстановка");
	Запрос.УстановитьПараметр("РабочееМесто", РабочееМесто);
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Строка = Новый Структура("ДрайверОборудования, ДанныеДрайвера", Выборка.ДрайверОборудования, ПолучитьДанныеДрайвера(Выборка.ДрайверОборудования)); 
		Список.Добавить(Строка);
	КонецЦикла;
	
	Возврат Список;
	
КонецФункции

// Записывает изменения в переданном объекте.
// Для использования в обработчиках обновления.
//
// Параметры:
//   Данные                            - Произвольный - объект, набор записей или менеджер константы, 
//														который необходимо записать.
//   РегистрироватьНаУзлахПлановОбмена - Булево       - включает регистрацию на узлах планов обмена при записи объекта.
//   ВключитьБизнесЛогику              - Булево       - включает бизнес-логику при записи объекта.
//
Процедура ЗаписатьДанные(Знач Данные, Знач РегистрироватьНаУзлахПлановОбмена = Ложь, 
	Знач ВключитьБизнесЛогику = Ложь) Экспорт
	
	Данные.ОбменДанными.Загрузка = Не ВключитьБизнесЛогику;
	Если Не РегистрироватьНаУзлахПлановОбмена Тогда
		Данные.ДополнительныеСвойства.Вставить("ОтключитьМеханизмРегистрацииОбъектов");
		Данные.ОбменДанными.Получатели.АвтоЗаполнение = Ложь;
	КонецЕсли;
	
	Данные.Записать();
	
КонецПроцедуры

// Устанавливает признак необходимости переустановки оборудования для подключаемого оборудования на рабочем месте
//
Процедура УстановитьПризнакПереустановкиДрайвера(РабочееМесто, ДрайверОборудования, Признак) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ  
	|	ПодключаемоеОборудование.Ссылка
	|ИЗ
	|	Справочник.ИНАГРО_ПодключаемоеОборудование КАК ПодключаемоеОборудование
	|ГДЕ
	|	ПодключаемоеОборудование.РабочееМесто = &РабочееМесто
	|	И ПодключаемоеОборудование.ДрайверОборудования = &ДрайверОборудования
	|	И НЕ ПодключаемоеОборудование.ТребуетсяПереустановка = &ТребуетсяПереустановка"); 
	
	Запрос.УстановитьПараметр("РабочееМесто", РабочееМесто);
	Запрос.УстановитьПараметр("ДрайверОборудования", ДрайверОборудования);
	Запрос.УстановитьПараметр("ТребуетсяПереустановка", Признак);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		СправочникОбъект = Выборка.Ссылка.ПолучитьОбъект();
		СправочникОбъект.ТребуетсяПереустановка = Признак;
		ЗаписатьДанные(СправочникОбъект)
	КонецЦикла;
	
КонецПроцедуры

// Устанавливает признак необходимости установки оборудования для подключаемого оборудования на рабочем месте
//
Процедура УстановитьПризнакУстановкиДрайвера(РабочееМесто, ДрайверОборудования, Признак) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ  
	|	ПодключаемоеОборудование.Ссылка
	|ИЗ
	|	Справочник.ИНАГРО_ПодключаемоеОборудование КАК ПодключаемоеОборудование
	|ГДЕ
	|	ПодключаемоеОборудование.РабочееМесто = &РабочееМесто
	|	И ПодключаемоеОборудование.ДрайверОборудования = &ДрайверОборудования
	|	И НЕ ПодключаемоеОборудование.ТребуетсяУстановка = &ТребуетсяУстановка"); 
	
	Запрос.УстановитьПараметр("РабочееМесто", РабочееМесто);
	Запрос.УстановитьПараметр("ДрайверОборудования", ДрайверОборудования);
	Запрос.УстановитьПараметр("ТребуетсяУстановка", Признак);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		СправочникОбъект = Выборка.Ссылка.ПолучитьОбъект();
		СправочникОбъект.ТребуетсяУстановка = Признак;
		ЗаписатьДанные(СправочникОбъект)
	КонецЦикла;
	
КонецПроцедуры

// Сохраняет пользовательские настройки подключаемого оборудования
//
Процедура СохранитьПользовательскиеНастройкиПодключаемогоОборудования(СписокНастроек) Экспорт
		
	Если НЕ ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Возврат;
	КонецЕсли;

	Для Каждого Элемент Из СписокНастроек Цикл
		ХранилищеОбщихНастроек.Сохранить("ПользовательскиеНастройкиПодключаемогоОборудования", Элемент.Ключ, Элемент.Значение);
	КонецЦикла;
		
	ОбновитьПовторноИспользуемыеЗначения();

КонецПроцедуры

// Производит разложение данных дорожек магнитной карты по шаблонам
// На входе:
// ДанныеДорожек - массив строк. Значения полученные из дорожек.
// ПараметрыДорожек - массив структур содержащих параметры настройки устройства
//  * Использовать, булево - признак использования дорожки
//  * НомерДорожки, число - порядковый номер дорожки 1-3
//
// На выходе:
// Массив структур содержащих расшифрованные данные по всем подходящим шаблонам со ссылкой на них
// * Массив - шаблоны
//   * Структура - данные шаблона
//     - Шаблон, СправочникСсылка.ШаблоныМагнитныхКарт
//     - ДанныеДорожек, массив полей всех дорожек
//       * Структура - данные поля
//         - Поле
//         - ЗначениеПоля
Функция РасшифроватьКодМагнитнойКарты(ДанныеДорожек, ПараметрыДорожек) Экспорт
	
	Если ДанныеДорожек.Количество() = 0
		ИЛИ ПараметрыДорожек.Количество() = 0 Тогда
		Возврат Неопределено; // нет данных
	КонецЕсли;
	
	ДанныеОтбор = Новый Массив;
	СчетчикДорожек = 0;
	Для каждого текПараметр Из ПараметрыДорожек Цикл
		Если текПараметр.Использовать Тогда
			Попытка
				ДанныеОтбор.Добавить(Новый Структура("НомерДорожки, ДлинаДорожки, ДанныеДорожки"
													, текПараметр.НомерДорожки, СтрДлина(ДанныеДорожек[СчетчикДорожек]), ДанныеДорожек[СчетчикДорожек]));
			Исключение
				Возврат Неопределено; // неверный формат шаблона
			КонецПопытки;
		КонецЕсли;
		СчетчикДорожек = СчетчикДорожек + 1;
	КонецЦикла;
	
	// 1-ый этап. Ищем шаблоны совпадающие по длине кода
	// а) При сравнении играют роль только доступные дорожки
	// б) Необходимо чтобы хотя бы одна дорожка была доступной
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	ШаблоныМагнитныхКарт.Ссылка,
	|	
	|	ШаблоныМагнитныхКарт.ДоступностьДорожки1,
	|	ШаблоныМагнитныхКарт.Префикс1,
	|	ШаблоныМагнитныхКарт.Суффикс1,
	|	ШаблоныМагнитныхКарт.ДлинаКода1,
	|	ШаблоныМагнитныхКарт.РазделительБлоков1,
	|	
	|	ШаблоныМагнитныхКарт.ДоступностьДорожки2,
	|	ШаблоныМагнитныхКарт.Префикс2,
	|	ШаблоныМагнитныхКарт.Суффикс2,
	|	ШаблоныМагнитныхКарт.ДлинаКода2,
	|	ШаблоныМагнитныхКарт.РазделительБлоков2,
	|	
	|	ШаблоныМагнитныхКарт.ДоступностьДорожки3,
	|	ШаблоныМагнитныхКарт.Префикс3,
	|	ШаблоныМагнитныхКарт.Суффикс3,
	|	ШаблоныМагнитныхКарт.ДлинаКода3,
	|	ШаблоныМагнитныхКарт.РазделительБлоков3
	|ИЗ
	|	Справочник.ШаблоныМагнитныхКарт КАК ШаблоныМагнитныхКарт
	|ГДЕ
	|	(ШаблоныМагнитныхКарт.ДоступностьДорожки1
	|			ИЛИ ШаблоныМагнитныхКарт.ДоступностьДорожки2
	|			ИЛИ ШаблоныМагнитныхКарт.ДоступностьДорожки3)
	|	И ВЫБОР
	|			КОГДА ШаблоныМагнитныхКарт.ДоступностьДорожки1
	|				ТОГДА ШаблоныМагнитныхКарт.ДлинаКода1 = &ДлинаКода1
	|			ИНАЧЕ ИСТИНА
	|		КОНЕЦ
	|	И ВЫБОР
	|			КОГДА ШаблоныМагнитныхКарт.ДоступностьДорожки2
	|				ТОГДА ШаблоныМагнитныхКарт.ДлинаКода2 = &ДлинаКода2
	|			ИНАЧЕ ИСТИНА
	|		КОНЕЦ
	|	И ВЫБОР
	|			КОГДА ШаблоныМагнитныхКарт.ДоступностьДорожки3
	|				ТОГДА ШаблоныМагнитныхКарт.ДлинаКода3 = &ДлинаКода3
	|			ИНАЧЕ ИСТИНА
	|		КОНЕЦ");
	Запрос.УстановитьПараметр("ДлинаКода1", СтрДлина(ДанныеДорожек[0]));
	Запрос.УстановитьПараметр("ДлинаКода2", СтрДлина(ДанныеДорожек[1]));
	Запрос.УстановитьПараметр("ДлинаКода3", СтрДлина(ДанныеДорожек[2]));
	Выборка = Запрос.Выполнить().Выбрать();
	
	СписокШаблонов = Новый Массив;
	Пока Выборка.Следующий() Цикл
		
		// 2-ой этап - Пропускаем шаблоны не совпадающие по суффиксу, префиксу, разделителю.
		
		Если НЕ КодСоответствуетШаблонуМК(ДанныеДорожек, Выборка) Тогда
			Продолжить;
		КонецЕсли;
		
		ДанныеДорожки = Новый Массив;
		Для каждого текОтбор Из ДанныеОтбор Цикл
			Для каждого текПоле Из Выборка.Ссылка["ПоляДорожки"+Строка(текОтбор.НомерДорожки)] Цикл
				
				// Поиск блока по номеру
				ДанныеСтрока = текОтбор.ДанныеДорожки;
				Префикс = Выборка["Префикс"+Строка(текОтбор.НомерДорожки)];
				Если Префикс = Лев(ДанныеСтрока, СтрДлина(Префикс)) Тогда
					ДанныеСтрока = Прав(ДанныеСтрока, СтрДлина(ДанныеСтрока)-СтрДлина(Префикс)); // Удаляем префикс если есть
				КонецЕсли;
				Суффикс = Выборка["Суффикс"+Строка(текОтбор.НомерДорожки)];
				Если Суффикс = Прав(ДанныеСтрока, СтрДлина(Суффикс)) Тогда
					ДанныеСтрока = Лев(ДанныеСтрока, СтрДлина(ДанныеСтрока)-СтрДлина(Суффикс)); // Удаляем суффикс если есть
				КонецЕсли;
				
				текНомерБлока = 0;
				Пока текНомерБлока < текПоле.НомерБлока Цикл
					РазделительБлоков = Выборка["РазделительБлоков"+Строка(текОтбор.НомерДорожки)];
					ПозицияРазделителя = Найти(ДанныеСтрока, РазделительБлоков);
					Если ПустаяСтрока(РазделительБлоков) ИЛИ ПозицияРазделителя = 0 Тогда
						Блок = ДанныеСтрока;
					ИначеЕсли ПозицияРазделителя = 1 Тогда
						Блок = "";
						ДанныеСтрока = Прав(ДанныеСтрока, СтрДлина(ДанныеСтрока)-1);
					Иначе
						Блок = Лев(ДанныеСтрока, ПозицияРазделителя-1);
						ДанныеСтрока = Прав(ДанныеСтрока, СтрДлина(ДанныеСтрока)-ПозицияРазделителя);
					КонецЕсли;
					текНомерБлока = текНомерБлока + 1;
				КонецЦикла;
				
				// Поиск подстроки в блоке
				ЗначениеПоля = Сред(Блок, текПоле.НомерПервогоСимволаПоля, ?(текПоле.ДлинаПоля = 0, СтрДлина(Блок), текПоле.ДлинаПоля));
				
				ДанныеПоля = Новый Структура("Поле, ЗначениеПоля", текПоле.Поле, ЗначениеПоля);
				ДанныеДорожки.Добавить(ДанныеПоля);
			КонецЦикла;
		КонецЦикла;
		Шаблон = Новый Структура("Шаблон, ДанныеДорожек", Выборка.Ссылка, ДанныеДорожки);
		СписокШаблонов.Добавить(Шаблон);
	КонецЦикла;
	
	Если СписокШаблонов.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат СписокШаблонов;
	
КонецФункции

// Определяет соответствует ли код карты шаблону
// На входе:
// ДанныеДорожек - Массив содержащий строки кода дорожки. Всего 3 Элемента.
// ДанныеШаблона - структура содержащая данные шаблона:
//	- Суффикс
//	- Префикс
//	- РазделительБлоков
//	- ДлинаКода
// На выходе:
// Истина - код соответствует шаблону
Функция КодСоответствуетШаблонуМК(ДанныеДорожек, ДанныеШаблона)
	Для Итератор = 1 По 3 Цикл
		Если ДанныеШаблона["ДоступностьДорожки"+Строка(Итератор)] Тогда
			текСтрока = ДанныеДорожек[Итератор - 1];
			Если Прав(текСтрока, СтрДлина(ДанныеШаблона["Суффикс"+Строка(Итератор)])) <> ДанныеШаблона["Суффикс"+Строка(Итератор)]
				ИЛИ Лев(текСтрока, СтрДлина(ДанныеШаблона["Префикс"+Строка(Итератор)])) <> ДанныеШаблона["Префикс"+Строка(Итератор)]
				ИЛИ Найти(текСтрока, ДанныеШаблона["РазделительБлоков"+Строка(Итератор)]) = 0
				ИЛИ СтрДлина(текСтрока) <> ДанныеШаблона["ДлинаКода"+Строка(Итератор)] Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат Истина;
КонецФункции

// Получить таблицу товаров из XML структуры для ТСД
//
Функция ПолучитьТаблицуТоваровТСД(ДанныеЗагрузки) Экспорт
	
	Результат = Новый Массив();
	
	Если НЕ ПустаяСтрока(ДанныеЗагрузки) Тогда
		
		ЧтениеXML = Новый ЧтениеXML; 
		ЧтениеXML.УстановитьСтроку(ДанныеЗагрузки);
		ЧтениеXML.ПерейтиКСодержимому();
		
		Если ЧтениеXML.Имя = "Table" и ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда  
			Пока ЧтениеXML.Прочитать() Цикл  
				Если ЧтениеXML.Имя = "Record" и ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда  
					Результат.Добавить(ЧтениеXML.ЗначениеАтрибута("BarCode"));
					Результат.Добавить(ЧтениеXML.ЗначениеАтрибута("Quantity"));
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Сформировать таблицу товаров в XML структуре для ТСД
//
Функция СформироватьТаблицуТоваровТСД(ДанныеЗагрузки) Экспорт
	
	ЗаписьXML = Новый ЗаписьXML; 
	ЗаписьXML.УстановитьСтроку("UTF-8");
	ЗаписьXML.ЗаписатьОбъявлениеXML();

	ЗаписьXML.ЗаписатьНачалоЭлемента("Table");
	Для Каждого Позиция Из ДанныеЗагрузки  Цикл
		ЗаписьXML.ЗаписатьНачалоЭлемента("Record");
		ЗаписьXML.ЗаписатьАтрибут("BarCode"                      , Строка(Позиция[0].Значение));
		ЗаписьXML.ЗаписатьАтрибут("Name"                         , Строка(Позиция[1].Значение));
		ЗаписьXML.ЗаписатьАтрибут("UnitOfMeasurement"            , Строка(Позиция[2].Значение));
		ЗаписьXML.ЗаписатьАтрибут("CharacteristicOfNomenclature" , Строка(Позиция[3].Значение));
		ЗаписьXML.ЗаписатьАтрибут("SeriesOfNomenclature"         , Строка(Позиция[4].Значение));
		ЗаписьXML.ЗаписатьАтрибут("Quality"                      , Строка(Позиция[5].Значение));
		ЗаписьXML.ЗаписатьАтрибут("Price"                        , Строка(Позиция[6].Значение));
		ЗаписьXML.ЗаписатьАтрибут("Quantity"                     , Строка(Позиция[7].Значение));
		ЗаписьXML.ЗаписатьКонецЭлемента();
	КонецЦикла;
	ЗаписьXML.ЗаписатьКонецЭлемента();
		
	Возврат ЗаписьXML.Закрыть();
	
КонецФункции

// Сформировать таблицу товаров в XML структуре для весов с печатью этикеток
//
Функция СформироватьТаблицуТоваровВесыСПечатьюЭтикеток(ДанныеЗагрузки) Экспорт
	
	ЗаписьXML = Новый ЗаписьXML; 
	ЗаписьXML.УстановитьСтроку("UTF-8");
	ЗаписьXML.ЗаписатьОбъявлениеXML();
	
	ЗаписьXML.ЗаписатьНачалоЭлемента("Table");
	Для Каждого Позиция Из ДанныеЗагрузки  Цикл
		ЗаписьXML.ЗаписатьНачалоЭлемента("Record");
		ЗаписьXML.ЗаписатьАтрибут("PLU"         , Строка(Позиция[0].Значение));
		ЗаписьXML.ЗаписатьАтрибут("Code"        , Строка(Позиция[1].Значение));
		ЗаписьXML.ЗаписатьАтрибут("Name"        , Строка(Позиция[2].Значение));
		ЗаписьXML.ЗаписатьАтрибут("Price"       , Строка(Позиция[3].Значение));
		ЗаписьXML.ЗаписатьАтрибут("Description" , Строка(Позиция[4].Значение));
		ЗаписьXML.ЗаписатьАтрибут("ShelfLife"   , Строка(Позиция[5].Значение));
		ЗаписьXML.ЗаписатьКонецЭлемента();
	КонецЦикла;
	ЗаписьXML.ЗаписатьКонецЭлемента();
		
	Возврат ЗаписьXML.Закрыть();
	
КонецФункции

// Функция определяет тип штрихкода по значение кода
// 
Функция ОпределитьТипШтрихкода(Штрихкод) Экспорт
	
	ТипШтрихкода = "";	
	ДлинаШтрихкода = СтрДлина(Штрихкод);
	
	Если ДлинаШтрихкода = 0 Тогда
		Возврат ТипШтрихкода;
	КонецЕсли;
	
	Сумма = 0;
	
	Если ДлинаШтрихкода = 14 Тогда // ITF14
		
		Коэффициент = 1; 
		Для Сч = 1 По 13 Цикл
			КодСимв = КодСимвола(Штрихкод, Сч);
			Если КодСимв < 48 Или КодСимв > 57 Тогда
				Прервать;
			КонецЕсли;
			Сумма       = Сумма + Коэффициент * (КодСимв - 48);
			Коэффициент = 4 - Коэффициент;
		КонецЦикла;
		Сумма = (10 - Сумма % 10) % 10;
		Если КодСимвола(Штрихкод, 14) = Сумма + 48 Тогда
			ТипШтрихкода = "ITF14";
 		КонецЕсли;
		
	ИначеЕсли ДлинаШтрихкода = 13 Тогда // EAN13
		
		EAN13 = Истина;
		Коэффициент = 1;
		Для Сч = 1 По 12 Цикл
			КодСимв     = КодСимвола(Штрихкод, Сч);
			Если КодСимв < 48 Или КодСимв > 57 Тогда
				EAN13 = Ложь;
				Прервать;
			КонецЕсли;
			Сумма  = Сумма + Коэффициент * (КодСимв - 48);
			Коэффициент = 4 - Коэффициент;
		КонецЦикла;
		Сумма = (10 - Сумма % 10) % 10;
		ПроверочныйСимвол = Символ(Сумма + 48);
		Если EAN13 И ПроверочныйСимвол = Прав(Штрихкод, 1) Тогда
			ТипШтрихкода = "EAN13";
		КонецЕсли;
		
	ИначеЕсли ДлинаШтрихкода = 8 Тогда // EAN8
		
		EAN8 = Истина;
		Коэффициент = 3;
		Для Сч = 1 По 7 Цикл
			КодСимв = КодСимвола(Штрихкод, Сч);
			Если КодСимв < 48 Или КодСимв > 57 Тогда
				EAN8 = Ложь;
				Прервать;
			КонецЕсли;
			Сумма       = Сумма + Коэффициент * (КодСимв - 48);
			Коэффициент = 4 - Коэффициент;
		КонецЦикла;
		Сумма = (10 - Сумма % 10) % 10;
		Если EAN8 И (КодСимвола(Штрихкод, 8) = Сумма + 48) Тогда
			ТипШтрихкода = "EAN8";
		КонецЕсли;
		
	КонецЕсли;
	
	Если ТипШтрихкода= "" Тогда // CODE39
		
		CODE39 = Истина;
		Для Сч = 1 По ДлинаШтрихкода Цикл
			КодСимв = КодСимвола(Штрихкод, Сч);
			Если (КодСимв <> 32)
				И (КодСимв < 36 Или КодСимв > 37)
				И (КодСимв <> 43)
				И (КодСимв < 45 Или КодСимв > 57)
				И (КодСимв < 65 Или КодСимв > 90) Тогда
				CODE39 = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если CODE39 Тогда
			ТипШтрихкода = "CODE39";
		КонецЕсли                                                     
		
	КонецЕсли;
	
	Если ТипШтрихкода= ""  Тогда // CODE128
		// CODE128 — символы ASCII от 0 до 127 (цифры от «0» до «9», буквы от «A» до «Z» и от «a» до «z») и специальные символы;
		CODE128 = Истина;
		Для Сч = 1 По ДлинаШтрихкода Цикл
			КодСимв = КодСимвола(Штрихкод, Сч);
			Если (КодСимв > 127) Тогда
				CODE128 = Ложь;
			Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если CODE128 Тогда
			ТипШтрихкода = "CODE128";
		КонецЕсли                                                     
		
	КонецЕсли;
	
	Если ТипШтрихкода= "CODE128"  Тогда // EAN128
		// В коде EAN128 регламентирован словарь CODE128 но регламентированы группы кодов
		Если КодСимвола(Штрихкод, 1) = 40 Тогда
			ТипШтрихкода = "EAN128";
		КонецЕсли;
	КонецЕсли;
	
	Возврат ТипШтрихкода;
	
КонецФункции

// Функция выполняет формирование изображения штрихкода.
// Параметры: 
//   ПараметрыШтрихкода 
// Возвращаемое значение: 
//   Картинка - Картинка со сформированным штрихкодом или НЕОПРЕДЕЛЕНО
Функция ПолучитьКартинкуШтрихкода(ПараметрыШтрихкода) Экспорт
	
	ВнешняяКомпонента = ИНАГРО_МенеджерОборудованияСерверПовтИсп.ПодключитьВнешнююКомпонентуПечатиШтрихкода();
	
	Если ВнешняяКомпонента = Неопределено Тогда
		ВызватьИсключение НСтр("ru='Ошибка подключения внешней компоненты печати штрихкода!';uk='Помилка підключення зовнішньої компоненти друку штрихкоду!'");
	КонецЕсли;
	
	// Зададим размер картинки
	ВнешняяКомпонента.Ширина = Окр(ПараметрыШтрихкода.Ширина);
	ВнешняяКомпонента.Высота = Окр(ПараметрыШтрихкода.Высота);
	
	ВнешняяКомпонента.АвтоТип = Ложь;
	
	Если ПараметрыШтрихкода.ТипКода = 99 Тогда
		ТипШтрихкодаВрем = ОпределитьТипШтрихкода(ПараметрыШтрихкода.Штрихкод);
		Если ТипШтрихкодаВрем = "EAN8" Тогда
			ВнешняяКомпонента.ТипКода = 0;
		ИначеЕсли ТипШтрихкодаВрем = "EAN13" Тогда
			ВнешняяКомпонента.ТипКода = 1;
			// Если код содержит контрольный символ, обязательно указываем
			ВнешняяКомпонента.СодержитКС = СтрДлина(ПараметрыШтрихкода.Штрихкод) = 13;
		ИначеЕсли ТипШтрихкодаВрем = "EAN128" Тогда
			ВнешняяКомпонента.ТипКода = 2;
		ИначеЕсли ТипШтрихкодаВрем = "CODE39" Тогда
			ВнешняяКомпонента.ТипКода = 3;
		ИначеЕсли ТипШтрихкодаВрем = "CODE128" Тогда
			ВнешняяКомпонента.ТипКода = 4;
		ИначеЕсли ТипШтрихкодаВрем = "ITF14" Тогда
			ВнешняяКомпонента.ТипКода = 11;
		Иначе
			ВнешняяКомпонента.АвтоТип = Истина;
		КонецЕсли;
	Иначе
		ВнешняяКомпонента.АвтоТип = Ложь;
		ВнешняяКомпонента.ТипКода = ПараметрыШтрихкода.ТипКода;
	КонецЕсли;
	
	Если ПараметрыШтрихкода.Свойство("ПрозрачныйФон") Тогда
		ВнешняяКомпонента.ПрозрачныйФон = ПараметрыШтрихкода.ПрозрачныйФон;
	КонецЕсли;

	ВнешняяКомпонента.ОтображатьТекст = ПараметрыШтрихкода.ОтображатьТекст;
	
	// Формируем картинку штрихкода
	ВнешняяКомпонента.ЗначениеКода = ПараметрыШтрихкода.Штрихкод;
	
	Если ПараметрыШтрихкода.Свойство("УголПоворота") Тогда
		ВнешняяКомпонента.УголПоворота = ПараметрыШтрихкода.УголПоворота;
	Иначе
		ВнешняяКомпонента.УголПоворота = 0;
	КонецЕсли;
	
	// Если установленная нами ширина меньше минимально допустимой для этого штрихкода
	Если ВнешняяКомпонента.Ширина < ВнешняяКомпонента.МинимальнаяШиринаКода Тогда
		ВнешняяКомпонента.Ширина = ВнешняяКомпонента.МинимальнаяШиринаКода;
	КонецЕсли;
	
	// Если установленная нами высота меньше минимально допустимой для этого штрихкода
	Если ВнешняяКомпонента.Высота < ВнешняяКомпонента.МинимальнаяВысотаКода Тогда
		ВнешняяКомпонента.Высота = ВнешняяКомпонента.МинимальнаяВысотаКода;
	КонецЕсли;

	Если ПараметрыШтрихкода.Свойство("РазмерШрифта") И (ПараметрыШтрихкода.РазмерШрифта > 0) 
		И (ПараметрыШтрихкода.ОтображатьТекст) И (ВнешняяКомпонента.РазмерШрифта <> ПараметрыШтрихкода.РазмерШрифта) Тогда
		ВнешняяКомпонента.РазмерШрифта = ПараметрыШтрихкода.РазмерШрифта;
	КонецЕсли;
	
	// Сформируем картинку
	ДвоичныеДанныеКартинки = ВнешняяКомпонента.ПолучитьШтрихкод();
	
	// Если картинка сформировалась
	Если ДвоичныеДанныеКартинки <> Неопределено Тогда
		// Формируем из двоичных данных
		Возврат Новый Картинка(ДвоичныеДанныеКартинки);
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции


// Получить таблицу товаров из XML структуры для ТСД
//
Функция ПолучитьТаблицуТоваров(ДанныеЗагрузки) Экспорт
	
	Результат = Новый Массив();
	
	Если НЕ ПустаяСтрока(ДанныеЗагрузки) Тогда
		
		ЧтениеXML = Новый ЧтениеXML; 
		ЧтениеXML.УстановитьСтроку(ДанныеЗагрузки);
		ЧтениеXML.ПерейтиКСодержимому();
		
		Если ЧтениеXML.Имя = "Table" и ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда  
			Пока ЧтениеXML.Прочитать() Цикл  
				Если ЧтениеXML.Имя = "Record" и ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда  
					Результат.Добавить(ЧтениеXML.ЗначениеАтрибута("BarCode"));
					Результат.Добавить(ЧтениеXML.ЗначениеАтрибута("Quantity"));
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Сформировать таблицу товаров в XML структуре для ТСД
//
Функция СформироватьТаблицуТоваров(ДанныеЗагрузки) Экспорт
	
	Результат = Новый Массив();
	
	ЗаписьXML = Новый ЗаписьXML; 
	ЗаписьXML.УстановитьСтроку("UTF-8");
	ЗаписьXML.ЗаписатьОбъявлениеXML();

	ЗаписьXML.ЗаписатьНачалоЭлемента("Table");
	Для Каждого Позиция Из ДанныеЗагрузки  Цикл
		ЗаписьXML.ЗаписатьНачалоЭлемента("Record");
		ЗаписьXML.ЗаписатьАтрибут("BarCode", Позиция[0].Значение);
		ЗаписьXML.ЗаписатьАтрибут("Name", Строка(Позиция[1].Значение));
		ЗаписьXML.ЗаписатьАтрибут("UnitOfMeasurement", Строка(Позиция[2].Значение));
		ЗаписьXML.ЗаписатьАтрибут("CharacteristicOfNomenclature", Строка(Позиция[3].Значение));
		ЗаписьXML.ЗаписатьАтрибут("SeriesOfNomenclature", Строка(Позиция[4].Значение));
		ЗаписьXML.ЗаписатьАтрибут("Quality", Строка(Позиция[5].Значение));
		ЗаписьXML.ЗаписатьАтрибут("Price", Строка(Позиция[6].Значение));
		ЗаписьXML.ЗаписатьАтрибут("Quantity", Строка(Позиция[7].Значение));
		ЗаписьXML.ЗаписатьКонецЭлемента();
	КонецЦикла;
	ЗаписьXML.ЗаписатьКонецЭлемента();
    	
	Возврат ЗаписьXML.Закрыть();
	
КонецФункции

// Сформировать таблицу доп.реквизитов для реализации
//
Функция СформироватьТаблицуДопРеквизитов(ДанныеЗагрузки) Экспорт
	
	Результат = Новый Массив();
	
	ЗаписьXML = Новый ЗаписьXML; 
	ЗаписьXML.УстановитьСтроку("UTF-8");
	ЗаписьXML.ЗаписатьОбъявлениеXML();

	ЗаписьXML.ЗаписатьНачалоЭлемента("Table");
	Для Каждого Позиция Из ДанныеЗагрузки  Цикл
		ЗаписьXML.ЗаписатьНачалоЭлемента("Record");
		ЗаписьXML.ЗаписатьАтрибут("VAT", Позиция[0]);
		ЗаписьXML.ЗаписатьАтрибут("IsExcisable", Строка(Формат(Позиция[1], "БЛ=False; БИ=True")));
		ЗаписьXML.ЗаписатьКонецЭлемента();
	КонецЦикла;
	ЗаписьXML.ЗаписатьКонецЭлемента();
    	
	Возврат ЗаписьXML.Закрыть();
	
КонецФункции

// Получить таблицу доп.реквизитов из XML структуры
//
Функция ПолучитьТаблицуДопРеквизитов(ДанныеЗагрузки) Экспорт
	
	Результат = Новый Массив();
	
	Если НЕ ПустаяСтрока(ДанныеЗагрузки) Тогда
		
		ЧтениеXML = Новый ЧтениеXML; 
		ЧтениеXML.УстановитьСтроку(ДанныеЗагрузки);
		ЧтениеXML.ПерейтиКСодержимому();
		
		Если ЧтениеXML.Имя = "Table" и ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда  
			Пока ЧтениеXML.Прочитать() Цикл  
				Если ЧтениеXML.Имя = "Record" и ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда  
					Результат.Добавить(ЧтениеXML.ЗначениеАтрибута("VAT"));
					Результат.Добавить(Булево(ЧтениеXML.ЗначениеАтрибута("IsExcisable")));
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ПолучитьМетодРаботыДрайвера(Оборудование) Экспорт

	АсинхронныйМетодРаботы = Ложь;
	
	Запрос = Новый Запрос;
	Запрос.Текст ="ВЫБРАТЬ
	              |	ПодключаемоеОборудование.ДрайверОборудования.АсинхронныйМетодРаботы КАК АсинхронныйМетодРаботы
	              |ИЗ
	              |	Справочник.ИНАГРО_ПодключаемоеОборудование КАК ПодключаемоеОборудование
	              |ГДЕ
	              |	ПодключаемоеОборудование.Ссылка = &Оборудование";
	
	Запрос.УстановитьПараметр("Оборудование", Оборудование);
	Результат = Запрос.Выполнить().Выбрать();
	
	Если Результат.Следующий() Тогда
		АсинхронныйМетодРаботы = Результат.АсинхронныйМетодРаботы;	
	КонецЕсли;	
	
	Возврат АсинхронныйМетодРаботы;

КонецФункции

#КонецОбласти