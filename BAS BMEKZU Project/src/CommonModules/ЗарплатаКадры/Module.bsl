////////////////////////////////////////////////////////////////////////////////
// ПРОГРАММНЫЙ ИНТЕРФЕЙС

// Выполняет действия в форме Организации, связанные с зарплатно-кадровой спецификой 
// Вызов процедуры необходимо выполнять в обработчике ПриСозданииНаСервере
// формы организации
Процедура ОрганизацииФормаЭлементаПриСозданииНаСервере(Форма) Экспорт
	Форма.УстановитьПараметрыФункциональныхОпцийФормы(Новый Структура("Организация", Форма.Объект.Ссылка));
КонецПроцедуры

Функция ВалютаУчетаЗаработнойПлаты() Экспорт

	Возврат Справочники.Валюты.НайтиПоКоду("980");

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЙ ПРОГРАММНЫЙ ИНТЕРФЕЙС

// Выполняет заполнение первоначальных значений при создании новых 
// объектов или открытии иных форм
// Параметры:
//		Форма - форма, реквизиты которой необходимо заполнить
//		ЗапрашиваемыеЗначения - структура с запрашиваемыми значениями
//			Имя элемента структуры идентифицирует значение, которое 
//				необходимо заполнить
//			Значение элемента структуры - путь к реквизиту формы, значение
//				которого необходимо заполнить
//			Список поддерживаемых значений см. в описании ПолучитьЗначенияПоУмолчанию
//
Процедура ЗаполнитьПервоначальныеЗначенияВФорме(Форма, ЗапрашиваемыеЗначения) Экспорт
	
	ЗаполнитьЗначенияВФорме(Форма, ЗапрашиваемыеЗначения);
	
КонецПроцедуры

// Получает значения по умолчанию
// Параметры:
//		ЗаполняемыеЗначения - структура, 
//				Ключи структуры - идентификаторы запрашиваемых значений, 
//				Значения полей структуры заполняются процедурой приведены ниже
//
//				Процедура поддерживает получение значений по умолчанию, которые 
//				зависят от других значений.
//				Например, для получения значения ДолжностьРуководителя для 
//				конкретной организации можно передать структуру с полями Организация и 
//				ДолжностьРуководителя, причем поле Организация заполнить конкретным значением
//				В результате выполнения процедуры поле ДолжностьРуководителя
//				будет заполнено значением по умолчанию
//
//		ЗаполненныеЗначения - (необязательный) массив, 
//				Содержит идентификаторы уже заполненных значений, 
//				Значения - уже заполненные значения
//				На основании уже заполненных значений, могут быть 
//				заполнены, например, данные организации (НаименованиеПРФ и т.п.)
//		
//		Допустимые идентификаторы запрашиваемых значений:
//				Год	
//				Месяц	
//				ПредыдущийГод	
//				ПредыдущийМесяц	
//				ПредыдущийКвартал
//				Ответственный
//				-----------------
//				Организация
//				Руководитель
//				ГлавныйБухгалтер
//				ДолжностьРуководителя
//				Подразделение
//
Процедура ПолучитьЗначенияПоУмолчанию(ЗаполняемыеЗначения) Экспорт
	
	// Для проверки параметров
	// Массив поддерживаемых идентификаторов заполняемых значений
	ПоддерживаемыеИдентификаторы = ЗарплатаКадрыВнутренний.СписокДоступныхЗначенийПоУмолчанию();
	
	Для Каждого КлючЗначение Из ЗаполняемыеЗначения Цикл
		Если ПоддерживаемыеИдентификаторы.Найти(КлючЗначение.Ключ) = НеОпределено Тогда
			// не все запрашиваемые данные можем заполнить
			ТекстИсключения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru='Невозможно получение значения ""%1"" для заполнения в форме';uk='Неможливо отримання значення ""%1"" для заповнення в формі'"),
				КлючЗначение.Ключ);
			ВызватьИсключение ТекстИсключения;
		КонецЕсли;
	КонецЦикла;
	
	// Значения по умолчанию получаем в цикле для того, чтобы заполнить как 
	// "первичные", так и зависимые значения.
	Пока Истина Цикл
		НеОпределеноДо = КоличествоНеОпределенныхЗначений(ЗаполняемыеЗначения);
		ЗарплатаКадрыВнутренний.ПолучитьЗначенияПоУмолчанию(ЗаполняемыеЗначения);
		ЗарплатаКадрыПереопределяемый.ПолучитьЗначенияПоУмолчанию(ЗаполняемыеЗначения);
		ПолучитьЕдинственныеЗначенияТипов(ЗаполняемыеЗначения);
		НеОпределеноПосле = КоличествоНеОпределенныхЗначений(ЗаполняемыеЗначения);
		Если НеОпределеноДо = НеОпределеноПосле Или НеОпределеноПосле = 0 Тогда
			// Ничего не заполнили или уже все заполнили
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Процедура получает ссылочные значений, имеющиеся в базе в единственном экземпляре.
// Параметры:
//		ЗаполняемыеЗначения - структура, 
//				Ключи структуры - идентификаторы запрашиваемых значений, 
//				Значения полей должны быть заполнены, как минимум пустой ссылкой(для ссылочных полей)
//
// Допущения реализации:
//	1. Если в переданной структуре находятся 2 элемента одинакового типа
// 		и этот тип является типом владельца подбираемого значения, то в качестве владельца всегда будет использоваться первый заполненный элемент
//  2. Не учитываются возможные связи параметров выбора
//
Процедура ПолучитьЕдинственныеЗначенияТипов(ЗаполняемыеЗначения) Экспорт

	Запрос = Новый Запрос;
	ТекстОсновногоЗапроса  = "";
	
	СтрокаЗаменыОбъединить  = "
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|";
	
	СтрокаЗаменыРазрешенные = "РАЗРЕШЕННЫЕ";
	
	НомерПараметра = 0;
	
	Для каждого ЗаполняемоеЗначение Из ЗаполняемыеЗначения Цикл
		Если ЗначениеЗаполнено(ЗаполняемоеЗначение.Значение) ИЛИ ЗаполняемоеЗначение.Значение = Неопределено Тогда
			Продолжить;	
		КонецЕсли;
		
		Тип = ТипЗнч(ЗаполняемоеЗначение.Значение);
		Если НЕ ОбщегоНазначения.ЭтоСсылка(Тип) Тогда
			Продолжить;
		КонецЕсли; 
		
		МетаданныеТипа = Метаданные.НайтиПоТипу(Тип);
		
		ТекстОсновногоЗапроса = СтрЗаменить(ТекстОсновногоЗапроса, "#ОБЪЕДИНИТЬ#", СтрокаЗаменыОбъединить);
		
		ТекстОсновногоЗапроса = ТекстОсновногоЗапроса + "ВЫБРАТЬ #РАЗРЕШЕННЫЕ# ПЕРВЫЕ 2 """ + ЗаполняемоеЗначение.Ключ + """ КАК Поле,
		|	" + МетаданныеТипа.Имя + ".Ссылка КАК Ссылка
		| из " + МетаданныеТипа.ПолноеИмя() + " КАК " + МетаданныеТипа.Имя + "    
		|#ОБЪЕДИНИТЬ#";
		
		ТекстОсновногоЗапроса = СтрЗаменить(ТекстОсновногоЗапроса, "#РАЗРЕШЕННЫЕ#", СтрокаЗаменыРазрешенные);
		СтрокаЗаменыРазрешенные = "";
	КонецЦикла;
	
	ТекстОсновногоЗапроса = СтрЗаменить(ТекстОсновногоЗапроса, "#ОБЪЕДИНИТЬ#", "
	|ИТОГИ ПО
	| Поле");
	
	Если НЕ ПустаяСтрока(ТекстОсновногоЗапроса) Тогда
		Запрос.Текст = ТекстОсновногоЗапроса;
		Результат = Запрос.Выполнить();
		Если Не Результат.Пустой() Тогда
			Выборка = Результат.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
			Пока Выборка.Следующий() Цикл
				ВыборкаПоПолю = Выборка.Выбрать();
				Если ВыборкаПоПолю.Количество() = 1 Тогда
					ВыборкаПоПолю.Следующий();
					ЗаполняемыеЗначения[ВыборкаПоПолю.Поле] = ВыборкаПоПолю.Ссылка;
				КонецЕсли;
			КонецЦикла;	
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

// Выполняет формирование таблицы с набором значений доступа объекта (документа), 
// содержащего ссылки на организацию и сотрудника (сотрудников)
// Вызывается из процедуры ЗаполнитьНаборыЗначенийДоступа, реализованной в модуле таких 
// документов, доступ к которым выполняется через наборы значений доступа
// Параметры:
//		Объект
//		Таблица - переданная таблица значений
//		ПутьОрганизация - строка с именем реквизита, содержащего организацию
//		ПутьФизическоеЛицо - строка с именем реквизита, содержащего физическое лицо
//			Может быть идентификатором реквизита объекта (например, "ФизическоеЛицо") или
//			путем к реквизиту табличной части в 
//			формате <ИмяТабличнойЧасти>.<ИмяРеквизита> 
//			(например, "ФизическиеЛица.ФизическоеЛицо")
//
Процедура ЗаполнитьНаборыПоОрганизацииИФизическимЛицам(Объект, Таблица, ПутьОрганизация, ПутьФизическоеЛицо, НомерНабора = 0) Экспорт
	
	// Логика ограничения:
	// объект доступен, если доступна организация и все физические лица
	
	СтрокаТаб = Таблица.Добавить();
	СтрокаТаб.ЗначениеДоступа = Объект[ПутьОрганизация];
	СтрокаТаб.НомерНабора = НомерНабора;
	
	СтрокиПутиФизическогоЛица = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьФизическоеЛицо, ".");
	Если СтрокиПутиФизическогоЛица.Количество() = 0 Тогда
		//Нет физических лиц
	ИначеЕсли СтрокиПутиФизическогоЛица.Количество() = 1 Тогда
		СтрокаТаб = Таблица.Добавить();
		СтрокаТаб.ЗначениеДоступа = Объект[ПутьФизическоеЛицо];
		СтрокаТаб.НомерНабора = НомерНабора;
		
	Иначе
		Для Каждого СтрокаТаблицы Из Объект[СтрокиПутиФизическогоЛица[0]] Цикл
			СтрокаТаб = Таблица.Добавить();
			СтрокаТаб.ЗначениеДоступа = СтрокаТаблицы[СтрокиПутиФизическогоЛица[1]];
			СтрокаТаб.НомерНабора = НомерНабора;
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры


// Функция определяет является ли организация юридическим лицом 
// "по правилам" регламентированной отчетности
// 
Функция ЭтоЮридическоеЛицо(Организация) Экспорт
	Возврат ЗарплатаКадрыПовтИсп.ЭтоЮридическоеЛицо(Организация);
КонецФункции

// Возвращает структуру с параметрами формирования таблицы "записей", "среза последних" для процедур 
// СоздатьПоВременнойТаблицеВТИмяРегистра, СоздатьПоВременнойТаблицеВТИмяРегистраСрез 
//
// Параметры:
//		МенеджерВременныхТаблиц
//		ИмяВТИзмеренияДаты - имя временной таблицы - "фильтра"
//		ИзмеренияРегистра - строка с именами измерений регистра, разделенных символом ",",
//							по которым будет осуществляться фильтрация
//
// Возвращаемое значение:
//		Структура с полями:
//			МенеджерВременныхТаблиц
//			ИмяВТИзмеренияДаты - имя временной таблицы с параметрами среза.
//			Измерения - 		 массив с именами измерений, по которым будет получен "Срез последних"
//								 Может содержать колонки с именами, совпадающими с именами 
//								 измерений регистра сведений		
Функция ПараметрыДляСоздатьПоВременнойТаблицеВТИмяРегистра(МенеджерВременныхТаблиц, ИмяВТИзмеренияДаты, ИзмеренияРегистра) Экспорт
	
	МассивИзмерений = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИзмеренияРегистра, ",");
	
	ОписаниеПараметров = Новый Структура;
	ОписаниеПараметров.Вставить("МенеджерВременныхТаблиц", МенеджерВременныхТаблиц);
	ОписаниеПараметров.Вставить("ИмяВТИзмеренияДаты", ИмяВТИзмеренияДаты);
	ОписаниеПараметров.Вставить("Измерения", МассивИзмерений);
	
	Возврат ОписаниеПараметров;
	
КонецФункции 	

// Формирует временную таблицу с последними значениями ресурсов заданного регистра сведений
// Параметры:
//		МенеджерВременныхТаблиц
//
//		ТолькоРазрешенные - если истина, выбираются только разрешенные записи
//
//		ИмяРегистра - имя регистра сведений (не полное)
//
//		ИзмеренияДаты - таблица значений
//			Должна обязательно содержать колонку "Период"
//			Может содержать колонки с именами, совпадающими с именами 
//			измерений регистра сведений
//
//			Используется как фильтр - переданные в ней значения измерений "фильтруют" регистр.
//			В зависимости от значения параметра ВсеЗаписи строки ИзмеренияДаты используются 
//			не только как фильтр, но и как набор значений для дополнения результирующей 
//			временной таблицы.
//			Содержит даты получения последних значений ресурсов.
//			В предельном случае, когда нет колонок таблицы, соответствующих измерениям, 
//			(т.е. фильтрация по измерениям не выполняется), в таблице содержится одна строка 
//			с датой на которую нужно получить значения ресурсов.
//
//		Отбор - коллекция условий отбора, соединяемых по "И" и применяемых к регистру сведений
//			Коллекция строки которой имеют поля
//				ЛевоеЗначение - строка, имя поля регистра сведений
//				ВидСравнения - строка, вид сравнения, допустимый в языке запросов
//				ПравоеЗначение - значение для сравнения с полем ЛевоеЗначение
//
//		ВсеЗаписи - булево значение. 
//			Если Истина, то в результирующей временной таблице
//			должно быть столько же записей, сколько передано в параметре ИзмеренияДаты
//			Если Ложь, то временная таблица содержит записи только для тех 
//			значений измерений, для которых существуют данные в регистре
//			По умолчанию - Ложь
//		
//		ВключаяГраницу - булево значение.	
//			Если Истина, то записи на дату формирования среза учитываются
//			Если Ложь, то записи на дату формирования среза не учитываются
//			По умолчанию - Истина  
//
// Создает в МенеджерВременныхТаблиц временную таблицу с именем ВТ<ИмяРегистра>СрезПоследних.
// Например: ВТПлановыеНачисленияСрезПоследних
// Поля временной таблицы
//	- Период
//	- Все измерения (не только переданные в качестве фильтра, а все)
//	- Все ресурсы без постфикса ПоОкончании
//	- Все реквизиты
//
Процедура СоздатьПоТаблицеЗначенийВТИмяРегистраСрезПоследних(МенеджерВременныхТаблиц, ТолькоРазрешенные, ИмяРегистра, ИзмеренияДаты, Отбор = Неопределено, ВсеЗаписи = Ложь, ВключаяГраницу = Истина) Экспорт
	СоздатьПоТаблицеЗначенийВТИмяРегистраСрез(МенеджерВременныхТаблиц, ТолькоРазрешенные, ИмяРегистра, ИзмеренияДаты, Отбор, ВсеЗаписи, ВключаяГраницу, Истина);
КонецПроцедуры

// Формирует временную таблицу с первыми значениями ресурсов заданного регистра сведений, описание 
// параметров см. СоздатьПоТаблицеЗначенийВТИмяРегистраСрезПоследних
//
Процедура СоздатьПоТаблицеЗначенийВТИмяРегистраСрезПервых(МенеджерВременныхТаблиц, ТолькоРазрешенные, ИмяРегистра, ИзмеренияДаты, Отбор = Неопределено, ВсеЗаписи = Ложь, ВключаяГраницу = Истина) Экспорт
	СоздатьПоТаблицеЗначенийВТИмяРегистраСрез(МенеджерВременныхТаблиц, ТолькоРазрешенные, ИмяРегистра, ИзмеренияДаты, Отбор, ВсеЗаписи, ВключаяГраницу, Ложь);
КонецПроцедуры

// Формирует временную таблицу с последними значениями ресурсов заданного регистра сведений
// Параметры:
//
//		ПараметрыСреза - структура полученная функцией ПараметрыСрезаПоследних
//			Содержит следующие поля:
//							МенеджерВременныхТаблиц
//							ИмяВТИзмеренияДаты - имя временной таблицы с параметрами среза.
//												 Должна обязательно поле "Период"
//												 Используется как фильтр - переданные в ней значения измерений "фильтруют" регистр.
//												 В зависимости от значения параметра ВсеЗаписи строки ИзмеренияДаты используются 
//												 не только как фильтр, но и как набор значений для дополнения результирующей 
//												 временной таблицы.
//												 Содержит даты получения последних значений ресурсов.
//												 В предельном случае, когда нет колонок таблицы, соответствующих измерениям, 
//												 (т.е. фильтрация по измерениям не выполняется), в таблице содержится одна строка 
//												 с датой на которую нужно получить значения ресурсов.
//							Измерения - массив с именами измерений, по которым будет получен "Срез последних"
//										Может содержать колонки с именами, совпадающими с именами 
//										измерений регистра сведений
//
//		ТолькоРазрешенные - если истина, выбираются только разрешенные записи
//
//		ИмяРегистра - имя регистра сведений (не полное)
//			
//		Отбор - коллекция условий отбора, соединяемых по "И" и применяемых к регистру сведений
//			Коллекция строки которой имеют поля
//				ЛевоеЗначение - строка, имя поля регистра сведений
//				ВидСравнения - строка, вид сравнения, допустимый в языке запросов
//				ПравоеЗначение - значение для сравнения с полем ЛевоеЗначение
//
//		ВсеЗаписи - булево значение. 
//			Если Истина, то в результирующей временной таблице
//			должно быть столько же записей, сколько передано в параметре ИзмеренияДаты
//			Если Ложь, то временная таблица содержит записи только для тех 
//			значений измерений, для которых существуют данные в регистре
//			По умолчанию - Ложь
//		
//		ВключаяГраницу - булево значение.	
//			Если Истина, то записи на дату формирования среза учитываются
//			Если Ложь, то записи на дату формирования среза не учитываются
//			По умолчанию - Истина  
//
// Создает в МенеджерВременныхТаблиц временную таблицу с именем ВТ<ИмяРегистра>СрезПоследних.
// Например: ВТПлановыеНачисленияСрезПоследних
// Поля временной таблицы
//	- Период
//	- Все измерения (не только переданные в качестве фильтра, а все)
//	- Все ресурсы без постфикса ПоОкончании
//	- Все реквизиты
//
Процедура СоздатьПоВременнойТаблицеВТИмяРегистраСрезПоследних(ПараметрыСреза, ТолькоРазрешенные, ИмяРегистра, Отбор = Неопределено, ВсеЗаписи = Ложь, ВключаяГраницу = Истина) Экспорт
	СоздатьПоВременнойТаблицеВТИмяРегистраСрез(ПараметрыСреза, ТолькоРазрешенные,  ИмяРегистра, Отбор, ВсеЗаписи, ВключаяГраницу, Истина)
КонецПроцедуры

// Формирует временную таблицу с первыми значениями ресурсов заданного регистра сведений, описание 
// параметров см. СоздатьПоВременнойТаблицеВТИмяРегистраСрезПоследних
//
Процедура СоздатьПоВременнойТаблицеВТИмяРегистраСрезПервых(ПараметрыСреза, ТолькоРазрешенные, ИмяРегистра, Отбор = Неопределено, ВсеЗаписи = Ложь, ВключаяГраницу = Истина) Экспорт
	СоздатьПоВременнойТаблицеВТИмяРегистраСрез(ПараметрыСреза, ТолькоРазрешенные,  ИмяРегистра, Отбор, ВсеЗаписи, ВключаяГраницу, Ложь)
КонецПроцедуры

// Формирует временную таблицу с записями заданного регистра сведений
// Параметры:
//		МенеджерВременныхТаблиц
//
//		ТолькоРазрешенные - если истина, выбираются только разрешенные записи
//
//		ИмяРегистра - имя регистра сведений (не полное)
//
//		ИзмеренияДаты - таблица значений
//			Должна обязательно содержать колонки "ДатаНачала" и "ДатаОкончания"
//			Может содержать колонки с именами, совпадающими с именами 
//			измерений регистра сведений
//			Используется как фильтр - переданные в ней значения измерений "фильтруют" регистр.
//
//		Отбор - коллекция условий отбора, соединяемых по "И" и применяемых к регистру сведений
//			Коллекция строки которой имеют поля
//				ЛевоеЗначение - строка, имя поля регистра сведений
//				ВидСравнения - строка, вид сравнения, допустимый в языке запросов
//				ПравоеЗначение - значение для сравнения с полем ЛевоеЗначение
//
//			
// Создает в МенеджерВременныхТаблиц временную таблицу с именем ВТ<ИмяРегистра>.
// Например: ВТПлановыеНачисления
// Поля временной таблицы
//	- Период
//	- Все измерения 
//	- Все ресурсы 
//	- Все реквизиты
//	- Все стандартные реквизиты
//
Процедура СоздатьПоТаблицеЗначенийВТИмяРегистра(МенеджерВременныхТаблиц, ТолькоРазрешенные, ИмяРегистра, ИзмеренияДаты, Отбор = Неопределено) Экспорт
	
	МассивИзмерений = Новый Массив;
	Для Каждого Колонка Из ИзмеренияДаты.Колонки Цикл
		МассивИзмерений.Добавить(Колонка.Имя);		
	КонецЦикла;	
	
	КоллекцииПолей = КоллекцииПолейДляПодготовкиТекстаЗапроса(ИмяРегистра, МассивИзмерений);
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ИзмеренияДаты", ИзмеренияДаты);
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	
	ИмяВТИзмеренияДаты = УникальноеИмяВременнойТаблицы("ВТИзмеренияДаты");
	
	ТекстЗапроса = 
	"ВЫБРАТЬ";
	Для Каждого Измерение Из КоллекцииПолей.ИзмеренияФильтра Цикл
		ТекстЗапроса = ТекстЗапроса + "
		|	ИзмеренияДаты." + Измерение + ",";
	КонецЦикла;
	
	ТекстЗапроса = ТекстЗапроса + "
	|	ИзмеренияДаты.ДатаНачала,
	|	ИзмеренияДаты.ДатаОкончания,";
	
	ТекстЗапроса = Лев(ТекстЗапроса, СтрДлина(ТекстЗапроса) - 1);
	
	ТекстЗапроса = ТекстЗапроса + "
	|ПОМЕСТИТЬ " + ИмяВТИзмеренияДаты + "
	|ИЗ
	|	&ИзмеренияДаты КАК ИзмеренияДаты";
	
	Запрос.Текст = ТекстЗапроса;
	Запрос.Выполнить();
	
	ЗапросВТИмяРегистра = ЗапросВТИмяРегистра(ТолькоРазрешенные, КоллекцииПолей, ИмяРегистра, ИмяВТИзмеренияДаты, "", Отбор);
	ЗапросВТИмяРегистра.МенеджерВременныхТаблиц = Запрос.МенеджерВременныхТаблиц;
	
	ДобавитьТекстУдаленияВременнойТаблицы(ЗапросВТИмяРегистра.Текст, ИмяВТИзмеренияДаты);
	
	ЗапросВТИмяРегистра.Выполнить();
	
КонецПроцедуры

// Формирует временную таблицу с записями заданного регистра сведений
// Параметры:
//
//		ПараметрыЗапроса - структура полученная функцией ПараметрыДляСоздатьПоВременнойТаблицеВТИмяРегистра
//			Содержит следующие поля:
//							ИмяВТИзмеренияДаты - имя временной таблицы с параметрами среза.
//												 Должна обязательно поле "Период"
//												 Используется как фильтр - переданные в ней значения измерений "фильтруют" регистр.
//												 В зависимости от значения параметра ВсеЗаписи строки ИзмеренияДаты используются 
//												 не только как фильтр, но и как набор значений для дополнения результирующей 
//												 временной таблицы.
//												 Содержит даты получения последних значений ресурсов.
//												 В предельном случае, когда нет колонок таблицы, соответствующих измерениям, 
//												 (т.е. фильтрация по измерениям не выполняется), в таблице содержится одна строка 
//												 с датой на которую нужно получить значения ресурсов.
//							Измерения - массив с именами измерений, по которым будет получен "Срез последних"
//										Может содержать колонки с именами, совпадающими с именами 
//										измерений регистра сведений
//							МенеджерВременныхТаблиц - менеджер-получатель таблицы ВТ<ИмяРегистра>
//
//		ТолькоРазрешенные - если истина, выбираются только разрешенные записи
//
//		ИмяРегистра - имя регистра сведений (не полное)
//
//		Отбор - коллекция условий отбора, соединяемых по "И" и применяемых к регистру сведений
//			Коллекция строки которой имеют поля
//				ЛевоеЗначение - строка, имя поля регистра сведений
//				ВидСравнения - строка, вид сравнения, допустимый в языке запросов
//				ПравоеЗначение - значение для сравнения с полем ЛевоеЗначение
//
//			
// Создает в МенеджерВременныхТаблиц временную таблицу с именем ВТ<ИмяРегистра>.
// Например: ВТПлановыеНачисления
// Поля временной таблицы
//	- Период
//	- Все измерения
//	- Все ресурсы
//	- Все реквизиты
//	- Все стандартные реквизиты
//
Процедура СоздатьПоВременнойТаблицеВТИмяРегистра(ПараметрыЗапроса, ТолькоРазрешенные,  ИмяРегистра, Отбор = Неопределено) Экспорт
	
	КоллекцииПолей = КоллекцииПолейДляПодготовкиТекстаЗапроса(ИмяРегистра, ПараметрыЗапроса.Измерения);
	
	ЗапросВТИмяРегистра = ЗапросВТИмяРегистра(ТолькоРазрешенные, КоллекцииПолей, ИмяРегистра, ПараметрыЗапроса.ИмяВТИзмеренияДаты, "", Отбор);
	ЗапросВТИмяРегистра.МенеджерВременныхТаблиц = ПараметрыЗапроса.МенеджерВременныхТаблиц;
	
	ЗапросВТИмяРегистра.Выполнить();
	
КонецПроцедуры

// Помещает в переданный массив имена реквизитов формы
// Параметры:
//		Форма
//		МассивИменРеквизитовФормы
//      ПутьКДанным
//
Процедура ЗаполнитьМассивИменРеквизитовФормы(Форма, МассивИменРеквизитовФормы,  ПутьКДанным = "") Экспорт
	
	Если ЗначениеЗаполнено(ПутьКДанным) Тогда
		МассивРеквизитовФормы = Форма.ПолучитьРеквизиты(ПутьКДанным);
	Иначе
		МассивРеквизитовФормы = Форма.ПолучитьРеквизиты();
	КонецЕсли;
	
	Для Каждого Реквизит Из МассивРеквизитовФормы Цикл
		МассивИменРеквизитовФормы.Добавить(?(ЗначениеЗаполнено(ПутьКДанным), ПутьКДанным + ".", "") + Реквизит.Имя);	
	КонецЦикла;
	
КонецПроцедуры

Процедура ИзменитьРеквизитыФормы(Форма, ДобавляемыеРеквизиты, СуществующиеРеквизиты, УдаляемыеРеквизиты = Неопределено) Экспорт
	
	Если УдаляемыеРеквизиты = Неопределено Тогда 
		УдаляемыеРеквизиты = Новый Массив;
	КонецЕсли;
	
	Для Каждого Реквизит Из ДобавляемыеРеквизиты Цикл
		Если СуществующиеРеквизиты.Найти(?(ЗначениеЗаполнено(Реквизит.Путь), Реквизит.Путь + ".", "") + Реквизит.Имя) <> Неопределено 
			И УдаляемыеРеквизиты.Найти(?(ЗначениеЗаполнено(Реквизит.Путь), Реквизит.Путь + ".", "") + Реквизит.Имя) = Неопределено Тогда
			УдаляемыеРеквизиты.Добавить(?(ЗначениеЗаполнено(Реквизит.Путь), Реквизит.Путь + ".", "") + Реквизит.Имя);
		КонецЕсли;					
	КонецЦикла;		
	
	Форма.ИзменитьРеквизиты(ДобавляемыеРеквизиты, УдаляемыеРеквизиты);
	
КонецПроцедуры

Процедура УдалитьПодчиненныеЭлементыГруппы(Форма, ГруппаФормы) Экспорт 
	
	ЭлементыДляУдаления = Новый Массив;
	Для Каждого Элемент Из ГруппаФормы.ПодчиненныеЭлементы Цикл
		ЭлементыДляУдаления.Добавить(Элемент);
	КонецЦикла;
	
	Для Каждого Элемент Из ЭлементыДляУдаления Цикл
		Форма.Элементы.Удалить(Элемент);
	КонецЦикла;
	
КонецПроцедуры

// Выполняет заполнение значений в форме на основании значений по умолчанию 
// 
// Параметры:
//		Форма - форма, реквизиты которой необходимо заполнить
//		ЗапрашиваемыеЗначения - структура с запрашиваемыми значениями
//			Имя элемента структуры идентифицирует значение, которое 
//				необходимо заполнить
//			Значение элемента структуры - путь к реквизиту формы, значение
//				которого необходимо заполнить
//			Список поддерживаемых значений см. в описании ПолучитьЗначенияПоУмолчанию
//
//		ФиксированныеЗначения - (необязательный) массив, 
//				Содержит идентификаторы значений, 
//				которое не должны быть изменены при заполнении
//
Процедура ЗаполнитьЗначенияВФорме(Форма, ЗапрашиваемыеЗначения, ФиксированныеЗначения = Неопределено) Экспорт
	
	Если ФиксированныеЗначения = Неопределено Тогда
		ФиксированныеЗначения = Новый Массив
	КонецЕсли;
	
	ЗаполняемыеЗначения = Новый Структура;
	Для Каждого КлючЗначение Из ЗапрашиваемыеЗначения Цикл
		ЗаполняемыеЗначения.Вставить(
			КлючЗначение.Ключ,
			ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, КлючЗначение.Значение));
	КонецЦикла;
	
	ПолучитьЗначенияПоУмолчанию(ЗаполняемыеЗначения);
	
	// Заполняем значения
	Для Каждого КлючЗначение Из ЗапрашиваемыеЗначения Цикл
		
		Если ФиксированныеЗначения.Найти(КлючЗначение.Ключ) = Неопределено Тогда
		
			ЗначениеДляЗаполнения = НеОпределено;
			ЗаполняемыеЗначения.Свойство(КлючЗначение.Ключ, ЗначениеДляЗаполнения);
			
			ОбщегоНазначенияКлиентСервер.УстановитьРеквизитФормыПоПути(Форма, КлючЗначение.Значение, ЗначениеДляЗаполнения, Истина);
			
		КонецЕсли
		
	КонецЦикла;
	
КонецПроцедуры

// Предназначена для использования в ОбщегоНазначенияПереопределяемый.ЗаполнитьТаблицуПереименованияОбъектовМетаданных
//
// Заполняет переименования тех объектов метаданных, которые невозможно
// автоматически найти по типу, но ссылки на которые требуется сохранять
// в базе данных (например: подсистемы, роли).
//
// Подробнее: см. ОбщегоНазначения.ДобавитьПереименование().
//
Процедура ЗаполнитьТаблицуПереименованияОбъектовМетаданных(Итог) Экспорт
	
	ЗарплатаКадрыВнутренний.ЗаполнитьТаблицуПереименованияОбъектовМетаданных(Итог);
	
КонецПроцедуры

Процедура ЗаполнитьПользовательскиеПоляВариантаОтчета(КлючВарианта, КоллекцияПользовательскихПолей) Экспорт
	
	ЗарплатаКадрыВнутренний.ЗаполнитьПользовательскиеПоляВариантаОтчета(КлючВарианта, КоллекцияПользовательскихПолей);
	
КонецПроцедуры

Процедура УстановитьОтборВариантаОтчета(КлючВарианта, НастройкиОтчета) Экспорт
	
	ЗарплатаКадрыВнутренний.УстановитьОтборВариантаОтчета(КлючВарианта, НастройкиОтчета);
	
КонецПроцедуры

Процедура ПроверитьВозможностьСменыГоловнойОрганизации(Организация, Отказ) Экспорт
	
	ЗарплатаКадрыВнутренний.ПроверитьВозможностьСменыГоловнойОрганизации(Организация, Отказ);
	
КонецПроцедуры

///////////////////////////////////////////////////////////////////////////////
// Идентифицируемые объекты

// Возвращает представление объекта метаданных
// Поддерживается получение следующих видов представлений 
//		РасширенноеПредставлениеОбъекта
//		ПредставлениеОбъекта
//		РасширенноеПредставлениеСписка
//		ПредставлениеСписка
Функция ПредставлениеМетаданных(ОбъектМетаданных, ВидПредставления) Экспорт
	Если ВидПредставления = "РасширенноеПредставлениеОбъекта" Тогда
		Если ЗначениеЗаполнено(ОбъектМетаданных.РасширенноеПредставлениеОбъекта) Тогда
			Возврат ОбъектМетаданных.РасширенноеПредставлениеОбъекта;
		ИначеЕсли ЗначениеЗаполнено(ОбъектМетаданных.ПредставлениеОбъекта) Тогда
			Возврат ОбъектМетаданных.ПредставлениеОбъекта;
		Иначе
			Возврат ОбъектМетаданных.Синоним;
		КонецЕсли;
	ИначеЕсли ВидПредставления = "ПредставлениеОбъекта" Тогда
		Если ЗначениеЗаполнено(ОбъектМетаданных.ПредставлениеОбъекта) Тогда
			Возврат ОбъектМетаданных.ПредставлениеОбъекта;
		Иначе
			Возврат ОбъектМетаданных.Синоним;
		КонецЕсли;
	ИначеЕсли ВидПредставления = "РасширенноеПредставлениеСписка" Тогда
		Если ЗначениеЗаполнено(ОбъектМетаданных.РасширенноеПредставлениеСписка) Тогда
			Возврат ОбъектМетаданных.РасширенноеПредставлениеСписка;
		ИначеЕсли ЗначениеЗаполнено(ОбъектМетаданных.ПредставлениеСписка) Тогда
			Возврат ОбъектМетаданных.ПредставлениеСписка;
		Иначе
			Возврат ОбъектМетаданных.Синоним;
		КонецЕсли;
	ИначеЕсли ВидПредставления = "ПредставлениеСписка" Тогда
		Если ЗначениеЗаполнено(ОбъектМетаданных.ПредставлениеСписка) Тогда
			Возврат ОбъектМетаданных.ПредставлениеСписка;
		Иначе
			Возврат ОбъектМетаданных.Синоним;
		КонецЕсли;
	Иначе
		Возврат ОбъектМетаданных.Синоним;
	КонецЕсли;
				
КонецФункции

// Возвращает ссылку на объект по полному имени метаданных и заданному идентификатору
// Объекты, которые предполагают идентификацию должны содержать реквизит "ИдентификаторОбъекта"
// Если объекта с заданным идентификатором нет, возвращает пустую ссылку соответствующего типа
Функция СсылкаНаОбъектПоИдентификатору(ПолноеИмяОбъекта, ИдентификаторОбъекта) Экспорт
	Возврат ЗарплатаКадрыПовтИсп.СсылкаНаОбъектПоИдентификатору(ПолноеИмяОбъекта, ИдентификаторОбъекта);
КонецФункции

// Возвращает новый объект по полному имени метаданных и заданному идентификатору
// Вызывается при создании новых объектов с идентификатором вместо 
// вызова <МенеджерОбъекта>.НовыйЭлемент и т.п.
// Объекты, которые предполагают идентификацию должны содержать реквизит "ИдентификаторОбъекта"
Функция ОбъектСИдентификатором(ПолноеИмяОбъекта, ИдентификаторОбъекта) Экспорт
	
	МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПолноеИмяОбъекта);
	ВидОбъекта = ОбщегоНазначения.ВидОбъектаПоСсылке(МенеджерОбъекта.ПустаяСсылка());
	Если ВРег(ВидОбъекта) = ВРег("Справочник") ИЛИ ВидОбъекта = ВРег("ПланВидовХарактеристик") Тогда
		Объект = МенеджерОбъекта.СоздатьЭлемент();
	ИначеЕсли ВРег(ВидОбъекта) = ВРег("Документ") Тогда
		Объект = МенеджерОбъекта.СоздатьДокумент();
	ИначеЕсли ВРег(ВидОбъекта) = ВРег("БизнесПроцесс") Тогда
		Объект = МенеджерОбъекта.СоздатьБизнесПроцесс();
	ИначеЕсли ВРег(ВидОбъекта) = ВРег("ПланСчетов") Тогда
		Объект = МенеджерОбъекта.СоздатьСчет();
	ИначеЕсли ВРег(ВидОбъекта) = ВРег("ПланВидовРасчета") Тогда
		Объект = МенеджерОбъекта.СоздатьВидРасчета();
	ИначеЕсли ВРег(ВидОбъекта) = ВРег("Задача") Тогда
		Объект = МенеджерОбъекта.СоздатьЗадачу();
	ИначеЕсли ВРег(ВидОбъекта) = ВРег("ПланОбмена") Тогда
		Объект = МенеджерОбъекта.СоздатьУзел();
	КонецЕсли;
	Объект.ИдентификаторОбъекта = ИдентификаторОбъекта;
	Объект.ДополнительныеСвойства.Вставить("ЗаписьУдалениеОбъектаСИдентификатором", Истина);
	
	Возврат Объект;
	
КонецФункции

Процедура ПометитьНаУдалениеОбъектСИдентификатором(ПолноеИмяОбъекта, ИдентификаторОбъекта) Экспорт
	
	Ссылка = СсылкаНаОбъектПоИдентификатору(ПолноеИмяОбъекта, ИдентификаторОбъекта);
	Если Не ЗначениеЗаполнено(Ссылка) Тогда
		Возврат;
	КонецЕсли;
	
	Объект = Ссылка.ПолучитьОбъект();
	Попытка
		Объект.Заблокировать();
	Исключение
		ПредставлениеОбъекта = ПредставлениеМетаданных(Объект.Метаданные(), "РасширенноеПредставлениеОбъекта");
		ТекстИсключения = НСтр("ru='Невозможно изменить %1 """"%2"""". Возможно, объект редактируется другим пользователем';uk='Неможливо змінити %1 """"%2"""". Можливо, об''єкт редагується іншим користувачем'");
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстИсключения, ПредставлениеОбъекта, Объект.Наименование);
	КонецПопытки;
	Объект.ДополнительныеСвойства.Вставить("ЗаписьУдалениеОбъектаСИдентификатором", Истина);
	Объект.ПометкаУдаления = Истина;
	Объект.ИдентификаторОбъекта = Неопределено;
	Объект.Записать();
	
КонецПроцедуры

/////////////////////////////////////
// Работа с потоками XML

// Создает и возвращает объект ЗаписьXML, для создания XML документа
Функция СоздатьПотокXML(ИмяФайла = Неопределено, Кодировка  = "windows-1251") Экспорт	
	ПотокXML = Новый ЗаписьXML();
	
	ПотокXML.УстановитьСтроку(Кодировка);
	ПотокXML.Отступ = Истина;
	Если ИмяФайла <> Неопределено Тогда
		ПотокXML.ОткрытьФайл(ИмяФайла, Кодировка);
	КонецЕсли;
	
	ПотокXML.ЗаписатьОбъявлениеXML();
	
	Возврат ПотокXML;
	
КонецФункции

// Сохраняет документ XML  на диск и закрывает запись XML
Функция ЗаписатьПотокXML(ПотокXML) Экспорт
	Возврат ПотокXML.Закрыть();	
КонецФункции

/////////////////////////////////////
// Работа с деревом XML

// КОМПОЗИЦИЯ ДЕРЕВА

// Создает объект дерево значений, представляющее XML файл
Функция СоздатьДеревоXML() Экспорт	
	НовоеДеревоXML = Новый ДеревоЗначений;
	НовоеДеревоXML.Колонки.Добавить("Имя",      Новый ОписаниеТипов("Строка"));
	НовоеДеревоXML.Колонки.Добавить("Значение", Новый ОписаниеТипов("Строка"));
	
	Возврат НовоеДеревоXML;
	
КонецФункции

Функция ДобавитьУзелВДеревоXML(Ветка, Имя, Значение, СписокАтрибутов = Неопределено, ТипДанных = "", ЗначениеЗаписи = Неопределено) Экспорт
	ПустаяДата = Дата(1,1,1);
	
	НовыйУзел = Ветка.Строки.Добавить();
	НовыйУзел.Имя = Имя;
	НовыйУзел.Значение = Значение;
	
	Если СписокАтрибутов <> Неопределено Тогда
		ВеткаАтрибутов = НовыйУзел.Строки.Добавить();
		ВеткаАтрибутов.Имя = "АтрибутыXMLУзла";
		ВеткаАтрибутов.Значение = Неопределено;
		
		Для Каждого ЭлементСпискаАтрибутов Из СписокАтрибутов Цикл
			ЛистАтрибутов = ВеткаАтрибутов.Строки.Добавить();
			ЛистАтрибутов.Имя = ЭлементСпискаАтрибутов.Ключ;
			// доделать до правильного преобразования
			ЛистАтрибутов.Значение = Строка(ЭлементСпискаАтрибутов.Значение);
		КонецЦикла;
		
	КонецЕсли;
	
	Если ТипДанных = "СТРОКА" И ЗначениеЗаписи <> Неопределено Тогда
		ЗначениеЗаписи = "";
	ИначеЕсли ТипДанных = "ЧИСЛО" И ЗначениеЗаписи <> Неопределено Тогда
		Если ТипЗнч(ЗначениеЗаписи) = Тип("Число") Тогда
			ЗначениеЗаписи = 0;	
		Иначе
			ЗначениеЗаписи = "";
		КонецЕсли;	
	ИначеЕсли ТипДанных = "ДАТА" И ЗначениеЗаписи <> Неопределено Тогда
		ЗначениеЗаписи = ПустаяДата;	
	КонецЕсли;	
	
	Возврат НовыйУзел;
	
КонецФункции

// записывает значения из дерева значение в поток связанный с файлом XML
Процедура ЗаписатьУзелДереваXMLВXML(СтрокаДерева, ПотокXML, ПрефиксПространстваИмен = Неопределено, URIПространстваИмен = Неопределено) Экспорт	
	Если ТипЗнч(СтрокаДерева) = Тип("СтрокаДереваЗначений") Тогда
		
		Если НЕ ПустаяСтрока(СтрокаДерева.Имя) Тогда
			
			ПотокXML.ЗаписатьНачалоЭлемента(СтрЗаменить(СтрокаДерева.Имя,"__","-"));
			Если ПрефиксПространстваИмен <> Неопределено И URIПространстваИмен <> Неопределено Тогда
				ПотокXML.ЗаписатьСоответствиеПространстваИмен(ПрефиксПространстваИмен, URIПространстваИмен);
			КонецЕсли;
			СписокАтрибутов = СтрокаДерева.Строки.Найти("АтрибутыXMLУзла", "Имя", Ложь);
			
			Если СписокАтрибутов <> Неопределено Тогда
				Для каждого СтрокаСАтрибутом Из СписокАтрибутов.Строки Цикл
					ПотокXML.ЗаписатьАтрибут(СтрокаСАтрибутом.Имя, СтрокаСАтрибутом.Значение);
				КонецЦикла;
			КонецЕсли;
			
			ПотокXML.ЗаписатьТекст(?(СтрокаДерева.Значение = "00.00.0000", "", СтрокаДерева.Значение));
			
		КонецЕсли;
		
	КонецЕсли;
	
	Для каждого Лист из СтрокаДерева.Строки Цикл
		Если Лист.Имя = "АтрибутыXMLУзла" Тогда
			Продолжить;
		КонецЕсли;
		ЗаписатьУзелДереваXMLВXML(Лист, ПотокXML, ПрефиксПространстваИмен, URIПространстваИмен);
	КонецЦикла;
	
	Если ТипЗнч(СтрокаДерева) = Тип("СтрокаДереваЗначений") Тогда
		Если НЕ ПустаяСтрока(СтрокаДерева.Имя) Тогда
			ПотокXML.ЗаписатьКонецЭлемента();
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// ИМПОРТ / ЭКСПОРТ ДЕРЕВА

Функция ЗагрузитьXMLВДокументDOM(ТекстXML) Экспорт
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(ТекстXML);
	
	ПостроительDOM = Новый ПостроительDOM;
	
	ДокументDOM = ПостроительDOM.Прочитать(ЧтениеXML);
	
	Возврат ДокументDOM;
КонецФункции	

Функция ЗагрузитьФорматНабораЗаписей(Знач ДеревоФормата, Знач ИмяНабораЗаписей, НомерВыбираемогоЭлемента = 1) Экспорт	
	ФорматНабора = Новый Структура();
	
	//СтрокаНабораЗаписей = ДеревоФормата.Строки.Найти(ИмяНабораЗаписей, "ИмяЗаписи");
	УзлыФормата = ДеревоФормата.ДочерниеУзлы[0].ПолучитьЭлементыПоИмени(ИмяНабораЗаписей)[0].ДочерниеУзлы;
	
	Для Каждого УзелФормата Из УзлыФормата Цикл
		
		ФорматЗаписи = Новый Структура("ТипДанных, Размер, РазрядностьДробнойЧасти, Поля, Значение, ЭлементНеОбязателен, ТипЭлемента, НеВыводитьВФайл");
		
		// имя записи хранится в 4 колонке
		ИмяЗаписи =  УзелФормата.ДочерниеУзлы[3].ТекстовоеСодержимое;
		
		// тип данных хранится во 2 колонке
		ТипДанных = ВРег(УзелФормата.ДочерниеУзлы[1].ТекстовоеСодержимое);
		
		//Признак обязательности элемента хранится в 5-й колонке	
		ЭлементНеОбязателен = (ВРег(УзелФормата.ДочерниеУзлы[4].ТекстовоеСодержимое) = "НЕ ОБЯЗАТЕЛЬНО" Или ВРег(УзелФормата.ДочерниеУзлы[4].ТекстовоеСодержимое) = "Н");
		
		Если УзелФормата.ДочерниеУзлы.Количество() = 7 И УзелФормата.ДочерниеУзлы[6].ИмяУзла = "ТипЭлемента" Тогда
			ТипЭлемента = ВРег(УзелФормата.ДочерниеУзлы[6].ТекстовоеСодержимое);
		Иначе
			ТипЭлемента = "С";
		КонецЕсли;	
		
		Если ТипДанных = "" Тогда// Если тип данных не задан, то встретили строку - группировку
			Продолжить;
		КонецЕсли; 
		
		ПозицияРазделителя = Найти(ТипДанных,"/");
		Если ПозицияРазделителя <> 0 Тогда
			ТипДанных = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ТипДанных, "/")[НомерВыбираемогоЭлемента-1];
		КонецЕсли;
		
		ПозицияРазделителя = Найти(ИмяЗаписи,"/");
		Если ПозицияРазделителя <> 0 Тогда
			ИмяЗаписи = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЗаписи, "/")[НомерВыбираемогоЭлемента-1];
		КонецЕсли;
		
		ФорматЗаписи.ТипДанных =  ТипДанных;
		ФорматЗаписи.ЭлементНеОбязателен = ЭлементНеОбязателен;
		ФорматЗаписи.ТипЭлемента = ТипЭлемента;
		ФорматЗаписи.НеВыводитьВФайл = Ложь;
		// размер хранится в 3 колонке
		СтрРазмерПоля =  УзелФормата.ДочерниеУзлы[2].ТекстовоеСодержимое;
		
		Если ФорматЗаписи.ТипДанных = "КОНСТАНТА" Тогда
			
			// в колонке "размер" должно указываться значение константы
			ФорматЗаписи.Значение = СтрРазмерПоля;
			
		ИначеЕсли ФорматЗаписи.ТипДанных = "ЧИСЛО" Тогда
			
			ПозицияТочки = Найти(СтрРазмерПоля,".");
			Если ПозицияТочки<>0 Тогда
				ФорматЗаписи.Размер = Число(Лев(СтрРазмерПоля,ПозицияТочки-1));
				ФорматЗаписи.РазрядностьДробнойЧасти = Число(Сред(СтрРазмерПоля,ПозицияТочки+1));
			Иначе	
				ФорматЗаписи.Размер = Число(СтрРазмерПоля);
				ФорматЗаписи.РазрядностьДробнойЧасти = 0;
			КонецЕсли;	 
			
			ФорматЗаписи.Значение = 0;
			
		ИначеЕсли ФорматЗаписи.ТипДанных = "СТРОКА" Тогда
			
			ФорматЗаписи.Размер = Число(СтрРазмерПоля);
			
			ФорматЗаписи.Значение = "";
			
		ИначеЕсли ФорматЗаписи.ТипДанных = "ДАТА" Тогда
			
			ФорматЗаписи.Значение = Дата('00010101');
			
		ИначеЕсли ФорматЗаписи.ТипДанных = "ТАБЛИЦА" Тогда	
			
			// имя области-описания формата полей таблицы или структуры хранится в колонке размер
			ФорматЗаписи.Поля = ПолучитьФорматЗаписиИзДереваФормата(ДеревоФормата, СтрРазмерПоля);
			ФорматЗаписи.Значение = Новый ТаблицаЗначений;
			
			Для каждого Поле Из ФорматЗаписи.Поля Цикл
				
				Если Поле.ТипДанных = "ЧИСЛО" Тогда
					ОписаниеТиповПоля = Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(Поле.Размер, Поле.РазрядностьДробнойЧасти));
				ИначеЕсли Поле.ТипДанных = "СТРОКА" Тогда
					ОписаниеТиповПоля = Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(Поле.Размер));
				ИначеЕсли Поле.ТипДанных = "ДАТА" Тогда
					ОписаниеТиповПоля = Новый ОписаниеТипов("Дата", , , Новый КвалификаторыДаты(ЧастиДаты.Дата));
				КонецЕсли; 
				ФорматЗаписи.Значение.Колонки.Добавить(Поле.ИмяПоля, ОписаниеТиповПоля);
				
			КонецЦикла; 
				
		ИначеЕсли ФорматЗаписи.ТипДанных = "СТРУКТУРА" Тогда	
			
			ПозицияРазделителя = Найти(ИмяЗаписи,"/");
			Если ПозицияРазделителя <> 0 Тогда
				ИмяЗаписи = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЗаписи, "/")[НомерВыбираемогоЭлемента-1]
			КонецЕсли;
			ПозицияРазделителя = Найти(СтрРазмерПоля,"/");
			Если ПозицияРазделителя <> 0 Тогда
				СтрРазмерПоля = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрРазмерПоля, "/")[НомерВыбираемогоЭлемента-1]
			КонецЕсли;
			
			// имя области-описания формата полей таблицы или структуры хранится в колонке размер
			ФорматЗаписи.Поля = ПолучитьФорматЗаписиИзДереваФормата(ДеревоФормата, СтрРазмерПоля);
			ФорматЗаписи.Значение = Новый Структура;
			Для каждого Поле Из ФорматЗаписи.Поля Цикл
				
				ПустоеЗначениеПоля = Неопределено;
				Если Поле.ТипДанных = "ЧИСЛО" Тогда
					ПустоеЗначениеПоля = 0;
				ИначеЕсли Поле.ТипДанных = "ДАТА" Тогда
					ПустоеЗначениеПоля = Дата('00010101');
				Иначе
					ПустоеЗначениеПоля = "";
				КонецЕсли; 
				
				ФорматЗаписи.Значение.Вставить(Поле.ИмяПоля, ПустоеЗначениеПоля);
				
			КонецЦикла; 
			
		ИначеЕсли ФорматЗаписи.ТипДанных = "НАБОРЗАПИСЕЙ" Тогда
			
			// Имя набора записей хранится в третьей колонке
			ИмяНабора = УзелФормата.ДочерниеУзлы[2].ТекстовоеСодержимое;
			ПозицияРазделителя = Найти(ИмяНабора,"/");
			Если ПозицияРазделителя <> 0 Тогда
				ИмяНабора = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяНабора, "/")[НомерВыбираемогоЭлемента-1]
			КонецЕсли;
			ПозицияРазделителя = Найти(ИмяЗаписи,"/");
			Если ПозицияРазделителя <> 0 Тогда
				ИмяЗаписи = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЗаписи, "/")[НомерВыбираемогоЭлемента-1]
			КонецЕсли;
			ФорматЗаписи.Значение = ЗагрузитьФорматНабораЗаписей(ДеревоФормата, ИмяНабора, НомерВыбираемогоЭлемента);
			
		КонецЕсли;	
		
		ФорматНабора.Вставить(ИмяЗаписи, ФорматЗаписи);
		
	КонецЦикла;	
	
	Возврат ФорматНабора;
		
КонецФункции

// добавляет реквизит в дерево значений, представляющее XML файл
Процедура ДобавитьИнформациюВДерево(ДеревоВыгрузки, НаборЗаписей) Экспорт	
		
	ПустаяДата = Дата(1,1,1);
	
	Для каждого ЭлементНабора Из НаборЗаписей Цикл
		ИмяЗаписи = ЭлементНабора.Ключ;
				
		Запись = ЭлементНабора.Значение;
		
		Если Запись.НеВыводитьВФайл Тогда 
			Запись.НеВыводитьВФайл = Ложь;
			Продолжить;
		КонецЕсли;	
	
		ТипДанных = Запись.ТипДанных;
		Если ТипДанных = "КОНСТАНТА" Тогда
			
			ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, Запись.Значение, , ТипДанных, Запись.Значение);
			
		ИначеЕсли ТипДанных = "ЧИСЛО" Тогда
			
			// для проверок
			//Запись.Размер 
			//Запись.РазрядностьДробнойЧасти
			ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, Формат(Запись.Значение,"ЧЦ=" + Запись.Размер + "; ЧДЦ=" + Запись.РазрядностьДробнойЧасти + "; ЧРД=.; ЧН=; ЧГ=0"), , ТипДанных, Запись.Значение);
			Запись.НеВыводитьВФайл = Ложь;
		ИначеЕсли ТипДанных = "СТРОКА" Тогда
			
			// для проверок
			//Запись.Размер 
			
			ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, Запись.Значение, ,ТипДанных, Запись.Значение);
			
		ИначеЕсли ТипДанных = "ДАТА" Тогда
			
			ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, ?(Запись.Значение = ПустаяДата,"00.00.0000", Формат(Запись.Значение,"ДФ=dd.MM.yyyy")), ,ТипДанных, Запись.Значение);
			
		ИначеЕсли ТипДанных = "ТАБЛИЦА" Тогда	
			
			ПроверятьНеобязательныеПоля = Ложь;
			Для каждого Поле Из Запись.Поля Цикл
				ПроверятьНеобязательныеПоля = Поле.ЭлементНеОбязателен;
				Если ПроверятьНеобязательныеПоля Тогда
					Прервать;
				КонецЕсли;
			КонецЦикла; 
			
			Для каждого СтрокаТЗ Из Запись.Значение Цикл
				
				
				ВыводитьНеобязательныеПоля = Ложь;
				Если ПроверятьНеобязательныеПоля Тогда
					Для каждого Поле Из Запись.Поля Цикл
						Если Поле.ЭлементНеОбязателен Тогда
							ВыводитьНеобязательныеПоля = ЗначениеЗаполнено(СтрокаТЗ[Поле.ИмяПоля]);
							Если ВыводитьНеобязательныеПоля Тогда
								Прервать;
							КонецЕсли;
						КонецЕсли;
					КонецЦикла; 
				КонецЕсли;
				
				Атрибуты = Новый Структура;
				Для каждого Поле Из Запись.Поля Цикл
					
					Если Поле.ЭлементНеОбязателен И Не ВыводитьНеобязательныеПоля Тогда
						Продолжить;
					КонецЕсли;
					
					Данные = СтрокаТЗ[Поле.ИмяПоля];
					
					Если Поле.ТипДанных = "ЧИСЛО" Тогда
						Данные = Формат(Данные,"ЧЦ=" + Поле.Размер + "; ЧДЦ=" + Поле.РазрядностьДробнойЧасти + "; ЧРД=.; ЧН=; ЧГ=0")
					ИначеЕсли Поле.ТипДанных = "ДАТА" Тогда
						Если Не ЗначениеЗаполнено(Данные) Тогда
							Данные = ""
						Иначе
							Данные = Формат(Данные,"ДФ=dd.MM.yyyy");
						КонецЕсли;
					КонецЕсли;
					
					Если Поле.ТипЭлемента = "А" И НЕ Поле.НеВыводитьВФайл Тогда
						Атрибуты.Вставить(Поле.ИмяПоля, Данные);
					КонецЕсли;
					
				КонецЦикла;
				
				ВеткаСтрокиТЗ = ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, "", Атрибуты);
				
				Для каждого Поле Из Запись.Поля Цикл
					
					Если Поле.ТипЭлемента = "А" Тогда
						Поле.НеВыводитьВФайл = Ложь;
						Продолжить;
					КонецЕсли;
					
					Если Поле.НеВыводитьВФайл Тогда
						Поле.НеВыводитьВФайл = Ложь;
						Продолжить;
					КонецЕсли;	
					
					Если Поле.ЭлементНеОбязателен И Не ВыводитьНеобязательныеПоля Тогда
						Продолжить;
					КонецЕсли;
					
					ДобавитьИнформациюВДерево(ВеткаСтрокиТЗ, СтрокаТЗ[Поле.ИмяПоля])
					
				КонецЦикла;
				
			КонецЦикла; 
			
		ИначеЕсли ТипДанных = "СТРУКТУРА" Тогда	
			МассивДанных = Новый Массив;
			Атрибуты = Новый Структура;
			Для каждого Поле Из Запись.Поля Цикл
				
				Данные = Запись.Значение[Поле.ИмяПоля];
				
				Если Поле.ЭлементНеОбязателен И Не ЗначениеЗаполнено(Данные) Тогда
					Продолжить;
				КонецЕсли;
				
				ПустоеЗначение = "";
				Если Поле.ТипДанных = "ЧИСЛО" Тогда
					Если ТипЗнч(Данные) = Тип("Число") Тогда
						ПустоеЗначение = 0;	
					КонецЕсли;	
					Данные = Формат(Данные,"ЧЦ=" + Поле.Размер + "; ЧДЦ=" + Поле.РазрядностьДробнойЧасти + "; ЧРД=.; ЧН=; ЧГ=0");
				ИначеЕсли Поле.ТипДанных = "ДАТА" Тогда
					Если Не ЗначениеЗаполнено(Данные) Тогда
						Данные = ""
					Иначе
						Данные = Формат(Данные,"ДФ=dd.MM.yyyy");
						ПустоеЗначение = '00010101';
					КонецЕсли;
				КонецЕсли;
				
				Если Поле.ТипЭлемента = "А" И НЕ Поле.НеВыводитьВФайл  Тогда
					Атрибуты.Вставить(Поле.ИмяПоля, Данные);
				ИначеЕсли НЕ Поле.НеВыводитьВФайл Тогда 
					СтруктураДанных = Новый Структура("ИмяПоля, Значение, Данные, ТипДанных", Поле.ИмяПоля, Запись.Значение[Поле.ИмяПоля], Данные, Поле.ТипДанных);
					МассивДанных.Добавить(СтруктураДанных);
				КонецЕсли;
				Поле.НеВыводитьВФайл = Ложь;
				Запись.Значение[Поле.ИмяПоля] = ПустоеЗначение;	
			КонецЦикла; 
				
			ВеткаСтруктуры = ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, "", Атрибуты);
			
			Для Каждого Поле Из МассивДанных Цикл
				ДобавитьУзелВДеревоXML(ВеткаСтруктуры, Поле.ИмяПоля, Поле.Данные, ,Поле.ТипДанных, Поле.Данные);
            КонецЦикла;

		ИначеЕсли ТипДанных = "НАБОРЗАПИСЕЙ" Тогда
			
			Значение = Запись.Значение;
			
			Атрибуты = Новый Структура;
			Для каждого Поле Из Значение Цикл
				Если Поле.Значение.ТипЭлемента = "А" И НЕ Поле.Значение.НеВыводитьВФайл  Тогда
					Данные = Поле.Значение.Значение;
					Если Поле.Значение.ТипДанных = "ЧИСЛО" Тогда
						Данные = Формат(Данные,"ЧЦ=" + Поле.Значение.Размер + "; ЧДЦ=" + Поле.Значение.РазрядностьДробнойЧасти + "; ЧРД=.; ЧН=; ЧГ=0")
					ИначеЕсли Поле.Значение.ТипДанных = "ДАТА" Тогда
						Если Не ЗначениеЗаполнено(Данные) Тогда
							Данные = ""
						Иначе
							Данные = Формат(Данные,"ДФ=dd.MM.yyyy");
						КонецЕсли;
					КонецЕсли;
					Атрибуты.Вставить(Поле.Ключ, Данные);
					Значение.Удалить(Поле.Ключ);
				КонецЕсли;
			КонецЦикла;
			
			ДобавитьИнформациюВДерево(ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, "", Атрибуты), Значение);
			
		КонецЕсли;	
		
	КонецЦикла; 
	
КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции работы с отчетами

// Функция возвращает текст запроса временной таблицы периодов с заданной периодичностью
//
// Параметры:
//	ОписаниеНачалаИнтервала - Строка, имя параметра в тексте запроса ("&НачалоПериода", "ДАТАВРЕМЯ(2013, 1, 1)")
//							- Дата, начальная дата интервала, за который формируются периоды.
//	ОписаниеОкончанияИнтервала -  Строка, имя параметра в тексте запроса,
//							- Дата, конечная дата интервала, за который формируются периоды.
//	Периодичность - периодичность, на которую будет разбиваться интервал.
//		По умолчанию <МЕСЯЦ>. Может принимать значения:	ГОД, КВАРТАЛ, МЕСЯЦ, ДЕНЬ.
//	ИмяПоляПериод - наименование колонки во временной таблице периодов. 
//		По умолчанию <Период>.
//	ИмяВТ - наименование временной таблицы периодов, по умолчанию <ВТПериоды>.
//	ИспользоватьКонецПериода - булево, необязательный, по умолчанию - Ложь. 
//		Определяет необходимость использовать в качестве значения последнюю секунду периода. 
//		То есть если Истина, то для периодичности месяц, 
//		временная таблица будет заполнена датами конца каждого месяца, 
//		и если ложь, то - датами начала.
//
Функция ТекстЗапросаВТПериоды(Знач ОписаниеНачалаИнтервала, Знач ОписаниеОкончанияИнтервала, Периодичность = "МЕСЯЦ", ИмяПоляПериод = "Период", ИмяВТ = "ВТПериоды", ИспользоватьКонецПериода = Ложь) Экспорт
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	0 КАК Цифра
	|ПОМЕСТИТЬ Цифры
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	1
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	2
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	3
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	4
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	5
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	6
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	7
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	8
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	9
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВЫБОР
	|		КОГДА &НачалоПериодаИнтервала <> ДАТАВРЕМЯ(1, 1, 1)
	|			ТОГДА НАЧАЛОПЕРИОДА(ДОБАВИТЬКДАТЕ(&НачалоПериодаИнтервала, ЧАС, Цифры.Цифра + ЕСТЬNULL(Цифры10.Цифра, 0) * 10 + ЕСТЬNULL(Цифры100.Цифра, 0) * 100 + ЕСТЬNULL(Цифры1000.Цифра, 0) * 1000 + ЕСТЬNULL(Цифры10000.Цифра, 0) * 10000 + ЕСТЬNULL(Цифры100000.Цифра, 0) * 100000), ЧАС)
	|		ИНАЧЕ НАЧАЛОПЕРИОДА(ДОБАВИТЬКДАТЕ(ДАТАВРЕМЯ(1980, 1, 1), ЧАС, Цифры.Цифра + ЕСТЬNULL(Цифры10.Цифра, 0) * 10 + ЕСТЬNULL(Цифры100.Цифра, 0) * 100 + ЕСТЬNULL(Цифры1000.Цифра, 0) * 1000 + ЕСТЬNULL(Цифры10000.Цифра, 0) * 10000 + ЕСТЬNULL(Цифры100000.Цифра, 0) * 100000), ЧАС)
	|	КОНЕЦ КАК ИмяПоляПериод
	|ПОМЕСТИТЬ ИмяВТ
	|ИЗ
	|	Цифры КАК Цифры
	|		ЛЕВОЕ СОЕДИНЕНИЕ Цифры КАК Цифры10
	|		ПО (РАЗНОСТЬДАТ(&НачалоПериодаИнтервала, &ОкончаниеПериодаИнтервала, ЧАС) > 9)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Цифры КАК Цифры100
	|		ПО (РАЗНОСТЬДАТ(&НачалоПериодаИнтервала, &ОкончаниеПериодаИнтервала, ЧАС) > 99)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Цифры КАК Цифры1000
	|		ПО (РАЗНОСТЬДАТ(&НачалоПериодаИнтервала, &ОкончаниеПериодаИнтервала, ЧАС) > 999)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Цифры КАК Цифры10000
	|		ПО (РАЗНОСТЬДАТ(&НачалоПериодаИнтервала, &ОкончаниеПериодаИнтервала, ЧАС) > 9999)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Цифры КАК Цифры100000
	|		ПО (РАЗНОСТЬДАТ(&НачалоПериодаИнтервала, &ОкончаниеПериодаИнтервала, ЧАС) > 99999)
	|ГДЕ
	|	ВЫБОР
	|			КОГДА &НачалоПериодаИнтервала <> ДАТАВРЕМЯ(1, 1, 1)
	|				ТОГДА НАЧАЛОПЕРИОДА(ДОБАВИТЬКДАТЕ(&НачалоПериодаИнтервала, ЧАС, Цифры.Цифра + ЕСТЬNULL(Цифры10.Цифра, 0) * 10 + ЕСТЬNULL(Цифры100.Цифра, 0) * 100 + ЕСТЬNULL(Цифры1000.Цифра, 0) * 1000 + ЕСТЬNULL(Цифры10000.Цифра, 0) * 10000 + ЕСТЬNULL(Цифры100000.Цифра, 0) * 100000), ЧАС)
	|			ИНАЧЕ НАЧАЛОПЕРИОДА(ДОБАВИТЬКДАТЕ(ДАТАВРЕМЯ(1980, 1, 1), ЧАС, Цифры.Цифра + ЕСТЬNULL(Цифры10.Цифра, 0) * 10 + ЕСТЬNULL(Цифры100.Цифра, 0) * 100 + ЕСТЬNULL(Цифры1000.Цифра, 0) * 1000 + ЕСТЬNULL(Цифры10000.Цифра, 0) * 10000 + ЕСТЬNULL(Цифры100000.Цифра, 0) * 100000), ЧАС)
	|		КОНЕЦ МЕЖДУ &НачалоИнтервала И &ОкончаниеИнтервала
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|УНИЧТОЖИТЬ Цифры";
	
	Если ВРег(Периодичность) <> "ГОД"
		И ВРег(Периодичность) <> "КВАРТАЛ"
		И ВРег(Периодичность) <> "МЕСЯЦ"
		И ВРег(Периодичность) <> "ДЕНЬ" Тогда
		
		ВызватьИсключение("Невозможно сформировать запрос с переданными параметрами.");
		
	КонецЕсли;
	
	Если ИспользоватьКонецПериода Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "НАЧАЛОПЕРИОДА", "КОНЕЦПЕРИОДА");
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ЧАС", Периодичность);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ПОМЕСТИТЬ ИмяВТ", "ПОМЕСТИТЬ " + ИмяВТ);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "КАК ИмяПоляПериод", "КАК " + ИмяПоляПериод);
	
	Если ИспользоватьКонецПериода Тогда
		НачалоПериодаИнтервалаПредставление = "КОНЕЦПЕРИОДА(&НачалоИнтервала, " + ВРег(Периодичность) + ")";
		ОкончаниеПериодаИнтервалаПредставление = "КОНЕЦПЕРИОДА(&ОкончаниеИнтервала, " + ВРег(Периодичность) + ")";
	Иначе
		НачалоПериодаИнтервалаПредставление = "НАЧАЛОПЕРИОДА(&НачалоИнтервала, " + ВРег(Периодичность) + ")";
		ОкончаниеПериодаИнтервалаПредставление = "НАЧАЛОПЕРИОДА(&ОкончаниеИнтервала, " + ВРег(Периодичность) + ")";
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&НачалоПериодаИнтервала", НачалоПериодаИнтервалаПредставление);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ОкончаниеПериодаИнтервала", ОкончаниеПериодаИнтервалаПредставление);
	
	
	Если ТипЗнч(ОписаниеНачалаИнтервала) = Тип("Строка") Тогда
		НачалоИнтервалаПредставление = ОписаниеНачалаИнтервала;
	Иначе
		НачалоИнтервалаПредставление = "ДАТАВРЕМЯ(" + Формат(ОписаниеНачалаИнтервала, "ДФ='гггг, М, д, Ч, м, с'; ДП=") + ")";
	КонецЕсли;
	
	Если ТипЗнч(ОписаниеОкончанияИнтервала) = Тип("Строка") Тогда
		ОкончаниеИнтервалаПредставление = ОписаниеОкончанияИнтервала;
	Иначе
		ОкончаниеИнтервалаПредставление = "ДАТАВРЕМЯ(" + Формат(ОписаниеОкончанияИнтервала, "ДФ='гггг, М, д, Ч, м, с'; ДП=") + ")";
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&НачалоИнтервала", НачалоИнтервалаПредставление);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ОкончаниеИнтервала", ОкончаниеИнтервалаПредставление);
	
	Возврат ТекстЗапроса;
	
КонецФункции

// Формирует временную таблицу периодов с заданной периодичностью и текстом запроса,
// описание которого находится в Функции <ТекстЗапросаВТПериоды>
// Создает в МенеджерВременныхТаблиц временную таблицу с именем <ИмяВТ> 
// и периодичностью <Периодичность>	
// за интервал с <НачалоИнтервала> по <ОкончаниеИнтервала>
//
Процедура СоздатьВТПериоды(МенеджерВременныхТаблиц, НачалоИнтервала, ОкончаниеИнтервала, Периодичность = "МЕСЯЦ", ИмяПоляПериод = "Период", ИмяВТ = "ВТПериоды", ИспользоватьКонецПериода = Ложь) Экспорт
	
	Если НачалоИнтервала > ОкончаниеИнтервала Тогда
		ВызватьИсключение("Дата окончания не может быть меньше даты начала.")
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	Запрос.Текст = ТекстЗапросаВТПериоды(НачалоИнтервала, ОкончаниеИнтервала, Периодичность, ИмяПоляПериод, ИмяВТ, ИспользоватьКонецПериода);
	Запрос.Выполнить();
	
КонецПроцедуры

Функция СоответствиеПользовательскихПолей(ЭлементыПользовательскихПолей) Экспорт
	
	СоответствиеПользовательскихПолей = Новый Соответствие;
	
	Для каждого Элемент Из ЭлементыПользовательскихПолей Цикл
		СоответствиеПользовательскихПолей.Вставить(Элемент.Заголовок, СтрЗаменить(Элемент.ПутьКДанным,".",""));
	КонецЦикла;
	
	Возврат СоответствиеПользовательскихПолей;
	
КонецФункции

Процедура ЗаполнитьПараметрыПользовательскихПолей(Макет, Данные, СоответствиеПользовательскихПолей, ИменаЗаполняемыхПолей = "") Экспорт
	
	ЗаполняемыеПоля = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИменаЗаполняемыхПолей);
	
	СтруктураДанных = Новый Структура;
	Для каждого СоответствиеПользовательскогоПоля Из СоответствиеПользовательскихПолей Цикл
		
		Если ЗаполняемыеПоля.Количество() > 0
			И ЗаполняемыеПоля.Найти(СоответствиеПользовательскогоПоля.Ключ) = Неопределено Тогда
			Продолжить;
		КонецЕсли; 
		
		СтруктураДанных.Вставить(СоответствиеПользовательскогоПоля.Значение);
		
	КонецЦикла;
	
	ЗаполнитьЗначенияСвойств(СтруктураДанных, Данные);
	
	СтруктураЗначенийПользовательскихПолей = Новый Структура;
	Для каждого СоответствиеПользовательскогоПоля Из СоответствиеПользовательскихПолей Цикл
		
		Если ЗаполняемыеПоля.Количество() > 0
			И ЗаполняемыеПоля.Найти(СоответствиеПользовательскогоПоля.Ключ) = Неопределено Тогда
			Продолжить;
		КонецЕсли; 
		
		СтруктураЗначенийПользовательскихПолей.Вставить(СоответствиеПользовательскогоПоля.Ключ, СтруктураДанных[СоответствиеПользовательскогоПоля.Значение]);
		
	КонецЦикла;
	
	ЗаполнитьЗначенияСвойств(Макет.Параметры, СтруктураЗначенийПользовательскихПолей);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции работы с данными физических лиц

Процедура СоздатьВТФИООтветственныхЛиц(МенеджерВременныхТаблиц, ТолькоРазрешенные, ИменаПолейОтветственныхЛиц, ИмяВременнойТаблицыДанныхДокумента) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;

	ЭтоПервоеПолеОтветственного = Истина;
	Для Каждого ИмяПоляОтветственногоЛица Из ИменаПолейОтветственныхЛиц Цикл
		
		Если Не ЭтоПервоеПолеОтветственного Тогда 
			Запрос.Текст = Запрос.Текст + "
										  |ОБЪЕДИНИТЬ
										  |ВЫБРАТЬ РАЗЛИЧНЫЕ";
		Иначе
										  
			Запрос.Текст = Запрос.Текст + "ВЫБРАТЬ " + ?(ТолькоРазрешенные, "РАЗРЕШЕННЫЕ", "") + " РАЗЛИЧНЫЕ";
		КонецЕсли;										  
		
		Запрос.Текст = Запрос.Текст + "
		                              |	ДанныеДокумента.ИмяПоляОтветственногоЛица КАК ФизическоеЛицо,
		                              |	ДанныеДокумента.Дата КАК Период,
									  |	ДанныеДокумента.Ссылка" + ?(ЭтоПервоеПолеОтветственного, "
									  |ПОМЕСТИТЬ ВТСотрудники", "") + "
		                              |ИЗ
		                              |	ДанныеДокумента КАК ДанныеДокумента";	
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "ИмяПоляОтветственногоЛица", ИмяПоляОтветственногоЛица);
		
		ЭтоПервоеПолеОтветственного = Ложь;	
		
	КонецЦикла;		
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ДанныеДокумента", ИмяВременнойТаблицыДанныхДокумента);
	Запрос.Выполнить();
	
	Запрос.Текст = "ВЫБРАТЬ РАЗЛИЧНЫЕ ВТСотрудники.ФизическоеЛицо, ВТСотрудники.Период ИЗ ВТСотрудники КАК ВТСотрудники";
	СписокФизическихЛицСПериодом = Запрос.Выполнить().Выгрузить();
	Периоды = СписокФизическихЛицСПериодом.Скопировать(, "Период");
	Периоды.Свернуть("Период");
	
	МассивНеобходимыхДанных = Новый Массив;
	МассивНеобходимыхДанных.Добавить("Фамилия");
	МассивНеобходимыхДанных.Добавить("Имя");
	МассивНеобходимыхДанных.Добавить("Отчество");
	
	Если Периоды.Количество() = 0 Тогда  // ИНАГРО ++
		ПериодОсновной = Дата(1,1,1);
	Иначе
		ПериодОсновной = Периоды[0].Период;
	КонецЕсли;                          // ИНАГРО --
	
	КадровыйУчет.СоздатьНаДатуВТКадровыеДанныеФизическихЛиц(МенеджерВременныхТаблиц, ТолькоРазрешенные, СписокФизическихЛицСПериодом.ВыгрузитьКолонку("ФизическоеЛицо"), МассивНеобходимыхДанных, ПериодОсновной); // ИНАГРО ++
	
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ДанныеДокументов.ФизическоеЛицо,
	|	ДанныеДокументов.Период КАК Дата,
	|	ДанныеДокументов.Ссылка,
	|	ВТКадровыеДанныеФизЛиц.Фамилия,
	|	ВТКадровыеДанныеФизЛиц.Имя,
	|	ВТКадровыеДанныеФизЛиц.Отчество
	|ПОМЕСТИТЬ ВТФИООтветственныхЛиц
	|ИЗ
	|	ВТСотрудники КАК ДанныеДокументов
	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТКадровыеДанныеФизическихЛиц КАК ВТКадровыеДанныеФизЛиц
	|		ПО ДанныеДокументов.ФизическоеЛицо = ВТКадровыеДанныеФизЛиц.ФизическоеЛицо
	|			И ДанныеДокументов.Период = ВТКадровыеДанныеФизЛиц.Период";
				   
	Если НЕ ТолькоРазрешенные Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "ВЫБРАТЬ РАЗРЕШЕННЫЕ", "ВЫБРАТЬ");
	КонецЕсли;	

	Запрос.Выполнить();			   
	
КонецПроцедуры	

// Возвращает соответствие Физлицо - ФИО на дату
// относящихся к персональным
//
// Параметры:
//		ДатаАктуальности - дата, на которую определяется ФИО:
//		МассивФизЛиц - массив ссылок типа СправочникСсылка.ФизическиеЛица
//
// Возвращаемое значение:
//		соответствие	
//			ключ - СправочникСсылка.ФизическиеЛица
//			значение - строка ФИО
//
//
Функция СоответствиеФИОФизЛицСсылкам(ДатаАктуальности, МассивФизЛиц) Экспорт 
	
	МассивНеобходимыхПолей = Новый Массив;
	МассивНеобходимыхПолей.Добавить("Фамилия");
	МассивНеобходимыхПолей.Добавить("Имя");
	МассивНеобходимыхПолей.Добавить("Отчество");
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	КадровыйУчет.СоздатьНаДатуВТКадровыеДанныеФизическихЛиц(Запрос.МенеджерВременныхТаблиц, Истина, МассивФизЛиц, МассивНеобходимыхПолей, ДатаАктуальности);
	
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	КадровыеДанныеФизЛиц.ФизическоеЛицо,
	|	КадровыеДанныеФизЛиц.Фамилия,
	|	КадровыеДанныеФизЛиц.Имя,
	|	КадровыеДанныеФизЛиц.Отчество
	|ИЗ
	|	ВТКадровыеДанныеФизическихЛиц КАК КадровыеДанныеФизЛиц";
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	СоответствиеФИОФизЛицСсылкам = Новый Соответствие;
	
	Пока Выборка.Следующий() Цикл
		ФИО = Новый Структура("Фамилия, Имя, Отчество");
		ЗаполнитьЗначенияСвойств(ФИО, Выборка);
		СоответствиеФИОФизЛицСсылкам.Вставить(Выборка.ФизическоеЛицо, ФИО);		
	КонецЦикла;	
	
	Возврат СоответствиеФИОФизЛицСсылкам;
	
КонецФункции	

///////////////////////////////////////////////////////////////////////////////
// Проверка персональных данных физических лиц

Процедура ПроверитьПерсональныеДанныеСотрудника(Ссылка, ДанныеДляПроверки, ПроверяемыеРеквизиты, МассивНепроверяемыхРеквизитов, Дата = '00010101', ВыводитьСообщения = Ложь, Отказ = Ложь) Экспорт	
	МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоСсылке(Ссылка);
	
	МассивНеПроверяемыхРеквизитов.Очистить();
	
	СтруктураПроверяемыхДанных = МенеджерОбъекта.ПолучитьСтруктуруПроверяемыхДанных();
	
	СтруктураПроверяемыхДокументов = Новый Структура("ВидДокумента,  СерияДокумента, НомерДокумента, ДатаВыдачи, КемВыдан");
	ЗаполнитьЗначенияСвойств(СтруктураПроверяемыхДокументов, ДанныеДляПроверки);
	
	ПредставленияПроверяемыхРеквизитов = МенеджерОбъекта.ПолучитьПредставленияПроверяемыхРеквизитов();
		
	СоответствиеРеквизитовФормеОбъекта = МенеджерОбъекта.ПолучитьСоответствиеРеквизитовФормеОбъекта(ДанныеДляПроверки);
		
	СоответствиеРеквизитовПутиВФормеОбъекта = МенеджерОбъекта.ПолучитьСоответствиеРеквизитовПутиВФормеОбъекта();
	
	СоответствиеРеквизитовОткрываемымОбъектам = МенеджерОбъекта.ПолучитьСоответствиеПроверяемыхРеквизитовОткрываемымОбъектам(Ссылка, ДанныеДляПроверки);
	
	Для Каждого КлючЗначение Из СтруктураПроверяемыхДанных Цикл
		СтруктураПроверяемыхДанных[КлючЗначение.Ключ] = Неопределено;
	КонецЦикла;
	
	СоответствиеПутейИИменПроверяемыхРеквизитов = Новый Структура;
	
	Для Каждого ИмяРеквизита Из ПроверяемыеРеквизиты Цикл
		ПутьКРеквизиту = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяРеквизита, ".");	
		
		СоответствиеПутейИИменПроверяемыхРеквизитов.Вставить(ПутьКРеквизиту[ПутьКРеквизиту.Количество() - 1], ИмяРеквизита);
	КонецЦикла;	
	
	ЗаполнитьЗначенияСвойств(СтруктураПроверяемыхДанных, ДанныеДляПроверки);

	ПроверитьОбязательныеПоля(Ссылка, СтруктураПроверяемыхДанных, ДанныеДляПроверки, СоответствиеПутейИИменПроверяемыхРеквизитов, СоответствиеРеквизитовФормеОбъекта, СоответствиеРеквизитовПутиВФормеОбъекта, СоответствиеРеквизитовОткрываемымОбъектам, ПредставленияПроверяемыхРеквизитов, МассивНепроверяемыхРеквизитов, ВыводитьСообщения, Отказ);
	
	
	ПроверитьМестоРождения(СтруктураПроверяемыхДанных, СоответствиеРеквизитовОткрываемымОбъектам, ДанныеДляПроверки, ВыводитьСообщения, Отказ);
	
	ПроверитьДанныеУдостоверенийЛичности(Ссылка, Дата, СтруктураПроверяемыхДокументов, ДанныеДляПроверки, СоответствиеПутейИИменПроверяемыхРеквизитов, СоответствиеРеквизитовФормеОбъекта, СоответствиеРеквизитовПутиВФормеОбъекта, ПредставленияПроверяемыхРеквизитов, СоответствиеРеквизитовОткрываемымОбъектам, МассивНепроверяемыхРеквизитов, ВыводитьСообщения, Отказ);
	
	ПроверитьЗаполнениеАдресов(СтруктураПроверяемыхДанных, СоответствиеРеквизитовОткрываемымОбъектам, ДанныеДляПроверки, ВыводитьСообщения, Отказ);

	ПроверитьДатыРождения(Дата, СтруктураПроверяемыхДанных, СоответствиеРеквизитовОткрываемымОбъектам, ДанныеДляПроверки, ВыводитьСообщения, Отказ);
	
	
КонецПроцедуры	



///////////////////////////////////////////////////////////////////////////////
// Выгрузка/загрузка данных

// Обработчик, вызываемый при окончании стандартного формирования словаря замен
// по очередному файлу общих данных.
//
// Параметры
//  СловарьЗамен - таблица значений, колонки:
//    Тип - Тип - Тип значения заменяемой ссылки
//    СоответствиеСсылок - Соответствие - соответствие новой ссылки исходной
//     Ключ - Новая ссылка (на которую требуется заменить)
//     Значение - Исходная ссылка (требующая замены)
//  ИмяФайлаОбщихДанных - Строка - имя текущего обрабатываемого файла выгрузки
//   общих данных
//
Процедура ДополнитьСловарьЗаменПоОбщимДанным(Знач СловарьЗамен, Знач ИмяФайлаОбщихДанных) Экспорт
	
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла("xml");
	
	ЗаписьТаблицы = Новый ЗаписьXML;
	ЗаписьТаблицы.ОткрытьФайл(ИмяВременногоФайла);
	
	Преобразование = ОбщегоНазначенияПовтИсп.ПолучитьПреобразованиеXSLИзОбщегоМакета("ИзвлечениеИдентификаторовОбъектовОбщихДанных");
	Преобразование.ПреобразоватьИзФайла(ИмяФайлаОбщихДанных, ЗаписьТаблицы);
	
	ЗаписьТаблицы.Закрыть();
	
	Чтение = Новый ЧтениеXML;
	Чтение.ОткрытьФайл(ИмяВременногоФайла);
	Чтение.ПерейтиКСодержимому();
	
	Если Чтение.ТипУзла <> ТипУзлаXML.НачалоЭлемента
		ИЛИ Чтение.Имя <> "Data" Тогда
		
		ВызватьИсключение(НСтр("ru='Ошибка чтения XML. Неверный формат файла. Ожидается начало элемента Data.';uk='Помилка читання XML. Неправильний формат файлу. Очікується початок елемента Data.'"));
	КонецЕсли;
	
	Если НЕ Чтение.Прочитать() Тогда
		ВызватьИсключение(НСтр("ru='Ошибка чтения XML. Обнаружено завершение файла.';uk='Помилка читання XML. Виявлено завершення файлу.'"));
	КонецЕсли;
	
	ТаблицаКодов = СериализаторXDTO.ПрочитатьXML(Чтение);
	
	Чтение.Закрыть();
	
	Попытка
		УдалитьФайлы(ИмяВременногоФайла);
	Исключение
		
	КонецПопытки;
	
	ТекстЗапросаСозданияТаблицыКодов =
	"ВЫБРАТЬ
	|	Коды.Ссылка КАК Ссылка,
	|	Коды.ИдентификаторОбъекта КАК ИдентификаторОбъекта
	|ПОМЕСТИТЬ Идентификаторы
	|ИЗ
	|	&Идентификаторы КАК Коды
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	Ссылка";
	МенеджерВТ = Новый МенеджерВременныхТаблиц;
		
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МенеджерВТ;
	Запрос.Текст = ТекстЗапросаСозданияТаблицыКодов;
	Запрос.УстановитьПараметр("Идентификаторы", ТаблицаКодов);
	Запрос.Выполнить();
	
	// Для этих типов при сопоставлении используется не код, а ИдентификаторОбъекта
	МассивТипов = Новый Массив;
	ТипыОбщихДанныхСопоставляемыхПоИдентификаторуОбъекта(МассивТипов);
	
	Для каждого ТипЗамены Из МассивТипов Цикл
		МетаданныеОбщегоТипа = Метаданные.НайтиПоТипу(ТипЗамены);
		
		ТекстЗапроса = 
			"ВЫБРАТЬ
			|	Идентификаторы.Ссылка КАК ИсходнаяСсылка,
			|	Идентификаторы.ИдентификаторОбъекта КАК ИдентификаторОбъекта,
			|	ТаблицаСправочника.Ссылка КАК ОбщаяСсылка
			|ИЗ
			|	Идентификаторы КАК Идентификаторы
			|		ЛЕВОЕ СОЕДИНЕНИЕ " + МетаданныеОбщегоТипа.ПолноеИмя() + " КАК ТаблицаСправочника
			|		ПО Идентификаторы.ИдентификаторОбъекта = ТаблицаСправочника.ИдентификаторОбъекта
			|ГДЕ
			|	Идентификаторы.Ссылка ССЫЛКА " + МетаданныеОбщегоТипа.ПолноеИмя();
			
		Запрос.Текст = ТекстЗапроса;
		Результат = Запрос.Выполнить();
		
		СтрокаТипа = СловарьЗамен.Найти(ТипЗамены, "Тип");
		Если СтрокаТипа = Неопределено Тогда
			СтрокаТипа = СловарьЗамен.Добавить();
			СтрокаТипа.Тип = ТипЗамены;
			СтрокаТипа.СоответствиеСсылок = Новый Соответствие;
		КонецЕсли;
		СоответствиеСсылок = СтрокаТипа.СоответствиеСсылок;
		
		Выборка = Результат.Выбрать();
		Пока Выборка.Следующий() Цикл
			СоответствиеСсылок.Вставить(
				Выборка.ОбщаяСсылка.УникальныйИдентификатор(),
				Выборка.ИсходнаяСсылка.УникальныйИдентификатор());
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

// Заполняет массив типов неразделенных данных. Он используется при обновлении ссылок 
// при загрузке-выгрузке конфигурации
// 
// Параметры:
//  МассивТипов - массив
//
Процедура ТипыОбщихДанных(Знач МассивТипов) Экспорт
	ЗарплатаКадрыВнутренний.ТипыОбщихДанных(МассивТипов);
КонецПроцедуры

// Заполняет массив типов неразделенных данных, 
// для которых при выгрузке/загрузке используется сопоставление не по коду, 
// а по реквизиту ИдентификаторОбъекта
// 
// Параметры:
//  МассивТипов - массив
//
Процедура ТипыОбщихДанныхСопоставляемыхПоИдентификаторуОбъекта(Знач МассивТипов) Экспорт
	ЗарплатаКадрыВнутренний.ТипыОбщихДанныхСопоставляемыхПоИдентификаторуОбъекта(МассивТипов);
КонецПроцедуры

///////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции ЗАРПЛАТА И КАДРЫ

// Заполняет документ по основанию сотрудник, осуществляет проверку корректности ввода документа
// В случае , когда проверка не проходит вызывает исключение
//
// Параметры:
//		ДокументОбъект - ДокументОбъект
//		ДанныеЗаполнения - СправочникСсылка.Сотрудники
//		ПроверкаОформленностиНаРаботу - Булево, когда Истина вызывает исключение, если сотрудник уже принят на работу,
//										Ложь - если сотрудник еще не принят
//		ОтключитьПроверкуЗанятости - Булево, отключает проверку принятости сотрудника
//
// Возвращаемое значение - Булево, Истина - ДанныеЗаполнения заполнен имеют тип СправочникСсылка.Сотрудники, Ложь - если 
//						   ДанныеЗаполнения содержат значение другого типа.
//
Процедура ЗаполнитьПоОснованиюСотрудником(ДокументОбъект, ДанныеЗаполнения, ПроверкаОформленностиНаРаботу = Ложь, ОтключитьПроверкуЗанятости = Ложь) Экспорт
	
	КадровыеДанные =  КадровыйУчет.КадровыеДанныеСотрудников(Истина, ДанныеЗаполнения, "ГоловнаяОрганизация,Организация,ФизическоеЛицо,ДатаПриема,ОформленПриемНаРаботу,ДатаУвольнения", ТекущаяДатаСеанса());
	Если КадровыеДанные.Количество() > 0 Тогда
		
		СтрокаДанных = КадровыеДанные[0];
		
		Если НЕ ОтключитьПроверкуЗанятости Тогда
			
			Если ПроверкаОформленностиНаРаботу Тогда
				
				Если СтрокаДанных.ОформленПриемНаРаботу Тогда
					
					Если ЗначениеЗаполнено(СтрокаДанных.ДатаУвольнения) Тогда
						
						ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
							НСтр("ru='Сотрудник ""%1"" был оформлен на работу с %2, уволен %3';uk='Співробітник ""%1"" був оформлений на роботу з %2, звільнений %3'"),
							ДанныеЗаполнения,
							Формат(СтрокаДанных.ДатаПриема, "ДЛФ=DD"),
							Формат(СтрокаДанных.ДатаУвольнения, "ДЛФ=DD"));
						
					Иначе
						
						Если ЗначениеЗаполнено(СтрокаДанных.ДатаПриема) Тогда
							
							ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
								НСтр("ru='Сотрудник ""%1"" уже оформлен на работу с %2';uk='Співробітник ""%1"" вже оформлений на роботу з %2'"),
								ДанныеЗаполнения,
								Формат(СтрокаДанных.ДатаПриема, "ДЛФ=DD"));
							
						Иначе
								
							ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
								НСтр("ru='Сотрудник ""%1"" уже оформлен на работу';uk='Співробітник ""%1"" вже оформлений на роботу'"),
								ДанныеЗаполнения);
							
						КонецЕсли;
						
					КонецЕсли;
					
				КонецЕсли; 
					
			Иначе
				
				Если НЕ ЗначениеЗаполнено(СтрокаДанных.Организация) Тогда
					
					ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru='Сотрудник ""%1"" не оформлен на работу';uk='Співробітник ""%1"" не оформлений на роботу'"),
						ДанныеЗаполнения);
					
				ИначеЕсли ЗначениеЗаполнено(СтрокаДанных.ДатаУвольнения) Тогда
						
					ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru='Сотрудник ""%1"" уволен %2';uk='Співробітник ""%1"" звільнений %2'"),
						ДанныеЗаполнения,
						Формат(СтрокаДанных.ДатаУвольнения, "ДЛФ=DD"));
					
				КонецЕсли;
					
			КонецЕсли;
			
		КонецЕсли; 
		
		Если ЗначениеЗаполнено(СтрокаДанных.Организация) Тогда
			ДокументОбъект.Организация = СтрокаДанных.Организация;
		Иначе
			ДокументОбъект.Организация = СтрокаДанных.ГоловнаяОрганизация;
		КонецЕсли;
		
		МетаданныеДокумента = ДокументОбъект.Метаданные();
		
		Если МетаданныеДокумента.Реквизиты.Найти("Сотрудник") <> Неопределено Тогда
			
			ДокументОбъект.Сотрудник 		= СтрокаДанных.Сотрудник;
			
		КонецЕсли; 
		
		Если МетаданныеДокумента.Реквизиты.Найти("ФизическоеЛицо") <> Неопределено Тогда
			
			ДокументОбъект.ФизическоеЛицо 	= СтрокаДанных.ФизическоеЛицо;
			
		КонецЕсли; 
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ПолучитьПрефиксообразующиеРеквизиты(Объекты) Экспорт
	ЗарплатаКадрыВнутренний.ПолучитьПрефиксообразующиеРеквизиты(Объекты);
КонецПроцедуры

Процедура ЗаполнитьИсточникиДанныхДляПроверкиЗапретаИзменения(ИсточникиДанных) Экспорт
	ЗарплатаКадрыВнутренний.ЗаполнитьИсточникиДанныхДляПроверкиЗапретаИзменения(ИсточникиДанных);	
КонецПроцедуры

Процедура ПередПроверкойЗапретаИзменения(Объект, ПроверкаЗапретаИзменения, УзелПроверкиЗапретаЗагрузки, ВерсияОбъекта) Экспорт
	
	Если Объект.ДополнительныеСвойства.Свойство("ОтключитьПроверкуДатыЗапретаИзменения")
		И Объект.ДополнительныеСвойства.ОтключитьПроверкуДатыЗапретаИзменения Тогда
		
		ПроверкаЗапретаИзменения = Ложь;
		СообщитьОЗапрете = Ложь;
		
	КонецЕсли; 	
	
КонецПроцедуры

// Возвращает структуру с полями
//	ИзмеренияФильтра - массив имен измерений по которым выполняется отбор
//	Измерения - массив имен всех измерений регистра
//	Ресурсы - массив имен ресурсов, которые не имеют "пары" ...ПоОкончании, кроме ДействуетДо
//	ВозвратныеРесурсы - массив имен ресурсов, которые имеют "пару" с именем ...ПоОкончании
//	Реквизиты - массив имен всех реквизитов
//  СтандартныеРеквизиты - массив имен стандартных реквизитов
Функция КоллекцииПолейДляПодготовкиТекстаЗапроса(ИмяРегистра, МассивИзмерений) Экспорт
	// Измерения для отбора
	ИзмеренияФильтра = Новый Массив;
	Для Каждого Измерение Из МассивИзмерений Цикл
		Если 	ВРег(Измерение) = ВРег("Период") Или 
				ВРег(Измерение) = ВРег("ДатаНачала") Или 
				ВРег(Измерение) = ВРег("ДатаОкончания") Тогда
			Продолжить;
		КонецЕсли;
		ИзмеренияФильтра.Добавить(Измерение);
	КонецЦикла;
	
	РегистрСведенийМетаданные = Метаданные.РегистрыСведений[ИмяРегистра];
	
	// Все измерения
	Измерения = Новый Массив;
	Для Каждого Измерение Из РегистрСведенийМетаданные.Измерения Цикл
		Измерения.Добавить(Измерение.Имя);
	КонецЦикла;
	
	ЕстьВозвратныеСобытия = Ложь;
	
	// Ресурсы
	Ресурсы = Новый Массив;
	ВозвратныеРесурсы = Новый Массив;
	Для Каждого Ресурс Из РегистрСведенийМетаданные.Ресурсы Цикл
		Если ВРег(Ресурс.Имя) = ВРег("ДействуетДо") Тогда
			ЕстьВозвратныеСобытия = Истина;
			Продолжить; // не включаем ресурс ДействуетДо в список получаемых ресурсов
		КонецЕсли;	
		Если ВРег(Прав(Ресурс.Имя, 11)) <> ВРег("ПоОкончании") Тогда
			Ресурсы.Добавить(Ресурс.Имя);
		Иначе	
			ВозвратныеРесурсы.Добавить(Лев(Ресурс.Имя, СтрДлина(Ресурс.Имя) - 11));
		КонецЕсли;	
	КонецЦикла;
	
	// Удалим из списка "простых" ресурсов те, которые являются "возвратными"
	Для Каждого Ресурс Из ВозвратныеРесурсы Цикл
		ИндексРесурса = Ресурсы.Найти(Ресурс);
		Если ИндексРесурса <> Неопределено Тогда
			Ресурсы.Удалить(ИндексРесурса);
		КонецЕсли;			
	КонецЦикла;
	
	// Реквизиты
	Реквизиты = Новый Массив;
	Для Каждого Реквизит Из РегистрСведенийМетаданные.Реквизиты Цикл
		Реквизиты.Добавить(Реквизит.Имя);
	КонецЦикла;
	
	// СтандартныеРеквизиты
	СтандартныеРеквизиты = Новый Массив;
	Для Каждого СтандартныйРеквизит Из РегистрСведенийМетаданные.СтандартныеРеквизиты Цикл
		Если СтандартныйРеквизит.Имя <> "Период" Тогда
			СтандартныеРеквизиты.Добавить(СтандартныйРеквизит.Имя);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Новый Структура("ИзмеренияФильтра,Измерения,ВозвратныеРесурсы,Ресурсы,Реквизиты,СтандартныеРеквизиты",
							ИзмеренияФильтра, Измерения, ВозвратныеРесурсы, Ресурсы, Реквизиты, СтандартныеРеквизиты);
	
КонецФункции

// Возвращает признак необходимости отключения бизнес логики при записи объекта
//
// Параметры:
//  Объект - прикладной объект, например СправочникОбъект - объект для которого
//   требуется проверить необходимость отключения бизнес логики при записи.
//
// Возвращаемое значение:
//  Булево - признак необходимости отключения бизнес логики при записи объекта
//
Функция ОтключитьБизнесЛогикуПриЗаписи(Знач Объект) Экспорт
	
	Возврат Объект.ОбменДанными.Загрузка И (НЕ Объект.ДополнительныеСвойства.Свойство("ПроверятьБизнесЛогикуПриЗаписи")); 
		
КонецФункции

// Преобразовывает переданные массивы сотрудников и физических лиц в строку 
// вида <Фамилия И.О., Фамилия И.О...>
// Используется для заполнения краткого состава документов
//
// Параметры:
//	- Сотрудники - массив элементов типа СправочникСсылка.Сотрудники,
//	- ДатаАктуальности - дата для получения фамилии, имени и отчества
//	- Физлица - необязательный, массив элементов типа СправочникСсылка.ФизическиеЛица
//	- ФизлицаСотрудников - соответствие Сотрудник - Физическое лицо
//
Функция КраткийСоставСотрудников(Сотрудники, ДатаАктуальности, Физлица = Неопределено, ФизлицаСотрудников = Неопределено) Экспорт
	
	Если ФизлицаСотрудников <> Неопределено Тогда
		ФизлицаСотрудников = ОбщегоНазначения.ЗначениеРеквизитаОбъектов(Сотрудники, "ФизическоеЛицо");
	КонецЕсли;
	
	// Первые N человек и M символов
	МаксимальноеКоличествоФизическихЛиц = 10;
	МаксимальнаяДлинаСтроки = 100;

	Счетчик = 0;
	ПервыеФизлица = Новый Массив;
	УникальныеФизлица = Новый Соответствие;
	Для Каждого Сотрудник Из Сотрудники Цикл
		Если Счетчик = МаксимальноеКоличествоФизическихЛиц Тогда
			Прервать;
		КонецЕсли;
		Физлицо = ФизлицаСотрудников[Сотрудник];
		Если Не ЗначениеЗаполнено(Физлицо) 
			Или УникальныеФизлица[Физлицо] <> Неопределено Тогда
			Продолжить;	
		КонецЕсли;
		ПервыеФизлица.Добавить(Физлицо);
		УникальныеФизлица.Вставить(Физлицо, Истина);
		Счетчик = Счетчик + 1;
	КонецЦикла;
	
	// Если физлиц сотрудников не достаточно, 
	// добавляем данные табличных частей, где непосредственно Физические лица
	Если Счетчик < МаксимальноеКоличествоФизическихЛиц И Физлица <> Неопределено Тогда
		Для Каждого Физлицо Из Физлица Цикл
			Если Счетчик = МаксимальноеКоличествоФизическихЛиц Тогда
				Прервать;
			КонецЕсли;
			Если Не ЗначениеЗаполнено(Физлицо) 
				Или УникальныеФизлица[Физлицо] <> Неопределено Тогда
				Продолжить;	
			КонецЕсли;
			ПервыеФизлица.Добавить(Физлицо);
			УникальныеФизлица.Вставить(Физлицо, Истина);
			Счетчик = Счетчик + 1;
		КонецЦикла;
	КонецЕсли;
	
	ИменаФизлиц = СоответствиеФИОФизЛицСсылкам(ДатаАктуальности, ПервыеФизлица);
	
	КраткийСостав = "";
	Для Каждого Физлицо Из ПервыеФизлица Цикл
		Если Не ПустаяСтрока(КраткийСостав) Тогда
			КраткийСостав = КраткийСостав + ", ";
		КонецЕсли;
		ФИО = ИменаФизлиц[Физлицо];
		КраткийСостав = КраткийСостав + ФизическиеЛицаБП.ФамилияИнициалыФизЛица(Неопределено, ФИО.Фамилия, ФИО.Имя, ФИО.Отчество);
	КонецЦикла;
	Если СтрДлина(КраткийСостав) > МаксимальнаяДлинаСтроки Тогда
		КраткийСостав = Лев(КраткийСостав, МаксимальнаяДлинаСтроки - 3) + "...";
	КонецЕсли;
	
	Возврат КраткийСостав;

КонецФункции

/////////////////////////////////////////////////////////////////////////////////////////
// Особенные математические функции подгонки сумм

Процедура ОкруглитьСлагаемыеПоСумме(Данные, ИмяКолонки, Сумма, Точность = 0, ИмяКлюча = "ФизическоеЛицо") Экспорт 
	
	ВременнаяТаблица = Данные.Скопировать(, ИмяКлюча + "," + ИмяКолонки);
	ВременнаяТаблица.Колонки.Добавить(ИмяКолонки + "Окр");
	Для каждого СтрокаТЗ Из ВременнаяТаблица Цикл
		СтрокаТЗ[ИмяКолонки + "Окр"] = Окр(СтрокаТЗ[ИмяКолонки],Точность)
	КонецЦикла;
	Данные.ЗагрузитьКолонку(ВременнаяТаблица.ВыгрузитьКолонку(ИмяКолонки + "Окр"),ИмяКолонки);
	
	СуммаСлагаемых = ВременнаяТаблица.Итог(ИмяКолонки + "Окр");
	Если СуммаСлагаемых <> Сумма Тогда
		Шаг = Pow(10, -Точность);
		РасхождениеСуммы = Сумма - СуммаСлагаемых;
		Приращение = ?(РасхождениеСуммы > 0, Шаг, -Шаг);
		ВсегоПриращений = Мин(РасхождениеСуммы / Приращение, ВременнаяТаблица.Количество());
		ВременнаяТаблица.Колонки.Добавить(ИмяКолонки + "Расхождение");
		ВременнаяТаблица.Колонки.Добавить(ИмяКолонки + "Изменение");
		Для каждого СтрокаТЗ Из ВременнаяТаблица Цикл
			СтрокаТЗ[ИмяКолонки + "Расхождение"] = ?(СтрокаТЗ[ИмяКолонки + "Окр"] < СтрокаТЗ[ИмяКолонки], СтрокаТЗ[ИмяКолонки] - СтрокаТЗ[ИмяКолонки + "Окр"], СтрокаТЗ[ИмяКолонки + "Окр"] - СтрокаТЗ[ИмяКолонки]);
			СтрокаТЗ[ИмяКолонки + "Изменение"] = ?(СтрокаТЗ[ИмяКолонки + "Окр"] < СтрокаТЗ[ИмяКолонки], - Шаг, Шаг);
		КонецЦикла;
		ВременнаяТаблица.Сортировать(ИмяКолонки + "Изменение" + ?(Приращение > 0,""," Убыв") + ", " + ИмяКолонки + "Расхождение Убыв");
		СтруктураПоиска = Новый Структура(ИмяКлюча); 
		Для Сч = 1 По ВсегоПриращений Цикл
			Если ВременнаяТаблица[Сч-1][ИмяКолонки + "Изменение"] <> Приращение Тогда
				ЗаполнитьЗначенияСвойств(СтруктураПоиска, ВременнаяТаблица[Сч-1]);
				Данные.НайтиСтроки(СтруктураПоиска)[0][ИмяКолонки] = ВременнаяТаблица[Сч-1][ИмяКолонки + "Окр"] + Приращение;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;

КонецПроцедуры

Процедура ОкруглитьДваСлагаемыхПоСумме(ПервоеСлагаемое, ВтороеСлагаемое, Сумма, Точность = 0) Экспорт

	Если Окр(ПервоеСлагаемое,Точность) + Окр(ВтороеСлагаемое,Точность) = Сумма Тогда
		ПервоеСлагаемое = Окр(ПервоеСлагаемое,Точность);
		ВтороеСлагаемое = Окр(ВтороеСлагаемое,Точность);
	Иначе
		РасхождениеСуммы = Сумма - Окр(ПервоеСлагаемое,Точность) - Окр(ВтороеСлагаемое,Точность);
		ПервоеРасхождение = ?(Окр(ПервоеСлагаемое,Точность) < ПервоеСлагаемое, ПервоеСлагаемое - Окр(ПервоеСлагаемое,Точность), Окр(ПервоеСлагаемое,Точность) - ПервоеСлагаемое);
		ВтороеРасхождение = ?(Окр(ВтороеСлагаемое,Точность) < ВтороеСлагаемое, ВтороеСлагаемое - Окр(ВтороеСлагаемое,Точность), Окр(ВтороеСлагаемое,Точность) - ВтороеСлагаемое);
		ПервоеСлагаемое = Окр(ПервоеСлагаемое,Точность);
		ВтороеСлагаемое = Окр(ВтороеСлагаемое,Точность);
		Если ПервоеРасхождение <= ВтороеРасхождение Тогда
			ВтороеСлагаемое = ВтороеСлагаемое + РасхождениеСуммы; 
		Иначе
			ПервоеСлагаемое = ПервоеСлагаемое + РасхождениеСуммы; 
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////////////////////////
// Работа с личными данными физических лиц

Процедура ОбработатьЗаписьНабораФИО(НаборЗаписей) Экспорт
	ТаблицаФизЛиц = НаборЗаписей.Выгрузить();
	ОбновитьНаименованияФизЛицаИСотрудника(ТаблицаФизЛиц);	
КонецПроцедуры

Процедура ОбновитьНаименованияФизЛицаИСотрудника(ТаблицаФизЛиц) Экспорт
	
 	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	
	Запрос.УстановитьПараметр("ТекущаяДата", '20990101');
	Запрос.УстановитьПараметр("ТекущийНабор", ТаблицаФизЛиц);
	
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ТекущийНабор.ФизическоеЛицо
	|ПОМЕСТИТЬ ВТФизЛицаТекущегоНабора
	|ИЗ
	|	&ТекущийНабор КАК ТекущийНабор
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ФИОФизическихЛицСрезПоследних.ФизическоеЛицо,
	|	ФИОФизическихЛицСрезПоследних.Фамилия,
	|	ФИОФизическихЛицСрезПоследних.Имя,
	|	ФИОФизическихЛицСрезПоследних.Отчество
	|ПОМЕСТИТЬ ВТФИОФизЛицПоследнее
	|ИЗ
	|	ВТФизЛицаТекущегоНабора КАК ФизЛицаТекущегоНабора
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ФИОФизическихЛиц.СрезПоследних(
	|				&ТекущаяДата,
	|				ФизическоеЛицо В
	|					(ВЫБРАТЬ
	|						ФизЛицаТекущегоНабора.ФизическоеЛицо
	|					ИЗ
	|						ВТФизЛицаТекущегоНабора КАК ФизЛицаТекущегоНабора)) КАК ФИОФизическихЛицСрезПоследних
	|		ПО ФизЛицаТекущегоНабора.ФизическоеЛицо = ФИОФизическихЛицСрезПоследних.ФизическоеЛицо
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ФИОФизЛицПоследнее.ФизическоеЛицо,
	|	ФИОФизЛицПоследнее.Фамилия,
	|	ФИОФизЛицПоследнее.Имя,
	|	ФИОФизЛицПоследнее.Отчество,
	|	ФизическиеЛица.Наименование,
	|	ФизическиеЛица.УточнениеНаименования
	|ИЗ
	|	ВТФИОФизЛицПоследнее КАК ФИОФизЛицПоследнее
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ФизическиеЛица КАК ФизическиеЛица
	|		ПО (ФИОФизЛицПоследнее.ФизическоеЛицо = ФизическиеЛица.Ссылка
	|				И (ФизическиеЛица.Наименование <> (ВЫРАЗИТЬ(ФИОФизЛицПоследнее.Фамилия + ВЫБОР
	|							КОГДА ФИОФизЛицПоследнее.Имя = """"
	|								ТОГДА """"
	|							ИНАЧЕ "" "" + ФИОФизЛицПоследнее.Имя
	|						КОНЕЦ + ВЫБОР
	|							КОГДА ФИОФизЛицПоследнее.Отчество = """"
	|								ТОГДА """"
	|							ИНАЧЕ "" "" + ФИОФизЛицПоследнее.Отчество
	|						КОНЕЦ + ВЫБОР
	|							КОГДА ФизическиеЛица.УточнениеНаименования = """"
	|								ТОГДА """"
	|							ИНАЧЕ "" "" + ФизическиеЛица.УточнениеНаименования
	|						КОНЕЦ КАК СТРОКА(50)))
	|					ИЛИ ФизическиеЛица.ФИО <> (ВЫРАЗИТЬ(ФИОФизЛицПоследнее.Фамилия + ВЫБОР
	|							КОГДА ФИОФизЛицПоследнее.Имя = """"
	|								ТОГДА """"
	|							ИНАЧЕ "" "" + ФИОФизЛицПоследнее.Имя
	|						КОНЕЦ + ВЫБОР
	|							КОГДА ФИОФизЛицПоследнее.Отчество = """"
	|								ТОГДА """"
	|							ИНАЧЕ "" "" + ФИОФизЛицПоследнее.Отчество
	|						КОНЕЦ КАК СТРОКА(50)))))
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	Сотрудники.Ссылка КАК Сотрудник,
	|	ФИОФизЛицПоследнее.Фамилия,
	|	ФИОФизЛицПоследнее.Имя,
	|	ФИОФизЛицПоследнее.Отчество,
	|	Сотрудники.УточнениеНаименования,
	|	Сотрудники.Наименование КАК СотрудникНаименование,
	|	ФизическиеЛица.УточнениеНаименования КАК УточнениеНаименованияФизЛица
	|ИЗ
	|	ВТФИОФизЛицПоследнее КАК ФИОФизЛицПоследнее
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Сотрудники КАК Сотрудники
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ФизическиеЛица КАК ФизическиеЛица
	|			ПО Сотрудники.ФизическоеЛицо = ФизическиеЛица.Ссылка
	|		ПО ФИОФизЛицПоследнее.ФизическоеЛицо = Сотрудники.ФизическоеЛицо
	|			И (Сотрудники.Наименование <> (ВЫРАЗИТЬ(ФИОФизЛицПоследнее.Фамилия + ВЫБОР
	|					КОГДА ФИОФизЛицПоследнее.Имя = """"
	|						ТОГДА """"
	|					ИНАЧЕ "" "" + ФИОФизЛицПоследнее.Имя
	|				КОНЕЦ + ВЫБОР
	|					КОГДА ФИОФизЛицПоследнее.Отчество = """"
	|						ТОГДА """"
	|					ИНАЧЕ "" "" + ФИОФизЛицПоследнее.Отчество
	|				КОНЕЦ + ВЫБОР
	|					КОГДА ФизическиеЛица.УточнениеНаименования = """"
	|						ТОГДА """"
	|					ИНАЧЕ "" "" + ФизическиеЛица.УточнениеНаименования
	|				КОНЕЦ + ВЫБОР
	|					КОГДА Сотрудники.УточнениеНаименования = """"
	|						ТОГДА """"
	|					ИНАЧЕ "" "" + Сотрудники.УточнениеНаименования
	|				КОНЕЦ КАК СТРОКА(50))))";
	
				   
	Результат = Запрос.ВыполнитьПакет();
	
	ИзменитьНаименованиеФизическихЛиц(Результат[2].Выбрать());
	ИзменитьНаименованиеСотрудников(Результат[3].Выбрать());
	
	УстановитьПривилегированныйРежим(Ложь);
КонецПроцедуры

///////////////////////////////////////////////////////////////////////////////
// Регламентированная отчетность

// Процедура заполняет список используемых регламентированных отчетов
//
Процедура ЗаполнитьСписокРегламентированныхОтчетов(СписокРегламентированныхОтчетов) Экспорт
	ЗарплатаКадрыВнутренний.ЗаполнитьСписокРегламентированныхОтчетов(СписокРегламентированныхОтчетов);
КонецПроцедуры

// Процедура заполняет структуру показателей.
// Ключ структуры – идентификатор показателя.
// Значение структуры – массив из двух элементов:
// 	- признак автозаполнения показателя,
//	- признак расшифровки показателя.
//
// Параметры:
// 	ПоказателиОтчета - структура показателей отчета,
// 	ИДОтчета         - идентификатор отчета,
//	ИДРедакцииОтчета - идентификатор редакции формы отчета.
//
Процедура ЗаполнитьПоказателиРегламентированногоОтчета(ПоказателиОтчета, ИДОтчета, ИДРедакцииОтчета) Экспорт
	ЗарплатаКадрыВнутренний.ЗаполнитьПоказателиРегламентированногоОтчета(ПоказателиОтчета, ИДОтчета, ИДРедакцииОтчета);
КонецПроцедуры

// Процедура заполняет переданную в виде контейнера структуру данных отчета.
//
Процедура ЗаполнитьРегламентированныйОтчет(ИДОтчета, ИДРедакцииОтчета, ПараметрыОтчета, Контейнер) Экспорт
	ЗарплатаКадрыВнутренний.ЗаполнитьРегламентированныйОтчет(ИДОтчета, ИДРедакцииОтчета, ПараметрыОтчета, Контейнер);
КонецПроцедуры

// Процедура добавляет описание показателя регламентированной отчетности
//
Процедура ДобавитьПоказательРегламентированнойОтчетности(СтруктураПоказателей, ИмяПоказателя, ПризнакАвтозаполнения, ПризнакРасшифровки) Экспорт
	РегламентированнаяОтчетность.ВставитьПоказательВСтруктуру(СтруктураПоказателей, ИмяПоказателя, ПризнакАвтозаполнения, ПризнакРасшифровки);
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Прочие процедуры и функции

Функция РазделительЗапросов() Экспорт
	
	Возврат "
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|";
		
КонецФункции

Функция УникальноеИмяВременнойТаблицы(ИмяВременнойТаблицы) Экспорт
	
	Возврат ИмяВременнойТаблицы + "_" + СтрЗаменить(Строка(Новый УникальныйИдентификатор), "-", "x");
	
КонецФункции

Процедура ДобавитьТекстУдаленияВременнойТаблицы(ТекстЗапроса, ИмяВременнойТаблицы) Экспорт
	
		ТекстЗапроса = ТекстЗапроса + РазделительЗапросов() + "УНИЧТОЖИТЬ " + ИмяВременнойТаблицы;
		
КонецПроцедуры

Процедура ДобавитьТекстУдаленияВременныхТаблиц(ТекстЗапроса, МассивИменВременныхТаблиц) Экспорт
	
	Для каждого ИмяВТКУничтожению Из МассивИменВременныхТаблиц Цикл
		
		ДобавитьТекстУдаленияВременнойТаблицы(ТекстЗапроса, ИмяВТКУничтожению);
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ОбъединитьТекстыЗапросов(ТекстЗапросаПриемник, ТекстЗапросаИсточник) Экспорт
	
	ТекстЗапросаПриемник = ?(ПустаяСтрока(ТекстЗапросаПриемник), "", ТекстЗапросаПриемник + РазделительЗапросов()) + ТекстЗапросаИсточник;
	
КонецПроцедуры

Процедура СкопироватьПараметрыЗапроса(ЗапросПриемник, ЗапросИсточник) Экспорт
	
	Для каждого Параметр Из ЗапросИсточник.Параметры Цикл
		
		ЗапросПриемник.УстановитьПараметр(Параметр.Ключ, Параметр.Значение);
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ОбъединитьЗапросы(ЗапросПриемник, ЗапросИсточник) Экспорт
	
	ОбъединитьТекстыЗапросов(ЗапросПриемник.Текст, ЗапросИсточник.Текст);
	СкопироватьПараметрыЗапроса(ЗапросПриемник,  ЗапросИсточник);
	
КонецПроцедуры

Функция ЗапросВТИмяРегистраСрез(ТолькоРазрешенные, КоллекцииПолей, ИмяРегистра, ИмяТаблицыИзмерений, ИмяСоздаваемойТаблицы = "",
	Отбор = Неопределено, ВсеЗаписи = Ложь, ВключаяГраницу = Истина, СрезПоследних = Истина, СоответствиеИзмеренийПолямТаблицы = Неопределено) Экспорт
	
	Если СоответствиеИзмеренийПолямТаблицы = Неопределено Тогда
		СоответствиеИзмеренийПолямТаблицы = Новый Соответствие;
	КонецЕсли;
	
	ИзмерениеФильтраПериод = СоответствиеИзмеренийПолямТаблицы.Получить("Период");
	Если ИзмерениеФильтраПериод = Неопределено Тогда
		ИзмерениеФильтраПериод = "Период";
	КонецЕсли;
	
	Запрос = Новый Запрос;
	
	Если ПустаяСтрока(ИмяСоздаваемойТаблицы) Тогда
		ИмяСоздаваемойТаблицы = "ВТ" + ИмяРегистра + ?(СрезПоследних,"СрезПоследних","СрезПервых");
	КонецЕсли; 
	
	ИмяВТМаксимальныеПериоды = УникальноеИмяВременнойТаблицы("ВТМаксимальныеПериоды");
	
	ТекстЗапроса = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ИзмеренияДаты." + ИзмерениеФильтраПериод + " КАК ЗаданныйПериод";
	Для Каждого Измерение Из КоллекцииПолей.Измерения Цикл
		Если КоллекцииПолей.ИзмеренияФильтра.Найти(Измерение) <> НеОпределено Тогда
			ИзмерениеФильтра = СоответствиеИзмеренийПолямТаблицы.Получить(Измерение);
			Если ИзмерениеФильтра = Неопределено Тогда
				ИзмерениеФильтра = Измерение;
			КонецЕсли;
			ТекстЗапроса = ТекстЗапроса + ",
			|	ИзмеренияДаты." + ИзмерениеФильтра + " КАК " + Измерение;
		Иначе
			ТекстЗапроса = ТекстЗапроса + ",
			|	РегистрСведений." + Измерение;
		Конецесли;
	КонецЦикла;
	
	Если СрезПоследних Тогда
		ТекстЗапроса = ТекстЗапроса + ",
		|	МАКСИМУМ(РегистрСведений.Период) КАК Период
		|ПОМЕСТИТЬ " + ИмяВТМаксимальныеПериоды + "
		|ИЗ
		|	" + ИмяТаблицыИзмерений + " КАК ИзмеренияДаты
		|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений." + ИмяРегистра + " КАК РегистрСведений
		|		ПО (РегистрСведений.Период <= ИзмеренияДаты." + ИзмерениеФильтраПериод + " ИЛИ ИзмеренияДаты." + ИзмерениеФильтраПериод + " = ДАТАВРЕМЯ(1,1,1,0,0,0))";
		Если НЕ ВключаяГраницу Тогда
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса,"<=","<");
		КонецЕсли;
	Иначе
		ТекстЗапроса = ТекстЗапроса + ",
		|	МИНИМУМ(РегистрСведений.Период) КАК Период
		|ПОМЕСТИТЬ " + ИмяВТМаксимальныеПериоды + "
		|ИЗ
		|	" + ИмяТаблицыИзмерений + " КАК ИзмеренияДаты
		|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений." + ИмяРегистра + " КАК РегистрСведений
		|		ПО (РегистрСведений.Период >= ИзмеренияДаты." + ИзмерениеФильтраПериод + ")";
		Если НЕ ВключаяГраницу Тогда
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса,">=",">");
		КонецЕсли;
	КонецЕсли;
	
	Для Каждого Измерение Из КоллекцииПолей.ИзмеренияФильтра Цикл
		ИзмерениеФильтра = СоответствиеИзмеренийПолямТаблицы.Получить(Измерение);
		Если ИзмерениеФильтра = Неопределено Тогда
			ИзмерениеФильтра = Измерение;
		КонецЕсли;
		ТекстЗапроса = ТекстЗапроса + "
		|			И (РегистрСведений." + Измерение + " = ИзмеренияДаты." + ИзмерениеФильтра + ")";
	КонецЦикла;
	
	Если Отбор <> Неопределено И Отбор.Количество() > 0 Тогда
		СчПараметров = 1;
		ТекстОтбор = "
		|	И (";
		Для Каждого СтруктураОтбора Из Отбор Цикл
			Если ТипЗнч(СтруктураОтбора.ПравоеЗначение) = Тип("Строка") Тогда
				ОписаниеПараметра = СтруктураОтбора.ПравоеЗначение;
			Иначе
				ИмяПараметра = ИмяСоздаваемойТаблицы +"_Параметр" + СчПараметров;
				ОписаниеПараметра = "&" + ИмяПараметра;
				Запрос.УстановитьПараметр(ИмяПараметра, СтруктураОтбора.ПравоеЗначение);
			КонецЕсли;
			ТекстОтбор = ТекстОтбор + "
			|	РегистрСведений." + СтруктураОтбора.ЛевоеЗначение + " " + СтруктураОтбора.ВидСравнения + " (" + ОписаниеПараметра + ") И";
			СчПараметров = СчПараметров + 1;
		КонецЦикла;	
		ТекстОтбор = Лев(ТекстОтбор, СтрДлина(ТекстОтбор) - 1);
		ТекстОтбор = ТекстОтбор + ")";
		ТекстЗапроса = ТекстЗапроса + ТекстОтбор;
	КонецЕсли;
	
	ТекстОтборовСКД = "";
	Для каждого Измерение Из КоллекцииПолей.ИзмеренияФильтра Цикл
		ТекстОтборовСКД = ?(ПустаяСтрока(ТекстОтборовСКД), "", ТекстОтборовСКД + "," + Символы.ПС) + "	РегистрСведений." + Измерение + ".*";
	КонецЦикла;
	
	Если НЕ ПустаяСтрока(ТекстОтборовСКД) Тогда
		ТекстЗапроса = ТекстЗапроса + "
			|{ГДЕ
			|" + ТекстОтборовСКД + "}";
	КонецЕсли; 
	
	ТекстЗапроса = ТекстЗапроса + "
	|
	|СГРУППИРОВАТЬ ПО
	|	ИзмеренияДаты." + ИзмерениеФильтраПериод;
	Для Каждого Измерение Из КоллекцииПолей.Измерения Цикл
		Если КоллекцииПолей.ИзмеренияФильтра.Найти(Измерение) <> НеОпределено Тогда
			ИзмерениеФильтра = СоответствиеИзмеренийПолямТаблицы.Получить(Измерение);
			Если ИзмерениеФильтра = Неопределено Тогда
				ИзмерениеФильтра = Измерение;
			КонецЕсли;
			ТекстЗапроса = ТекстЗапроса + ",
			|	ИзмеренияДаты." + ИзмерениеФильтра;
		Иначе
			ТекстЗапроса = ТекстЗапроса + ",
			|	РегистрСведений." + Измерение;
		Конецесли;
	КонецЦикла;
	ТекстЗапроса = ТекстЗапроса + РазделительЗапросов() + 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	МаксимальныеПериоды.ЗаданныйПериод КАК Период,
	|	РегистрСведений.Период КАК ПериодЗаписи";
	Для Каждого Измерение Из КоллекцииПолей.Измерения Цикл
		ТекстЗапроса = ТекстЗапроса + ",
		|	МаксимальныеПериоды." + Измерение;
	КонецЦикла;
	
	Если СрезПоследних Тогда
		ТекстЗапросаПолей = "";
		Для Каждого Ресурс Из КоллекцииПолей.ВозвратныеРесурсы Цикл
			ТекстЗапросаПолей = ТекстЗапросаПолей + ",
			|	ВЫБОР
			|		КОГДА РегистрСведений.ДействуетДо = ДАТАВРЕМЯ(1, 1, 1)
			|				ИЛИ РегистрСведений.ДействуетДо >= МаксимальныеПериоды.ЗаданныйПериод И МаксимальныеПериоды.ЗаданныйПериод <> ДАТАВРЕМЯ(1, 1, 1)
			|			ТОГДА РегистрСведений." + Ресурс + "
			|		ИНАЧЕ РегистрСведений." + Ресурс + "ПоОкончании
			|	КОНЕЦ КАК " + Ресурс;
		КонецЦикла;
		Если ВключаяГраницу Тогда
			ТекстЗапросаПолей = СтрЗаменить(ТекстЗапросаПолей,">=",">");
		КонецЕсли;
		ТекстЗапроса = ТекстЗапроса + ТекстЗапросаПолей;
	иначе
		Для Каждого Ресурс Из КоллекцииПолей.ВозвратныеРесурсы Цикл
			ТекстЗапроса = ТекстЗапроса + ",
			|	РегистрСведений." + Ресурс + " КАК " + Ресурс;
			ТекстЗапроса = ТекстЗапроса + ",
			|	РегистрСведений." + Ресурс + "ПоОкончании КАК " + Ресурс + "ПоОкончании";
		КонецЦикла;
	КонецЕсли;
	
	Для Каждого Ресурс Из КоллекцииПолей.Ресурсы Цикл
		ТекстЗапроса = ТекстЗапроса + ",
		|	РегистрСведений." + Ресурс + " КАК " + Ресурс;
	КонецЦикла;
	
	Для Каждого Реквизит Из КоллекцииПолей.Реквизиты Цикл
		ТекстЗапроса = ТекстЗапроса + ",
		|	РегистрСведений." + Реквизит;
	КонецЦикла;
	
	Если НЕ СрезПоследних Тогда
		Для Каждого СтандартныйРеквизит Из КоллекцииПолей.СтандартныеРеквизиты Цикл
			ТекстЗапроса = ТекстЗапроса + ",
			|	РегистрСведений." + СтандартныйРеквизит;
		КонецЦикла;
	КонецЕсли;	
	
	ТекстЗапроса = ТекстЗапроса + "
	|ПОМЕСТИТЬ " + ИмяСоздаваемойТаблицы + "
	|ИЗ
	|	" + ИмяВТМаксимальныеПериоды + " КАК МаксимальныеПериоды
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений." + ИмяРегистра + " КАК РегистрСведений
	|		ПО (РегистрСведений.Период = МаксимальныеПериоды.Период)";
	Для Каждого Измерение Из КоллекцииПолей.Измерения Цикл
		ТекстЗапроса = ТекстЗапроса + "
		|			И (РегистрСведений." + Измерение + " = МаксимальныеПериоды." + Измерение + ")";
	КонецЦикла;
	Если НЕ ВсеЗаписи Тогда
		ТекстЗапроса = ТекстЗапроса + "
		|ГДЕ
		|	(НЕ РегистрСведений.Период ЕСТЬ NULL)";
	КонецЕсли;
	
	ДобавитьТекстУдаленияВременнойТаблицы(ТекстЗапроса, ИмяВТМаксимальныеПериоды);
	
	Если НЕ ТолькоРазрешенные Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ВЫБРАТЬ РАЗРЕШЕННЫЕ", "ВЫБРАТЬ");
	КонецЕсли;
	
	Запрос.Текст = ТекстЗапроса;
		
	Возврат Запрос;
	
КонецФункции

Функция ЗапросВТИмяРегистра(ТолькоРазрешенные, КоллекцииПолей, ИмяРегистра, ИмяТаблицыИзмерений, ИмяСоздаваемойТаблицы = "", Отбор = Неопределено, СоответствиеИзмеренийПолямТаблицы = Неопределено) Экспорт
	
	Если СоответствиеИзмеренийПолямТаблицы = Неопределено Тогда
		СоответствиеИзмеренийПолямТаблицы = Новый Соответствие;
	КонецЕсли;
	
	ИзмерениеФильтраДатаНачала = СоответствиеИзмеренийПолямТаблицы.Получить("ДатаНачала");
	Если ИзмерениеФильтраДатаНачала = Неопределено Тогда
		ИзмерениеФильтраДатаНачала = "ДатаНачала";
	КонецЕсли;
	
	ИзмерениеФильтраДатаОкончания = СоответствиеИзмеренийПолямТаблицы.Получить("ДатаОкончания");
	Если ИзмерениеФильтраДатаОкончания = Неопределено Тогда
		ИзмерениеФильтраДатаОкончания = "ДатаОкончания";
	КонецЕсли;
		
	Запрос = Новый Запрос;
	
	Если ПустаяСтрока(ИмяСоздаваемойТаблицы) Тогда
		ИмяСоздаваемойТаблицы = "ВТ" + ИмяРегистра;
	КонецЕсли; 
	
	ТекстЗапроса = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	РегистрСведений.Период";
	Для Каждого Измерение Из КоллекцииПолей.Измерения Цикл
		ТекстЗапроса = ТекстЗапроса + ",
		|	РегистрСведений." + Измерение;
	КонецЦикла;
	Для Каждого Ресурс Из КоллекцииПолей.ВозвратныеРесурсы Цикл
		ТекстЗапроса = ТекстЗапроса + ",
		|	РегистрСведений." + Ресурс;
	КонецЦикла;
	Для Каждого Ресурс Из КоллекцииПолей.Ресурсы Цикл
		ТекстЗапроса = ТекстЗапроса + ",
		|	РегистрСведений." + Ресурс;
	КонецЦикла;
	Для Каждого Реквизит Из КоллекцииПолей.Реквизиты Цикл
		ТекстЗапроса = ТекстЗапроса + ",
		|	РегистрСведений." + Реквизит;
	КонецЦикла;
	Для Каждого СтандартныйРеквизит Из КоллекцииПолей.СтандартныеРеквизиты Цикл
		ТекстЗапроса = ТекстЗапроса + ",
		|	РегистрСведений." + СтандартныйРеквизит;
	КонецЦикла;
	ТекстЗапроса = ТекстЗапроса + "
	|ПОМЕСТИТЬ " + ИмяСоздаваемойТаблицы + "
	|ИЗ
	|	РегистрСведений." + ИмяРегистра + " КАК РегистрСведений
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ " + ИмяТаблицыИзмерений + " КАК ИзмеренияДаты
	|		ПО (ИзмеренияДаты." + ИзмерениеФильтраДатаНачала + " = ДАТАВРЕМЯ(1, 1, 1) ИЛИ РегистрСведений.Период >= ИзмеренияДаты." + ИзмерениеФильтраДатаНачала + ")
	|	И (ИзмеренияДаты." + ИзмерениеФильтраДатаОкончания + " = ДАТАВРЕМЯ(1, 1, 1) ИЛИ РегистрСведений.Период <= ИзмеренияДаты." + ИзмерениеФильтраДатаОкончания + ") И ";
	
	Для Каждого Измерение Из КоллекцииПолей.ИзмеренияФильтра Цикл
		ИзмерениеФильтра = СоответствиеИзмеренийПолямТаблицы.Получить(Измерение);
		Если ИзмерениеФильтра = Неопределено Тогда
			ИзмерениеФильтра = Измерение;
		КонецЕсли;
		ТекстЗапроса = ТекстЗапроса + "(ИзмеренияДаты." + ИзмерениеФильтра + " = РегистрСведений." + Измерение + ") И ";
	КонецЦикла;
	
	ТекстЗапроса = Лев(ТекстЗапроса, СтрДлина(ТекстЗапроса) - 3);
	
	Если Отбор <> Неопределено И Отбор.Количество() > 0 Тогда
		СчПараметров = 1;
		ТекстОтбор = "
		|	ГДЕ (";
		
		Для Каждого СтруктураОтбора Из Отбор Цикл
			Если ТипЗнч(СтруктураОтбора.ПравоеЗначение) = Тип("Строка") Тогда
				ОписаниеПараметра = СтруктураОтбора.ПравоеЗначение;
			Иначе
				ИмяПараметра = ИмяСоздаваемойТаблицы +"_Параметр" + СчПараметров;
				ОписаниеПараметра = "&" + ИмяПараметра;
				Запрос.УстановитьПараметр(ИмяПараметра, СтруктураОтбора.ПравоеЗначение);
			КонецЕсли;
			ТекстОтбор = ТекстОтбор + "
			|	РегистрСведений." + СтруктураОтбора.ЛевоеЗначение + " " + СтруктураОтбора.ВидСравнения + " (" + ОписаниеПараметра + ") И";
			СчПараметров = СчПараметров + 1;
		КонецЦикла;	
		ТекстОтбор = Лев(ТекстОтбор, СтрДлина(ТекстОтбор) - 1);
		ТекстОтбор = ТекстОтбор + ")";
		ТекстЗапроса = ТекстЗапроса + ТекстОтбор;
	КонецЕсли;	
	
	ТекстОтборовСКД = "";
	Для каждого Измерение Из КоллекцииПолей.ИзмеренияФильтра Цикл
		ТекстОтборовСКД = ?(ПустаяСтрока(ТекстОтборовСКД), "", ТекстОтборовСКД + "," + Символы.ПС) + "	РегистрСведений." + Измерение + ".*";
	КонецЦикла;
	
	Если НЕ ПустаяСтрока(ТекстОтборовСКД) Тогда
		ТекстЗапроса = ТекстЗапроса + "
			|{ГДЕ
			|" + ТекстОтборовСКД + "}";
	КонецЕсли; 
	
	Если КоллекцииПолей.ВозвратныеРесурсы.Количество() > 0 Тогда
			
		ТекстЗапроса = ТекстЗапроса + "
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ
		|	РегистрСведений.ДействуетДо";
		
		Для Каждого Измерение Из КоллекцииПолей.Измерения Цикл
			ТекстЗапроса = ТекстЗапроса + ",
			|	РегистрСведений." + Измерение;
		КонецЦикла;
		Для Каждого Ресурс Из КоллекцииПолей.ВозвратныеРесурсы Цикл
			ТекстЗапроса = ТекстЗапроса + ",
			|	РегистрСведений." + Ресурс + "ПоОкончании";
		КонецЦикла;
		Для Каждого Ресурс Из КоллекцииПолей.Ресурсы Цикл
			ТекстЗапроса = ТекстЗапроса + ",
			|	РегистрСведений." + Ресурс;
		КонецЦикла;
		Для Каждого Реквизит Из КоллекцииПолей.Реквизиты Цикл
			ТекстЗапроса = ТекстЗапроса + ",
			|	РегистрСведений." + Реквизит;
		КонецЦикла;
		Для Каждого СтандартныйРеквизит Из КоллекцииПолей.СтандартныеРеквизиты Цикл
			ТекстЗапроса = ТекстЗапроса + ",
			|	РегистрСведений." + СтандартныйРеквизит;
		КонецЦикла;
		ТекстЗапроса = ТекстЗапроса + "
		|ИЗ
		|	РегистрСведений." + ИмяРегистра + " КАК РегистрСведений
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ " + ИмяТаблицыИзмерений + " КАК ИзмеренияДаты
		|		ПО (ИзмеренияДаты." + ИзмерениеФильтраДатаНачала + " = ДАТАВРЕМЯ(1, 1, 1) ИЛИ РегистрСведений.ДействуетДо >= ИзмеренияДаты." + ИзмерениеФильтраДатаНачала + ")
		|	И (ИзмеренияДаты." + ИзмерениеФильтраДатаОкончания + " = ДАТАВРЕМЯ(1, 1, 1) ИЛИ РегистрСведений.ДействуетДо <= ИзмеренияДаты." + ИзмерениеФильтраДатаОкончания + ")
		|	И РегистрСведений.ДействуетДо <> ДАТАВРЕМЯ(1, 1, 1) И ";

		Для Каждого Измерение Из КоллекцииПолей.ИзмеренияФильтра Цикл
			Если ВРег(Измерение) <> ВРег("ДатаНачала") И ВРег(Измерение) <> ВРег("ДатаОкончания") Тогда
				ИзмерениеФильтра = СоответствиеИзмеренийПолямТаблицы.Получить(Измерение);
				Если ИзмерениеФильтра = Неопределено Тогда
					ИзмерениеФильтра = Измерение;
				КонецЕсли;
				ТекстЗапроса = ТекстЗапроса + "(ИзмеренияДаты." + ИзмерениеФильтра + " = РегистрСведений." + Измерение + ") И ";
			КонецЕсли;	
		КонецЦикла;
	
		ТекстЗапроса = Лев(ТекстЗапроса, СтрДлина(ТекстЗапроса) - 3);
		
		ТекстЗапроса = ТекстЗапроса + "
		|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений." + ИмяРегистра + " КАК РегистрСведенийВспом
		|		ПО РегистрСведений.Период < РегистрСведенийВспом.Период
		|			И РегистрСведений.ДействуетДо >= РегистрСведенийВспом.Период";
		Для Каждого Измерение Из КоллекцииПолей.Измерения Цикл
			ТекстЗапроса = ТекстЗапроса + "
			|			И РегистрСведений." + Измерение + " = РегистрСведенийВспом." + Измерение;
		КонецЦикла;
		ТекстЗапроса = ТекстЗапроса + "
		|ГДЕ
		|	РегистрСведенийВспом.Период ЕСТЬ NULL";
		
		Если Отбор <> Неопределено И Отбор.Количество() > 0 Тогда
			СчПараметров = 1;
			ТекстОтбор = "
			|	И (";
			Для Каждого СтруктураОтбора Из Отбор Цикл
				Если ТипЗнч(СтруктураОтбора.ПравоеЗначение) = Тип("Строка") Тогда
					ОписаниеПараметра = СтруктураОтбора.ПравоеЗначение;
				Иначе
					ИмяПараметра = ИмяСоздаваемойТаблицы +"_Параметр" + СчПараметров;
					ОписаниеПараметра = "&" + ИмяПараметра;
					Запрос.УстановитьПараметр(ИмяПараметра, СтруктураОтбора.ПравоеЗначение);
				КонецЕсли;
				ТекстОтбор = ТекстОтбор + "
				|	РегистрСведений." + СтруктураОтбора.ЛевоеЗначение + " " + СтруктураОтбора.ВидСравнения + " (" + ОписаниеПараметра + ") И";
				СчПараметров = СчПараметров + 1;
			КонецЦикла;	
			ТекстОтбор = Лев(ТекстОтбор, СтрДлина(ТекстОтбор) - 1);
			ТекстОтбор = ТекстОтбор + ")";
			ТекстЗапроса = ТекстЗапроса + ТекстОтбор;
		КонецЕсли;	
		
	КонецЕсли;
	
	Если НЕ ТолькоРазрешенные Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ВЫБРАТЬ РАЗРЕШЕННЫЕ", "ВЫБРАТЬ");
	КонецЕсли;
	
	Запрос.Текст = ТекстЗапроса;
	
	Возврат Запрос;
	
КонецФункции


Функция ВыбираемыеИзмеренияРегистра(ВыбираемыеПоляРС, ДоступныеПоля)
	
	ВыбираемыеИзмерения = Новый Структура;
	
	Для Каждого Поле Из ВыбираемыеПоляРС Цикл
		Для Каждого ДоступноеПоле Из ДоступныеПоля Цикл
			Если Поле.Ключ = ДоступноеПоле.Имя И ДоступноеПоле.Роль.Измерение  Тогда
				ВыбираемыеИзмерения.Вставить(Поле.Ключ,Поле.Ключ);	
			КонецЕсли;	
		КонецЦикла;	
	КонецЦикла;	
		
	Возврат ВыбираемыеИзмерения;
	
КонецФункции	

Функция ДобавитьОтборПоРегистраторуРегистрНакопленияОбороты(ТекстЗапроса, ИмяПараметраРегистратор, ПоляСуммирования) Экспорт
	
	СхемаЗапроса = Новый СхемаЗапроса();
	СхемаЗапроса.УстановитьТекстЗапроса(ТекстЗапроса);
	
	Для Каждого ПакетЗапроса Из СхемаЗапроса.ПакетЗапросов Цикл
		Оператор = ПакетЗапроса.Операторы[0];
		Источник = Оператор.Источники[0];
		
		//Проверка, что это таблица оборотов
		Если Найти(ВРЕГ(Источник.Источник.ИмяТаблицы),".ОБОРОТЫ") = 0 Тогда
			Продолжить;
		КонецЕсли;	
		
		//Периодичность в оборотах
		Источник.Источник.Параметры[2].Выражение = Новый ВыражениеСхемыЗапроса("Регистратор");
		//Отбор по регистратору
		Оператор.Отбор.Добавить("Регистратор = &"+ИмяПараметраРегистратор);
		//Группировки
		Для Каждого ПолеСуммирования ИЗ ПоляСуммирования Цикл
			Для Каждого Колонка из ПакетЗапроса.Колонки Цикл
				Если Колонка.Псевдоним = ПолеСуммирования Тогда
					Индекс = ПакетЗапроса.Колонки.Индекс(Колонка);
					Поле = Оператор.ВыбираемыеПоля.Получить(Индекс);
					Если Найти(ВРЕГ(Строка(Поле)), "СУММА(") = 0 Тогда
						Оператор.ВыбираемыеПоля.Установить(Индекс,Новый ВыражениеСхемыЗапроса("СУММА("+Поле+")"));
						Прервать;
					КонецЕсли;	
				КонецЕсли;	
			КонецЦикла;
		КонецЦикла;		
	КонецЦикла;	
	
	Возврат СхемаЗапроса.ПолучитьТекстЗапроса();
	
КонецФункции	

Функция ЗапросВТСрезПоследнихНаВсеДаты(ИмяИтоговойВТ, ОсновнаяТаблица, ОтборыОТ, ВыбираемыеПоляОТ, ИмяПоляПериодОТ, ТаблицаРегистрСведений, ОтборыРС, ВыбираемыеПоляРС,  ИмяПоляПериодРС, ПоляСвязей, ВыбиратьРазрешенные = Истина, ВключитьОсновнуюТаблицу = Истина, ПредварительныйОтбор = Истина) Экспорт
	
	//Создание схемы запроса
	СхемаЗапроса = Новый СхемаЗапроса;
	
	ВТОсновнаяТаблицаСОтборами = ОсновнаяТаблица;
	
	Если ПредварительныйОтбор Тогда
		Запрос0 = СхемаЗапроса.ПакетЗапросов.Добавить();
		//Установка свойств запроса
		ВТОсновнаяТаблицаСОтборами = ЗарплатаКадры.УникальноеИмяВременнойТаблицы("ВТОсновнаяТаблицаСОтборами");
		Запрос0.ТаблицаДляПомещения = ВТОсновнаяТаблицаСОтборами;
		//Добавляем операторы выбора первого запроса пакета
		ОператорВыбора0 = Запрос0.Операторы[0];
		ОператорВыбора0.ВыбиратьРазличные = Истина;
		//Источники запроса
		ИсточникОсновнаяТаблица0 = ОператорВыбора0.Источники.Добавить(Тип("ОписаниеВременнойТаблицыСхемыЗапроса"),ОсновнаяТаблица);
		
		//Пля связи надо описать как доступные, добавить их в выбираемые поля, проиндексировать
		Для Каждого Поле ИЗ ПоляСвязей Цикл
			ИсточникОсновнаяТаблица0.Источник.ДоступныеПоля.Добавить(Поле.Ключ);
			ОператорВыбора0.ВыбираемыеПоля.Добавить(ОсновнаяТаблица+"."+Поле.Ключ);
			Запрос0.Индекс.Добавить(ОсновнаяТаблица+"."+Поле.Ключ);
		КонецЦикла;

		//Аналогично нужен период
		ИсточникОсновнаяТаблица0.Источник.ДоступныеПоля.Добавить(ИмяПоляПериодОТ);
		ОператорВыбора0.ВыбираемыеПоля.Добавить(ОсновнаяТаблица+"."+ИмяПоляПериодОТ);
		Запрос0.Индекс.Добавить(ОсновнаяТаблица+"."+ИмяПоляПериодОТ);
			
		//Отборы надо описать как доступные и включить в отборы
		Для Каждого Поле ИЗ ОтборыОТ Цикл
			ИсточникОсновнаяТаблица0.Источник.ДоступныеПоля.Добавить(Поле.Ключ);
			ОператорВыбора0.Отбор.Добавить(ОсновнаяТаблица+"."+Поле.Ключ+ " "+Поле.Значение);
		КонецЦикла;
		
		
		Запрос1 = СхемаЗапроса.ПакетЗапросов.Добавить();
		//Установка свойств запроса
		ВТТаблицаРегистрСведений = ЗарплатаКадры.УникальноеИмяВременнойТаблицы("ВТТаблицаРегистрСведений");
		Запрос1.ТаблицаДляПомещения = ВТТаблицаРегистрСведений;
		Запрос1.ВыбиратьРазрешенные = ВыбиратьРазрешенные;
		//Добавляем операторы выбора первого запроса пакета
		ОператорВыбора1 = Запрос1.Операторы[0];
		//Источники запроса
		ИсточникРегистрСведений1 = ОператорВыбора1.Источники.Добавить(ТаблицаРегистрСведений,"ТаблицаРегистрСведений");
		ИсточникОсновнаяТаблица1 = ОператорВыбора1.Источники.Добавить(Тип("ОписаниеВременнойТаблицыСхемыЗапроса"),ВТОсновнаяТаблицаСОтборами);
		
		ВыбираемыеИзмерения = ВыбираемыеИзмеренияРегистра(ВыбираемыеПоляРС,ИсточникРегистрСведений1.Источник.ДоступныеПоля);
		
		//Указываем выбираемые поля регистра сведений плюс обязательно период
		Для Каждого Поле ИЗ ВыбираемыеПоляРС Цикл
			ОператорВыбора1.ВыбираемыеПоля.Добавить("ТаблицаРегистрСведений."+Поле.Ключ);
		КонецЦикла;
		ОператорВыбора1.ВыбираемыеПоля.Добавить("ТаблицаРегистрСведений.Период");
		//Поля связи добавляем в выбираемые поля и индексируем
		Для Каждого Поле ИЗ ПоляСвязей Цикл
			ОператорВыбора1.ВыбираемыеПоля.Добавить("ТаблицаРегистрСведений."+Поле.Значение);
			Запрос1.Индекс.Добавить("ТаблицаРегистрСведений."+Поле.Значение);
		КонецЦикла;
		
		//Соединение
		Индекс = 0;
		Для Каждого Поле ИЗ ПоляСвязей Цикл
			ИсточникОсновнаяТаблица1.Источник.ДоступныеПоля.Добавить(Поле.Ключ);
			ИсточникРегистрСведений1.Соединения.Добавить(ВТОсновнаяТаблицаСОтборами,ВТОсновнаяТаблицаСОтборами+"."+Поле.Ключ+" = ТаблицаРегистрСведений."+Поле.Значение);
			ИсточникРегистрСведений1.Соединения[Индекс].ТипСоединения = ТипСоединенияСхемыЗапроса.Внутреннее;
			Индекс = Индекс+1
		КонецЦикла;	
	КонецЕсли;	
		
	Запрос2 = СхемаЗапроса.ПакетЗапросов.Добавить();
	//Установка свойств запроса
	ВТТаблицаМаксимальныеПериоды = ЗарплатаКадры.УникальноеИмяВременнойТаблицы("ВТТаблицаМаксимальныеПериоды");
	Запрос2.ТаблицаДляПомещения = ВТТаблицаМаксимальныеПериоды;
	Запрос2.ВыбиратьРазрешенные = ВыбиратьРазрешенные;
	//Добавляем операторы выбора первого запроса пакета
	ОператорВыбора2 = Запрос2.Операторы[0];
	//Источники запроса
	Если ПредварительныйОтбор Тогда
		ИсточникОсновнаяТаблица2 = ОператорВыбора2.Источники.Добавить(Тип("ОписаниеВременнойТаблицыСхемыЗапроса"),ВТОсновнаяТаблицаСОтборами);
		ИсточникРегистрСведений2 = ОператорВыбора2.Источники.Добавить(ВТТаблицаРегистрСведений,"ТаблицаРегистрСведений");
	Иначе
		ИсточникОсновнаяТаблица2 = ОператорВыбора2.Источники.Добавить(Тип("ОписаниеВременнойТаблицыСхемыЗапроса"),ВТОсновнаяТаблицаСОтборами);
		ИсточникРегистрСведений2 = ОператорВыбора2.Источники.Добавить(ТаблицаРегистрСведений,"ТаблицаРегистрСведений");
		ВыбираемыеИзмерения = ВыбираемыеИзмеренияРегистра(ВыбираемыеПоляРС,ИсточникРегистрСведений2.Источник.ДоступныеПоля);
	КонецЕсли;	
		
	//Добавляем поле период таблицы регистра сведений
	ОператорВыбора2.ВыбираемыеПоля.Добавить("МАКСИМУМ(ТаблицаРегистрСведений."+ИмяПоляПериодРС+")");
	Запрос2.Колонки[0].Псевдоним = "МаксимальныйПериод";
		
	//Соединение
	Для Каждого Поле ИЗ ПоляСвязей Цикл
		ИсточникОсновнаяТаблица2.Источник.ДоступныеПоля.Добавить(Поле.Ключ);
		ОператорВыбора2.ВыбираемыеПоля.Добавить(ВТОсновнаяТаблицаСОтборами+"."+Поле.Ключ);
		ИсточникОсновнаяТаблица2.Соединения.Добавить("ТаблицаРегистрСведений",ВТОсновнаяТаблицаСОтборами+"."+Поле.Ключ+" = ТаблицаРегистрСведений."+Поле.Значение);
	КонецЦикла;	
	//Дополнительно условие по периоду
	ИсточникОсновнаяТаблица2.Источник.ДоступныеПоля.Добавить(ИмяПоляПериодОТ);
	ОператорВыбора2.ВыбираемыеПоля.Добавить(ВТОсновнаяТаблицаСОтборами+"."+ИмяПоляПериодОТ);
	ИсточникОсновнаяТаблица2.Соединения.Добавить("ТаблицаРегистрСведений",ВТОсновнаяТаблицаСОтборами+"."+ИмяПоляПериодОТ+" >= ТаблицаРегистрСведений."+ИмяПоляПериодРС);
	
	//Поля связи индексируем
	Для Каждого Поле ИЗ ПоляСвязей Цикл
		Запрос2.Индекс.Добавить(ВТОсновнаяТаблицаСОтборами+"."+Поле.Ключ);
	КонецЦикла;
	Запрос2.Индекс.Добавить(ВТОсновнаяТаблицаСОтборами+"."+ИмяПоляПериодОТ);
	
	Для Каждого Поле ИЗ ВыбираемыеИзмерения Цикл
		ОператорВыбора2.ВыбираемыеПоля.Добавить("ТаблицаРегистрСведений."+Поле.Ключ);
		Запрос2.Индекс.Добавить("ТаблицаРегистрСведений."+Поле.Ключ);
	КонецЦикла;	
	
	Запрос3 = СхемаЗапроса.ПакетЗапросов.Добавить();
	//Установка свойств запроса
	Запрос3.ТаблицаДляПомещения = ИмяИтоговойВТ;
	//Добавляем операторы выбора первого запроса пакета
	ОператорВыбора3 = Запрос3.Операторы[0];
	Индекс = 0;
	//Источники запроса
	Если ПредварительныйОтбор Тогда
		ИсточникТаблицаМаксимум3 = ОператорВыбора3.Источники.Добавить(ВТТаблицаМаксимальныеПериоды,"ТаблицаМаксимальныеПериоды");
		ИсточникРегистрСведений3 = ОператорВыбора3.Источники.Добавить(ВТТаблицаРегистрСведений,"ТаблицаРегистрСведений");
	Иначе
		ИсточникТаблицаМаксимум3 = ОператорВыбора3.Источники.Добавить(ВТТаблицаМаксимальныеПериоды,"ТаблицаМаксимальныеПериоды");
		ИсточникРегистрСведений3 = ОператорВыбора3.Источники.Добавить(ТаблицаРегистрСведений,"ТаблицаРегистрСведений");
	КонецЕсли;	
	//Если есть дополнительные выбираемые поля из основной таблицы надо сделать соединение с основнойтаблицей
	Если ВключитьОсновнуюТаблицу Тогда
		ИсточникОсновнаяТаблица3 = ОператорВыбора3.Источники.Добавить(Тип("ОписаниеВременнойТаблицыСхемыЗапроса"),ОсновнаяТаблица);
		//Указываем доступные и выбираемые поля основной таблицы
		Для Каждого Поле ИЗ ВыбираемыеПоляОТ Цикл
			ИсточникОсновнаяТаблица3.Источник.ДоступныеПоля.Добавить(Поле.Ключ);
			ОператорВыбора3.ВыбираемыеПоля.Добавить(ОсновнаяТаблица+"."+Поле.Ключ);
			Запрос3.Колонки[Индекс].Псевдоним = Поле.Значение;
			Индекс = Индекс+1;
		КонецЦикла;
		//Отборы надо описать как доступные и включить в отборы
		Для Каждого Поле ИЗ ОтборыОТ Цикл
			ИсточникОсновнаяТаблица3.Источник.ДоступныеПоля.Добавить(Поле.Ключ);
			ОператорВыбора3.Отбор.Добавить(ОсновнаяТаблица+"."+Поле.Ключ+ " "+Поле.Значение);
		КонецЦикла;
		//Указываем поля связи как доступные поля основной таблицы и формируем связи
		Для Каждого Поле ИЗ ПоляСвязей Цикл
			ИсточникОсновнаяТаблица3.Источник.ДоступныеПоля.Добавить(Поле.Ключ);
			ИсточникОсновнаяТаблица3.Соединения.Добавить("ТаблицаМаксимальныеПериоды","ТаблицаМаксимальныеПериоды."+Поле.Ключ+" = "+ОсновнаяТаблица+"."+Поле.Ключ);
		КонецЦикла;
		//Дополнительно период
		ИсточникОсновнаяТаблица3.Источник.ДоступныеПоля.Добавить(ИмяПоляПериодОТ);
		ИсточникОсновнаяТаблица3.Соединения.Добавить("ТаблицаМаксимальныеПериоды","ТаблицаМаксимальныеПериоды."+ИмяПоляПериодОТ+" = "+ОсновнаяТаблица+"."+ИмяПоляПериодОТ);
	КонецЕсли;	
	
	//Указываем поля связи как выбираемые поля таблицы максимальных периодов
	Для Каждого Поле ИЗ ПоляСвязей Цикл
		ОператорВыбора3.ВыбираемыеПоля.Добавить("ТаблицаМаксимальныеПериоды."+Поле.Ключ);
		Запрос3.Индекс.Добавить("ТаблицаМаксимальныеПериоды."+Поле.Ключ);
		Индекс = Индекс+1;
	КонецЦикла;
	//Аналогично для периода
	ОператорВыбора3.ВыбираемыеПоля.Добавить("ТаблицаМаксимальныеПериоды."+ИмяПоляПериодОТ);
	Запрос3.Индекс.Добавить("ТаблицаМаксимальныеПериоды."+ИмяПоляПериодОТ);
	Индекс = Индекс+1;
	//Указываем выбираемые поля регистра сведений
	Для Каждого Поле ИЗ ВыбираемыеПоляРС Цикл
		ОператорВыбора3.ВыбираемыеПоля.Добавить("ТаблицаРегистрСведений."+Поле.Ключ);
		Запрос3.Колонки[Индекс].Псевдоним = Поле.Значение;
		Индекс = Индекс+1;
	КонецЦикла;
	
	//Соединения
	Для Каждого Поле ИЗ ПоляСвязей Цикл
		ИсточникТаблицаМаксимум3.Соединения.Добавить("ТаблицаРегистрСведений","ТаблицаМаксимальныеПериоды."+Поле.Ключ+" = ТаблицаРегистрСведений."+Поле.Значение);
	КонецЦикла;
	//Дополнительно условие по периоду
	ИсточникТаблицаМаксимум3.Соединения.Добавить("ТаблицаРегистрСведений","ТаблицаМаксимальныеПериоды.МаксимальныйПериод = ТаблицаРегистрСведений."+ИмяПоляПериодРС);
	
	//Возможные отборы
	Для Каждого Поле ИЗ ОтборыРС Цикл
		ОператорВыбора3.Отбор.Добавить("ТаблицаРегистрСведений."+Поле.Ключ+ " "+Поле.Значение);
	КонецЦикла;
	Если ВключитьОсновнуюТаблицу Тогда
		Для Каждого Поле ИЗ ОтборыОТ Цикл
			ИсточникОсновнаяТаблица3.Источник.ДоступныеПоля.Добавить(Поле.Ключ);
			ОператорВыбора3.Отбор.Добавить(ОсновнаяТаблица+"."+Поле.Ключ+ " "+Поле.Значение);
		КонецЦикла;
	КонецЕсли;	
		
	Запрос3.Индекс.Добавить("ТаблицаМаксимальныеПериоды."+ИмяПоляПериодОТ);
	
	Для Каждого Поле ИЗ ВыбираемыеИзмерения Цикл
		ИсточникТаблицаМаксимум3.Соединения.Добавить("ТаблицаРегистрСведений","ТаблицаМаксимальныеПериоды."+Поле.Ключ+" = ТаблицаРегистрСведений."+Поле.Ключ);
	КонецЦикла;
		
    Если ПредварительныйОтбор Тогда
		ЗапросУничтоженияВТ1 = СхемаЗапроса.ПакетЗапросов.Добавить(Тип("ЗапросУничтоженияТаблицыСхемыЗапроса"));
		ЗапросУничтоженияВТ1.ИмяТаблицы = ВТОсновнаяТаблицаСОтборами;
		ЗапросУничтоженияВТ2 = СхемаЗапроса.ПакетЗапросов.Добавить(Тип("ЗапросУничтоженияТаблицыСхемыЗапроса"));
		ЗапросУничтоженияВТ2.ИмяТаблицы = ВТТаблицаРегистрСведений;
	КонецЕсли;	
	ЗапросУничтоженияВТ3 = СхемаЗапроса.ПакетЗапросов.Добавить(Тип("ЗапросУничтоженияТаблицыСхемыЗапроса"));
	ЗапросУничтоженияВТ3.ИмяТаблицы = ВТТаблицаМаксимальныеПериоды;
	
	Возврат СхемаЗапроса.ПолучитьТекстЗапроса();
	
КонецФункции	

////////////////////////////////////////////////////////////////////////////////
// Универсальные процедуры и функции

// Заполняет данные выбора справочника при вводе по строке и автоподборе в справочнике
// Предназначена для вызова из обработчика ОбработкаПолученияДанныхВыбора в том случае, когда 
// обработка получения данных выбора выполняется "особым образом" (с выполнением особенного запроса)
//
// Параметры:
//		ДанныеВыбора
//		МетаданныеОбъекта - метаданные справочника для которого переопределяется обработка получения данных выбора
//		Отбор - параметры отбора, переданные в ОбработкаПолученияДанныхВыбора 
//		Запрос - Запрос с предустановленными параметрами текст запроса, который необходимо выполнять
//			ВНИМАНИЕ! Запрос обязательно должен быть построен по схеме:
//				ВЫБРАТЬ * 
//				ИЗ 
//					... КАК <Псевдоним>
//				...
//			Текст запроса дополняется необходимыми функциями
//		ПсевдонимТаблицы - псевдоним основной таблицы в тексте переданного запроса
//
Процедура ЗаполнитьДанныеВыбораСправочника(ДанныеВыбора, МетаданныеОбъекта, Отбор, Запрос, ПсевдонимТаблицы) Экспорт
	
	ЗапросТекст = Запрос.Текст;
	
	ЗапросТекст = СтрЗаменить(ЗапросТекст, " *", 
		" ПЕРВЫЕ 51
		|	" + ПсевдонимТаблицы + ".Ссылка,
		|	" + ПсевдонимТаблицы + ".ПометкаУдаления,
		|	" + ПсевдонимТаблицы + ".Код,
		|	" + ПсевдонимТаблицы + ".Наименование");
		
	Если МетаданныеОбъекта.ДлинаКода = 0 Тогда
		ЗапросТекст = СтрЗаменить(ЗапросТекст, ",
		|	" + ПсевдонимТаблицы + ".Код", "");
	КонецЕсли;
	Если МетаданныеОбъекта.ДлинаНаименования = 0 Тогда
		ЗапросТекст = СтрЗаменить(ЗапросТекст, ",
		|	" + ПсевдонимТаблицы + ".Наименование", "");
	КонецЕсли;
	
	ЗапросТекст = ЗапросТекст + "
		|
		|УПОРЯДОЧИТЬ ПО
		|	Наименование";
	
	КоличествоЭлементов = 51;
	ДанныеВыбора = Новый СписокЗначений;
	Если МетаданныеОбъекта.ОсновноеПредставление = Метаданные.СвойстваОбъектов.ОсновноеПредставлениеСправочника.ВВидеНаименования И МетаданныеОбъекта.ДлинаНаименования > 0 Тогда 
		ПолеОсновногоПредставления = "Наименование";
		Если МетаданныеОбъекта.ДлинаКода > 0 Тогда
			ПолеДопПредставления = "Код";
		Иначе
			ПолеДопПредставления = "";
		КонецЕсли;
	ИначеЕсли МетаданныеОбъекта.ДлинаКода > 0 Тогда
		ПолеОсновногоПредставления = "Код";
		Если МетаданныеОбъекта.ДлинаНаименования > 0 Тогда
			ПолеДопПредставления = "Наименование";
		Иначе
			ПолеДопПредставления = "";
		КонецЕсли;
	Иначе
		ПолеОсновногоПредставления = "";
		ПолеДопПредставления = "";
	КонецЕсли;
	
	ДополнительноеУсловие = "";
	
	Для Каждого ЭлементОтбора Из Отбор Цикл
		Реквизит = МетаданныеОбъекта.Реквизиты.Найти(ЭлементОтбора.Ключ);
		Если Реквизит <> НеОпределено Тогда
			Если ТипЗнч(ЭлементОтбора.Значение) = Тип("Массив") Тогда
				ДополнительноеУсловие = "
				|	И " + ПсевдонимТаблицы + "." + ЭлементОтбора.Ключ + " В (&" + ЭлементОтбора.Ключ + ")";
			Иначе
				ДополнительноеУсловие = "
				|	И " + ПсевдонимТаблицы + "." + ЭлементОтбора.Ключ + " = &" + ЭлементОтбора.Ключ;
			КонецЕсли;	
			Запрос.УстановитьПараметр(ЭлементОтбора.Ключ, ЭлементОтбора.Значение);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого Поле Из МетаданныеОбъекта.ВводПоСтроке Цикл
		ТекстЗапроса = ЗапросТекст;
	
		ИмяПоля = Поле.Имя;
		
		// установим в запросе условие
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "И &ДополнительноеУсловие", ДополнительноеУсловие + "
		|И " + ПсевдонимТаблицы + "." + ИмяПоля + " ПОДОБНО &СтрокаПоиска");
		
		// допишем в поля выборки поле поиска
		Если ИмяПоля <> ПолеОсновногоПредставления И ИмяПоля <> ПолеДопПредставления Тогда
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, " ПЕРВЫЕ 51", " ПЕРВЫЕ 51
				|	" + ПсевдонимТаблицы + "." + ИмяПоля + " КАК ПолеПоиска,");
		КонецЕсли;
		
		// установим число выбираемых элементов
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, " ПЕРВЫЕ 51", " ПЕРВЫЕ " + Строка(КоличествоЭлементов));
		
		Запрос.Текст = ТекстЗапроса;
		Выборка = Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			Если ПолеОсновногоПредставления = ИмяПоля Тогда
				Если ПустаяСтрока(ПолеДопПредставления) Тогда
					Представление = СокрЛП(Выборка[ПолеОсновногоПредставления]);
				Иначе
					Представление = СокрЛП(Выборка[ПолеОсновногоПредставления]) + " (" + СокрЛП(Выборка[ПолеДопПредставления]) + ")";
				КонецЕсли;
			ИначеЕсли ПолеДопПредставления = ИмяПоля Тогда
				Представление = Выборка[ПолеДопПредставления] + " (" + СокрЛП(Выборка[ПолеОсновногоПредставления]) + ")";
			Иначе
				Представление = Выборка.ПолеПоиска + " (" + СокрЛП(Выборка[ПолеОсновногоПредставления]) + ")";
			КонецЕсли;
			ДанныеВыбора.Добавить(Выборка.Ссылка, Представление);
			
		КонецЦикла;
		КоличествоЭлементов = КоличествоЭлементов - Выборка.Количество();
		Если КоличествоЭлементов <= 0 Тогда
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	ДанныеВыбора.СортироватьПоПредставлению();

КонецПроцедуры

// Готовит данные выбора для справочников - классификаторов, упорядочивает по коду
//
Процедура ПодготовитьДанныеВыбораКлассификаторовСПорядкомКодов(ДанныеВыбора, Параметры, СтандартнаяОбработка, ПолноеИмяОбъектаМетаданных) Экспорт
	
	Запрос = Новый Запрос;
	
	ДанныеВыбора = Новый СписокЗначений;
	
	Запрос.Текст =
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 51
		|	СписокСправочника.Ссылка,
		|	СписокСправочника.Код КАК Код,
		|	СписокСправочника.Наименование,
		|	ИСТИНА КАК НайденПоКоду
		|ИЗ
		|	&СписокСправочника КАК СписокСправочника
		|ГДЕ &ТекстУсловийОтбора
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ
		|	СписокСправочника.Ссылка,
		|	СписокСправочника.Код,
		|	СписокСправочника.Наименование,
		|	ЛОЖЬ
		|ИЗ
		|	&СписокСправочника КАК СписокСправочника
		|ГДЕ &ТекстУсловийОтбора
		|
		|УПОРЯДОЧИТЬ ПО
		|	Код";
		
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&СписокСправочника", ПолноеИмяОбъектаМетаданных);
	
	ТекстУсловийОтбора = "";
	Если НЕ ПустаяСтрока(Параметры.СтрокаПоиска) Тогда
		ТекстУсловийОтбора = "СписокСправочника.Код ПОДОБНО &СтрокаПоиска";
		Запрос.УстановитьПараметр("СтрокаПоиска", Параметры.СтрокаПоиска + "%");
	КонецЕсли; 
	
	УстановитьОтборВЗапросеПоПараметрам(Запрос, ТекстУсловийОтбора, Параметры);
		
	Выборка = Запрос.Выполнить().Выбрать();
		
	Пока Выборка.Следующий() Цикл
		
		Если ДанныеВыбора.НайтиПоЗначению(Выборка.Ссылка) = Неопределено Тогда
			
			Если Выборка.НайденПоКоду Тогда
				Представление = СокрЛП(Выборка.Код) + " (" + Выборка.Наименование + ")";
			Иначе
				Представление = Выборка.Наименование + " (" + СокрЛП(Выборка.Код) + ")";
			КонецЕсли;
			
			ДанныеВыбора.Добавить(Выборка.Ссылка, Представление);
			
		КонецЕсли; 
		
	КонецЦикла;
		
	СтандартнаяОбработка = Ложь;
	
КонецПроцедуры

Процедура ПодготовитьДанныеВыбораКлассификаторовСПорядкомРеквизитаДопУпорядочивания(ДанныеВыбора, Параметры, СтандартнаяОбработка, ПолноеИмяОбъектаМетаданных) Экспорт
	
	Запрос = Новый Запрос;
	
	ДанныеВыбора = Новый СписокЗначений;
	
	Запрос.Текст =
		"ВЫБРАТЬ
		|	СписокСправочника.Ссылка
		|ИЗ
		|	&СписокСправочника КАК СписокСправочника
		|ГДЕ &ТекстУсловийОтбора
		|
		|УПОРЯДОЧИТЬ ПО
		|	СписокСправочника.РеквизитДопУпорядочивания";
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&СписокСправочника", ПолноеИмяОбъектаМетаданных);
	
	ТекстУсловийОтбора = "";
	Если НЕ ПустаяСтрока(Параметры.СтрокаПоиска) Тогда
		ТекстУсловийОтбора = "СписокСправочника.Наименование ПОДОБНО &СтрокаПоиска";
		Запрос.УстановитьПараметр("СтрокаПоиска", Параметры.СтрокаПоиска + "%");
	КонецЕсли; 
	
	УстановитьОтборВЗапросеПоПараметрам(Запрос, ТекстУсловийОтбора, Параметры);
		
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		ДанныеВыбора.Добавить(Выборка.Ссылка);
	КонецЦикла;
	
КонецПроцедуры

// Создает структуру наборов записей, имитирующую коллекцию движений регистратора.
// Может применяться для временного использования методов, формирующих движения, 
// когда регистратор пока не записан.
//
// Параметры
//	МетаданныеРегистратора
//
// Возвращаемое значение - структура, где ключ имя набора, 
//		значение - набор записей с отбором по временной ссылке
//
Функция НаборыЗаписейРегистратора(МетаданныеРегистратора, ВременнаяСсылка = Неопределено, ПропуститьПроверкуЗапретаИзменения = Истина) Экспорт
	
	НаборыЗаписей = Новый Структура;
	
	Если ВременнаяСсылка = Неопределено Тогда
		ВременнаяСсылка = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(МетаданныеРегистратора.ПолноеИмя()).ПолучитьСсылку();
	КонецЕсли;
	
	Для Каждого МетаданныеНабора Из МетаданныеРегистратора.Движения Цикл
		Менеджер = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(МетаданныеНабора.ПолноеИмя());
		НаборЗаписей = Менеджер.СоздатьНаборЗаписей();
		НаборЗаписей.Отбор.Регистратор.Установить(ВременнаяСсылка);
		НаборЗаписей.Записывать = Истина;
		Если ПропуститьПроверкуЗапретаИзменения Тогда
			НаборЗаписей.ДополнительныеСвойства.Вставить("ПропуститьПроверкуЗапретаИзменения");
		КонецЕсли;
		НаборыЗаписей.Вставить(МетаданныеНабора.Имя, НаборЗаписей);
	КонецЦикла;
	
	Возврат НаборыЗаписей;
	
КонецФункции

#Область Отладка

Функция ВыполнитьКод(ТекстКода, П1 = Неопределено, П2 = Неопределено, П3 = Неопределено, П4 = Неопределено, П5 = Неопределено) Экспорт
	

    Попытка
        Выполнить(ТекстКода);
    Исключение
        Возврат Ложь;
	КонецПопытки;
    
    Возврат Истина;
    
КонецФункции

Функция ВыполнитьКодОтладки(ИмяФайла = "", П1 = Неопределено, П2 = Неопределено, П3 = Неопределено, П4 = Неопределено, П5 = Неопределено) Экспорт
	
    РезультатКодаОтладки = Неопределено;
	
    Если НЕ ЗначениеЗаполнено(ИмяФайла) Тогда 
		ИмяФайла = "d:\отладка.txt";	
	КонецЕсли;
	Текст = Новый ЧтениеТекста(ИмяФайла, КодировкаТекста.ANSI);
	ТекстКода = Текст.Прочитать();
	
    Попытка
        Выполнить(ТекстКода);
    Исключение
        Возврат ИнформацияОбОшибке();
	КонецПопытки;
	
    Возврат РезультатКодаОтладки;
    
КонецФункции

Функция ПоказатьВТ(ИсходныйЗапрос, ИмяВременнойТаблицы = "", Упорядочивание = "", БыстрыйОтбор = "", БыстрыйОтборИндексСтроки = 0) Экспорт
	
	
	Запрос = Новый Запрос;
	Если ТипЗнч(ИсходныйЗапрос) = Тип("Запрос") Тогда
		Запрос.МенеджерВременныхТаблиц = ИсходныйЗапрос.МенеджерВременныхТаблиц;
	ИначеЕсли ТипЗнч(ИсходныйЗапрос) = Тип("МенеджерВременныхТаблиц") Тогда
		Запрос.МенеджерВременныхТаблиц = ИсходныйЗапрос;
	КонецЕсли;
	
	Если ИмяВременнойТаблицы <> "" Тогда
		
		//Одна указанная таблица
		Запрос.Текст = "ВЫБРАТЬ
		|	*
		|ИЗ
		|	"+ИмяВременнойТаблицы+"
		|
		|"+?(Упорядочивание = "", "", "УПОРЯДОЧИТЬ ПО "+Упорядочивание)+"
		|";
		
		РезультатЗапроса = Запрос.Выполнить();
		ТаблицаРезультат = РезультатЗапроса.Выгрузить();
		
		Если ЗначениеЗаполнено(БыстрыйОтбор) Тогда
			СтрокаДляОтбора = ТаблицаРезультат[БыстрыйОтборИндексСтроки];
			ЗначениеОтбора  = СтрокаДляОтбора[БыстрыйОтбор];
			СтруктураОтбора = Новый Структура(БыстрыйОтбор,ЗначениеОтбора);
			
			НайденныеСтроки = ТаблицаРезультат.НайтиСтроки(СтруктураОтбора);
			
			ТаблицаРезультат = ТаблицаРезультат.Скопировать(НайденныеСтроки);
			
		КонецЕсли;	
				
	    Возврат ТаблицаРезультат;
		
	ИначеЕсли ТипЗнч(ИсходныйЗапрос) = Тип("Запрос") Тогда
		//Получим список значений из запроса
		СписокТаблиц = Новый Структура;
		
		ТекстЗапроса = ИсходныйЗапрос.Текст;
		Для Счетчик = 1 По СтрЧислоСтрок(ТекстЗапроса) Цикл
			ТекСтрока = СтрПолучитьСтроку(ТекстЗапроса, Счетчик);
			Позиция = Найти(ТекСтрока,"ПОМЕСТИТЬ");
			Если Позиция > 0 Тогда
				ТекСтрока = СтрЗаменить(ТекСтрока,"ПОМЕСТИТЬ","");
				Запрос.Текст = "ВЫБРАТЬ
				|	*
				|ИЗ
				|	"+СокрЛП(ТекСтрока)+"
				|";
				РезультатЗапроса = Запрос.Выполнить();
				СписокТаблиц.Вставить(СокрЛП(ТекСтрока),РезультатЗапроса.Выгрузить());
			КонецЕсли;
		КонецЦикла;
		
		Возврат СписокТаблиц;
		
	ИначеЕсли ТипЗнч(ИсходныйЗапрос) = Тип("МенеджерВременныхТаблиц") Тогда
		//Получим список значений из менеджера
		СписокТаблиц = Новый Структура;
		
		Для Каждого ВТ ИЗ ИсходныйЗапрос.Таблицы Цикл
			
			СписокТаблиц.Вставить(СокрЛП(ВТ.ПолноеИмя),ВТ.ПолучитьДанные().Выгрузить());	
			
		КонецЦикла;
		
		Возврат СписокТаблиц;
		
	Иначе
		
		Возврат Неопределено;
		
	КонецЕсли;	
	
КонецФункции // ПоказатьВременнуюТаблицу()

Функция ВыполнитьЗапрос(ИсходныйЗапрос =  Неопределено, ТекстЗапроса = "", ИмяФайла  = "", СКонтекстом = Ложь) Экспорт
	
	
	Запрос = Новый Запрос;
	СтруктураКонтекст = Новый Структура();
	
	Если ТипЗнч(ИсходныйЗапрос) = Тип("Запрос") Тогда
		Запрос.МенеджерВременныхТаблиц = ИсходныйЗапрос.МенеджерВременныхТаблиц;
		СписокТаблиц = Новый Структура;
		Если ИсходныйЗапрос.МенеджерВременныхТаблиц <> Неопределено Тогда 
			Для Каждого ВТ ИЗ ИсходныйЗапрос.МенеджерВременныхТаблиц.Таблицы Цикл
				СписокТаблиц.Вставить(СокрЛП(ВТ.ПолноеИмя),ВТ.ПолучитьДанные().Выгрузить());	
			КонецЦикла;
		КонецЕсли;	
		СтруктураКонтекст.Вставить("Таблицы", СписокТаблиц);
		Для Каждого Параметр ИЗ ИсходныйЗапрос.Параметры Цикл
			Запрос.УстановитьПараметр(Параметр.Ключ, Параметр.Значение);
		КонецЦикла;
		СтруктураКонтекст.Вставить("Параметры", ИсходныйЗапрос.Параметры);
	Иначе
		Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц();
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ТекстЗапроса) Тогда
		//Запрос по тексту
		Запрос.Текст = СтрЗаменить(ТекстЗапроса,"|"," ");
		СтруктураКонтекст.Вставить("Текст", Запрос.Текст);
		Попытка
			РезультатЗапроса = Запрос.Выполнить();
			Результат = РезультатЗапроса.Выгрузить();
			Если НЕ СКонтекстом Тогда
				Возврат Результат;
			Иначе
				СтруктураКонтекст.Вставить("Результат", Результат);
				Возврат СтруктураКонтекст;
			КонецЕсли;
		Исключение
			Если НЕ СКонтекстом Тогда
				Возврат ИнформацияОбОшибке();
			Иначе
				СтруктураКонтекст.Вставить("Результат", ИнформацияОбОшибке());
				Возврат СтруктураКонтекст;
			КонецЕсли;
		КонецПопытки;	
	Иначе
		//из файла
		Если НЕ ЗначениеЗаполнено(ИмяФайла) Тогда 
			ИмяФайла = "d:\запрос.txt";	
		КонецЕсли;	
		Текст = Новый ЧтениеТекста(ИмяФайла, КодировкаТекста.ANSI);
		ТекстЗапроса = Текст.Прочитать();
		Запрос.Текст = СтрЗаменить(ТекстЗапроса,"|"," ");
		СтруктураКонтекст.Вставить("Текст", Запрос.Текст);
		Попытка
			РезультатЗапроса = Запрос.Выполнить();
			Результат = РезультатЗапроса.Выгрузить();
			Если НЕ СКонтекстом Тогда
				Возврат Результат;
			Иначе
				СтруктураКонтекст.Вставить("Результат", Результат);
				Возврат СтруктураКонтекст;
			КонецЕсли;
		Исключение
			Если НЕ СКонтекстом Тогда
				Возврат ИнформацияОбОшибке();
			Иначе
				СтруктураКонтекст.Вставить("Результат", ИнформацияОбОшибке());
				Возврат СтруктураКонтекст;
			КонецЕсли;
		КонецПопытки;	
		
	КонецЕсли;	
	
	Возврат Неопределено;
	
КонецФункции // ПоказатьВременнуюТаблицу()

Функция УстановитьПараметрЗапроса(ИсходныйЗапрос, ИмяПараметра, ЗначениеПараметра) Экспорт
	

    Попытка
        ИсходныйЗапрос.УстановитьПараметр(ИмяПараметра,ЗначениеПараметра);
    Исключение
        Возврат Ложь;
	КонецПопытки;
    
    Возврат Истина;
	
КонецФункции

#КонецОбласти

///////////////////////////////////////////////////////////////////////////////
// Формирование печатных форм

// Выводит строки по данным заполнения в результирующий табличный документ, в количестве не превышающем "ОграничениеСтрок"
// Остальные строки выводятся в дополнительные страницы, которые помещаются в массив "ОбластиДополнительныхСтрок"
//
// Параметры:
//		ТабличныйДокумент - результирующий табличный документ
//		ДанныеЗаполнения - коллекция с данными для заполнения строк, коллекция доступна для обхода циклом Для Каждого … Из … Цикл
//		ОграничениеСтрок - число, количество строк, размещаемых в основной области
//		ОбластиДополнительныхСтрок - массив областей с дополнительными строками
//		ОбластьШапка - область табличного документа для шапки
//		ОбластьСтрока - область табличного документа для строки
//		МассивОбластейЗаголовок - массив областей табличного документа для заголовка, выводятся по порядку
//		МассивОбластейПодвал - массив областей табличного документа для подвала, выводятся по порядку
//		ВыводитьСтрокиНаВсюСтраницу - Если Истина, то до конца дополнительной страницы будут выведены пустые строки
//
Процедура СформироватьОбластьТабличногоДокументаСОграниченнымНаборомСтрок(ТабличныйДокумент, ДанныеЗаполнения, ОграничениеСтрок,
	ОбластиДополнительныхСтрок, ОбластьШапка, ОбластьСтрока, МассивОбластейЗаголовок = Неопределено, МассивОбластейПодвал = Неопределено,
	ВыводитьСтрокиНаВсюСтраницу = Ложь) Экспорт
	
	КоличествоВыведенныхСтрок = 0;
	ДополнительнаяСтраница = Новый ТабличныйДокумент;
	
	Для каждого СтрокаДанныхЗаполнения Из ДанныеЗаполнения Цикл
		
		КоличествоВыведенныхСтрок = КоличествоВыведенныхСтрок + 1;
		
		// Если выводимая строка помещается в основной табличный документ
		Если КоличествоВыведенныхСтрок <= ОграничениеСтрок Тогда
			ОбластьСтрока.Параметры.Заполнить(СтрокаДанныхЗаполнения);
			ТабличныйДокумент.Вывести(ОбластьСтрока);
		КонецЕсли;
		
		// Если выводимая строка не помещается в основной табличный документ, то нужно вывести
		// заголовок и шапку для дополнительной страницы
		Если КоличествоВыведенныхСтрок = ОграничениеСтрок + 1 Тогда
			
			// Если задан заголовок для дополнительной страницы - выведем его
			Если МассивОбластейЗаголовок <> Неопределено Тогда
				СтруктураПараметров = Новый Структура("НомерПриложения", ОбластиДополнительныхСтрок.Количество() + 1);
				Для каждого ОбластьЗаголовок Из МассивОбластейЗаголовок Цикл
					ОбластьЗаголовок.Параметры.Заполнить(СтруктураПараметров);
					ДополнительнаяСтраница.Вывести(ОбластьЗаголовок);
				КонецЦикла;
			КонецЕсли;
			
			// Выводим шапку дополнительной страницы
			ДополнительнаяСтраница.Вывести(ОбластьШапка);
			
			// Повторяем шапку на каждой странице при печати
			ДополнительнаяСтраница.ПовторятьПриПечатиСтроки = ОбластьШапка;
			
		КонецЕсли;
		
		// Все строки, которые не поместились в основной табличный документ выводим в дополнительную страницу
		Если КоличествоВыведенныхСтрок > ОграничениеСтрок Тогда
			ОбластьСтрока.Параметры.Заполнить(СтрокаДанныхЗаполнения);
			ДополнительнаяСтраница.Вывести(ОбластьСтрока);
		КонецЕсли;
		
	КонецЦикла;
	
	// Если создавали дополнительную страницу нужно вывести подвал и надпись о продолжении таблицы
	Если КоличествоВыведенныхСтрок > ОграничениеСтрок Тогда
		
		// Выводим пустые строки до конца дополнительной страницы
		Если ВыводитьСтрокиНаВсюСтраницу Тогда
			
			Для ПараметрОбласти = 0 По ОбластьСтрока.Параметры.Количество() -1 Цикл
				ОбластьСтрока.Параметры[ПараметрОбласти] = Неопределено;
			КонецЦикла;
			
			ВыводимыеОбласти = Новый Массив();
			ВыводимыеОбласти.Добавить(ОбластьСтрока);
			Если МассивОбластейПодвал <> Неопределено Тогда
				Для каждого ОбластьПодвал Из МассивОбластейПодвал Цикл
					ВыводимыеОбласти.Добавить(ОбластьПодвал);
				КонецЦикла;
			КонецЕсли;
			
			Пока ОбщегоНазначения.ПроверитьВыводТабличногоДокумента(ДополнительнаяСтраница, ВыводимыеОбласти, Ложь) Цикл
				ДополнительнаяСтраница.Вывести(ОбластьСтрока);
			КонецЦикла;
			
		КонецЕсли;
		
		// Если задан подвал для дополнительной страницы - выведем его
		Если МассивОбластейПодвал <> Неопределено Тогда
			Для каждого ОбластьПодвал Из МассивОбластейПодвал Цикл
				ДополнительнаяСтраница.Вывести(ОбластьПодвал);
			КонецЦикла;
		КонецЕсли;
		
		// Поместим созданную страницу в массив
		ОбластиДополнительныхСтрок.Добавить(ДополнительнаяСтраница);
		
		// В основном табличном документе напишем, что есть дополнительная страница
		ОбластьНадписи = ОбластьСтрока.Область(1,1, ОбластьСтрока.ВысотаТаблицы, ОбластьСтрока.ШиринаТаблицы);
		ОбластьНадписи.Объединить();
		ОбластьНадписи.Очистить(Истина, Истина, Истина);
		ТекстНадписи = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru='Продолжение таблицы см. в дополнении к документу №%1.';uk='Продовження таблиці див. у додатку до документа №%1.'"),
				ОбластиДополнительныхСтрок.Количество());
		ОбластьНадписи.Текст = ТекстНадписи;
		ОбластьНадписи.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Право;
		ТабличныйДокумент.Вывести(ОбластьСтрока);
		
	// В основном табличном документе выведем пустые строки до заданного количества "ОграничениеСтрок"
	ИначеЕсли КоличествоВыведенныхСтрок < ОграничениеСтрок Тогда
		
		Для ПараметрОбласти = 0 По ОбластьСтрока.Параметры.Количество() -1 Цикл
			ОбластьСтрока.Параметры[ПараметрОбласти] = Неопределено;
		КонецЦикла;
		
		Для Шаг = КоличествоВыведенныхСтрок + 1 По ОграничениеСтрок Цикл
			ТабличныйДокумент.Вывести(ОбластьСтрока);
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Выводит дополнительные страницы в результирующий табличный документ
//
// Параметры:
//		ТабличныйДокумент - результирующий табличный документ
//		ОбластиДополнительныхСтрок - массив областей с дополнительными строками
//
Процедура ВывестиОбластиТабличногоДокументаСОграниченнымНаборомСтрок(ТабличныйДокумент, ОбластиДополнительныхСтрок) Экспорт
	
	Для каждого ДополнительнаяСтраница Из ОбластиДополнительныхСтрок Цикл
		ТабличныйДокумент.ВывестиГоризонтальныйРазделительСтраниц();
		ТабличныйДокумент.Вывести(ДополнительнаяСтраница);
	КонецЦикла;
	
КонецПроцедуры

// Выводит данные побуквенно
// Параметры:
//			Данные - Строка, которую нужно вывести
//			Раздел - Макет (область) табличного документа в которую нужно вывести
//			ИмяПоказателя - Строка, имя ячейки в области к которой прибавляется номер позиции в имени показателя
//			КоличествоЯчеек - Число, количество ячеек в которые нужно вывести данные
//			НачальнаяЯчейка - Число, ячейка с которой нужно начать побуквенный вывод
Процедура ВывестиДанныеПоБуквенно(Данные, Раздел, ИмяПоказателя, КоличествоЯчеек, НачальнаяЯчейка = 1) Экспорт

	Для НомЯчейки = НачальнаяЯчейка По НачальнаяЯчейка + КоличествоЯчеек - 1 Цикл
		Раздел.Области[ИмяПоказателя + Формат(НомЯчейки,"ЧГ=0")].Текст = Сред(Данные, НомЯчейки - НачальнаяЯчейка + 1, 1);
	КонецЦикла;

КонецПроцедуры

// Разбивает строку (не разрывая слов) на подстроки указанной длинны, 
//							строки дополняются пробелами, переводы строк удаляются
// Параметры
//  ТекстСтроки  - Строка, которую необходимо разбить на подстроки
//                 
//  МассивДлинСтрок  - Массив длин строк, если в результирующей строке оказалось подстрок больше
//                     Чем кодичество указанных длин, то все "лишние" строки выравниваются по последнему
//                     значению длинны строки.
// Возвращаемое значение:
//   Строка   - разбитая на подстроки указанной длинны
//
Функция РазбитьСтрокуНаПодСтроки(Знач ТекстСтроки, МассивДлинСтрок) Экспорт

	ВозвращаемаяСтрока = "";
	
	РазделителиСлов = " .,:;?!%\<>+-*/=_" + Символы.ПС;
	
	ТекстСтроки = СокрЛП(ТекстСтроки);
	
	// обыграем случай, когда у нас многострочная строка
	Если СтрЧислоСтрок(ТекстСтроки) > 1 Тогда
	
		Для НомерПодстроки = 1 По СтрЧислоСтрок(ТекстСтроки) Цикл
			
			НовыйМассивДлинСтроки = Новый Массив;
			
			Если НомерПодстроки = 1 Тогда
			
				НачальнаяГраница = 0;
			
			Иначе
				
				Если СтрЧислоСтрок(ВозвращаемаяСтрока) > МассивДлинСтрок.ВГраница() Тогда
				
					НачальнаяГраница = МассивДлинСтрок.ВГраница();
					
				Иначе
					
					НачальнаяГраница = СтрЧислоСтрок(ВозвращаемаяСтрока);
				
				КонецЕсли; 
			
			КонецЕсли; 
			
			Для ИндексСтроки = НачальнаяГраница По МассивДлинСтрок.ВГраница() Цикл
			
				НовыйМассивДлинСтроки.Добавить(МассивДлинСтрок[ИндексСтроки]);
			
			КонецЦикла; 
		
			ВозвращаемаяСтрока = ВозвращаемаяСтрока + ?(ПустаяСтрока(ВозвращаемаяСтрока), "", Символы.ПС) + РазбитьСтрокуНаПодСтроки(СтрПолучитьСтроку(ТекстСтроки, НомерПодстроки), НовыйМассивДлинСтроки);
		
		КонецЦикла; 
		
	Иначе
		
		ДлинаСтроки = МассивДлинСтрок[0];
		
		// Если длина строки меньше или равна нужной длине - просто вернем ее
		Если СтрДлина(ТекстСтроки) <= ДлинаСтроки Тогда
		
			ВозвращаемаяСтрока = ТекстСтроки; 
			
		Иначе
			
			// Заменим все разделители символом _, для удобства анализа
			ТестируемаяСтрока = ТекстСтроки;
			
			Для НомерРазделителя = 1 По СтрДлина(РазделителиСлов)  Цикл
				
				РазделительСлов = Сред(РазделителиСлов, НомерРазделителя, 1);
				
				ТестируемаяСтрока = СтрЗаменить(ТестируемаяСтрока, РазделительСлов, "_");
			
			КонецЦикла; 
			
			// Найдем первый разделитель
			Разрыв = Найти(ТестируемаяСтрока, "_");
			
			ИндексМассиваДлинСтрок = 0;
			
			// Обрабатываем строку пока она не закончится
			Пока СтрДлина(ТекстСтроки) > 0 Цикл
				
				Если ИндексМассиваДлинСтрок <= МассивДлинСтрок.ВГраница() Тогда
				
					ДлинаСтроки = МассивДлинСтрок[ИндексМассиваДлинСтрок];
				
				Иначе
				
					ДлинаСтроки = МассивДлинСтрок[МассивДлинСтрок.ВГраница()];
				
				КонецЕсли; 
				
				// если разрыв больше чем нужная длина
				// если разрывов больше нет
				// и частный случай, когда есть разрыв - пробел в самом конце строки нужной длины
				// или длина оставшейся строки меньше или равна нужной длине
				Если Разрыв >= ДлинаСтроки ИЛИ Разрыв = 0 ИЛИ Сред(ТекстСтроки, ДлинаСтроки + 1, 1) = " " ИЛИ СтрДлина(ТекстСтроки) <= ДлинаСтроки Тогда
				
					ВозвращаемаяСтрока = ВозвращаемаяСтрока + ?(ПустаяСтрока(ВозвращаемаяСтрока), "", Символы.ПС) + СокрЛП(Лев(ТекстСтроки, ДлинаСтроки));
					
					ТекстСтроки = СокрЛП(Сред(ТекстСтроки, ДлинаСтроки + 1));
					
					ТестируемаяСтрока = Сред(ТестируемаяСтрока, ДлинаСтроки + 1);
					
					Если Лев(ТестируемаяСтрока,1) = "_" Тогда
					
						ТестируемаяСтрока = Сред(ТестируемаяСтрока, 2);
					
					КонецЕсли; 
					
					ИндексМассиваДлинСтрок = ИндексМассиваДлинСтрок + 1;
					
					Разрыв = Найти(ТестируемаяСтрока, "_");
				
				Иначе 
					
					НовыйРазрыв = Найти(Сред(ТестируемаяСтрока, Разрыв + 1), "_");
					
					// Есть еще один разрыв и он вместе с предыдущим меньше или равен длине строки
					Если НовыйРазрыв > 0 И Разрыв + НовыйРазрыв <= ДлинаСтроки Тогда
						
						Разрыв = Разрыв + НовыйРазрыв;
						
					Иначе
						
						// больше разрывов нет
						// или он вместе с предыдущим больше нужной длины
						ВозвращаемаяСтрока = ВозвращаемаяСтрока + ?(ПустаяСтрока(ВозвращаемаяСтрока), "", Символы.ПС) + СокрЛП(Лев(ТекстСтроки, Разрыв));
						
						ТекстСтроки = СокрЛП(Сред(ТекстСтроки, Разрыв + 1));
						
						ТестируемаяСтрока = Сред(ТестируемаяСтрока, Разрыв + 1);
						
						Если Лев(ТестируемаяСтрока,1) = "_" Тогда
					
							ТестируемаяСтрока = Сред(ТестируемаяСтрока, 2);
					
						КонецЕсли; 
					
						ИндексМассиваДлинСтрок = ИндексМассиваДлинСтрок + 1;
					
						Разрыв = Найти(ТестируемаяСтрока, "_");
						
					КонецЕсли;
				
				КонецЕсли;
				
			КонецЦикла; 
				
		КонецЕсли; 
	
	КонецЕсли;
	
	Если СтрЧислоСтрок(ВозвращаемаяСтрока) > 1 Тогда
		
		ВыровненнаяСтрока = "";
		
		Для НомерПодстроки = 1 По СтрЧислоСтрок(ВозвращаемаяСтрока) - 1 Цикл
			
			ВыравниваемаяСтрока = СтрПолучитьСтроку(ВозвращаемаяСтрока, НомерПодстроки);
			
			Если НомерПодстроки - 1 <= МассивДлинСтрок.ВГраница() Тогда
				
				ДлинаСтроки = МассивДлинСтрок[НомерПодстроки - 1];
				
			Иначе
				
				ДлинаСтроки = МассивДлинСтрок[МассивДлинСтрок.ВГраница()];
				
			КонецЕсли; 
				
			Для НомерПозицииВСтроке = СтрДлина(ВыравниваемаяСтрока) + 1 По ДлинаСтроки Цикл
			
				ВыравниваемаяСтрока = ВыравниваемаяСтрока + " ";
			
			КонецЦикла; 
			
			ВыровненнаяСтрока = ВыровненнаяСтрока + ?(ПустаяСтрока(ВыровненнаяСтрока), "", Символы.ПС) + ВыравниваемаяСтрока;
		
		КонецЦикла;
		
		ВозвращаемаяСтрока = ВыровненнаяСтрока + Символы.ПС + СтрПолучитьСтроку(ВозвращаемаяСтрока, СтрЧислоСтрок(ВозвращаемаяСтрока));
		
	КонецЕсли; 
	
	ВозвращаемаяСтрока = СтрЗаменить(ВозвращаемаяСтрока, Символы.ПС, "");
	
	Возврат ВозвращаемаяСтрока;

КонецФункции // РазбитьСтрокуПоСтрочно()

// Выводит сумму в рублях и копейках в ячейки посимвольно
// Параметры:
//			Данные - Строка, которую нужно вывести
//			ТабличныйДокумент - Макет (область) табличного документа в которую нужно вывести
//			ПрефиксЯчеек - Строка, имя ячейки в области к которой прибавляется номер позиции в имени показателя
//			КоличествоЯчеек - Число, количество ячеек в которые нужно вывести данные
Процедура ВывестиСуммуВРубляхКопейкахВЯчейки(Данные, ТабличныйДокумент, ПрефиксЯчеек, КоличествоЯчеек) Экспорт
	ВывестиДанныеПоБуквенно(Прав("                  " + Формат(Данные, "ЧЦ=" + (КоличествоЯчеек + 1) + "; ЧДЦ=0; ЧС=-2; ЧГ="), КоличествоЯчеек), ТабличныйДокумент, ПрефиксЯчеек, КоличествоЯчеек);
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

/////////////////////////////////////
// Работа с деревом XML

Функция ПолучитьФорматЗаписиИзДереваФормата(Знач ДеревоФормата, Знач ИмяЗаписи)
	
	ТаблицаФормаЗаписи = Новый ТаблицаЗначений;
	ТаблицаФормаЗаписи.Колонки.Добавить("ИмяПоля",					Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(100)));
	ТаблицаФормаЗаписи.Колонки.Добавить("ТипДанных",				Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(10)));
	ТаблицаФормаЗаписи.Колонки.Добавить("ТипЭлемента",				Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(10)));
	ТаблицаФормаЗаписи.Колонки.Добавить("Размер",					Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(5)));
	ТаблицаФормаЗаписи.Колонки.Добавить("РазрядностьДробнойЧасти",	Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(5)));
	ТаблицаФормаЗаписи.Колонки.Добавить("ЭлементНеОбязателен", Новый ОписаниеТипов("Булево"));
	ТаблицаФормаЗаписи.Колонки.Добавить("НеВыводитьВФайл", Новый ОписаниеТипов("Булево"));

	
	УзлыФормата = ДеревоФормата.ДочерниеУзлы[0].ПолучитьЭлементыПоИмени(ИмяЗаписи)[0].ДочерниеУзлы;
	
	Для Каждого УзелФормата Из УзлыФормата Цикл
		
		//имя поля хранится в 4-ой колонке
		ИмяПоля = УзелФормата.ДочерниеУзлы[3].ТекстовоеСодержимое;
		Если ИмяПоля <> "" Тогда
			
			НовоеПоле = ТаблицаФормаЗаписи.Добавить();
			НовоеПоле.ИмяПоля = СокрЛП(ИмяПоля);
			//тип данных хранится во 2-ой колонке	
			НовоеПоле.ТипДанных = ВРег(УзелФормата.ДочерниеУзлы[1].ТекстовоеСодержимое);
			
			НовоеПоле.НеВыводитьВФайл = Ложь;
			
			Если УзелФормата.ДочерниеУзлы.Количество() = 7 И УзелФормата.ДочерниеУзлы[6].ИмяУзла = "ТипЭлемента" Тогда
				НовоеПоле.ТипЭлемента = ВРег(УзелФормата.ДочерниеУзлы[6].ТекстовоеСодержимое);
			Иначе
				НовоеПоле.ТипЭлемента = "С";
			КонецЕсли;	
			
			//размер поля хранится в 3-ей колонке	
			СтрРазмерПоля = УзелФормата.ДочерниеУзлы[2].ТекстовоеСодержимое;
			//Если указан размер поля, сохраним его
			Если (НовоеПоле.ТипДанных = "ЧИСЛО" Или НовоеПоле.ТипДанных = "СТРОКА") И СтрРазмерПоля <> "" Тогда
				ПозицияТочки = Найти(СтрРазмерПоля,".");
				Если ПозицияТочки<>0 Тогда
					НовоеПоле.Размер = Число(Лев(СтрРазмерПоля,ПозицияТочки-1));
					НовоеПоле.РазрядностьДробнойЧасти = Число(Сред(СтрРазмерПоля,ПозицияТочки+1));
				Иначе	
					НовоеПоле.Размер = Число(СтрРазмерПоля);
					НовоеПоле.РазрядностьДробнойЧасти = 0;
				КонецЕсли;	 
			КонецЕсли;	 
			//Признак обязательности элемента хранится в 5-й колонке	
			НовоеПоле.ЭлементНеОбязателен = (ВРег(УзелФормата.ДочерниеУзлы[4].ТекстовоеСодержимое) = "НЕ ОБЯЗАТЕЛЬНО" Или ВРег(УзелФормата.ДочерниеУзлы[4].ТекстовоеСодержимое) = "Н");
			
		КонецЕсли;	 
		
	КонецЦикла;
	
	Возврат ТаблицаФормаЗаписи;
КонецФункции

///////////////////////////////////////////////////////////////////////////////
// Проверка персональных данных физических лиц

Процедура ПроверитьДатыРождения(Дата, СтруктураПроверяемыхДанных, СоответствиеРеквизитовОткрываемымОбъектам, ДанныеДляПроверки, ВыводитьСообщения = Истина, Отказ = Ложь)
	Перем ОткрываемыйОбъект;
	
	Если СтруктураПроверяемыхДанных.Свойство("ДатаРожденияВСвидетельстве") Тогда
		Если Не СоответствиеРеквизитовОткрываемымОбъектам.Свойство("ДатаРожденияВСвидетельстве", ОткрываемыйОбъект) Тогда
			ОткрываемыйОбъект = ДанныеДляПроверки.Сотрудник;
		КонецЕсли;	
		
		Если ЗначениеЗаполнено(СтруктураПроверяемыхДанных.ДатаРожденияВСвидетельстве) И СтруктураПроверяемыхДанных.ДатаРожденияВСвидетельстве > Дата Тогда
			Если ВыводитьСообщения Тогда
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Сотрудник %1: указанная в свидетельстве дата рождения не может быть больше даты подачи сведений!';uk='Співробітник %1: зазначена у свідоцтві дата народження не може бути більше дати подання відомостей!'"), ДанныеДляПроверки.СотрудникНаименование);
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки, ОткрываемыйОбъект, "ДатаРождения",,Отказ);
			Иначе
				Отказ = Истина;
			КонецЕсли;	
		КонецЕсли;	
	КонецЕсли;	
	
	Если СтруктураПроверяемыхДанных.Свойство("ДатаРождения") Тогда
		Если Не СоответствиеРеквизитовОткрываемымОбъектам.Свойство("ДатаРождения", ОткрываемыйОбъект) Тогда
			ОткрываемыйОбъект = ДанныеДляПроверки.Сотрудник;
		КонецЕсли;	
		
		Если ЗначениеЗаполнено(СтруктураПроверяемыхДанных.ДатаРождения) И СтруктураПроверяемыхДанных.ДатаРождения > Дата Тогда
			Если ВыводитьСообщения Тогда
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Сотрудник %1: дата рождения не может быть больше даты подачи сведений!';uk='Співробітник %1: дата народження не може бути більше дати подання відомостей!'"), ДанныеДляПроверки.СотрудникНаименование);
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки, ОткрываемыйОбъект, "ДатаРождения",,Отказ);
			Иначе
				Отказ = Истина;
			КонецЕсли;	
		КонецЕсли;	
	КонецЕсли;		
КонецПроцедуры	

Процедура ПроверитьОбязательныеПоля(Ссылка, СтруктураПроверяемыхДанных, ДанныеДляПроверки, СоответствиеПутейИИменПроверяемыхРеквизитов, СоответствиеРеквизитовФормеОбъекта, СоответствиеРеквизитовПутиВФормеОбъекта, СоответствиеРеквизитовОткрываемымОбъектам, ПредставленияПроверяемыхРеквизитов, МассивНепроверяемыхРеквизитов, ВыводитьСообщения = Истина, Отказ = Ложь)
	Перем ЗначениеДанныхСвидетельства;
	Перем ОткрываемыйОбъект;
	Для Каждого КлючЗначение Из СтруктураПроверяемыхДанных Цикл
		Если КлючЗначение.Значение = Неопределено Тогда 
			Продолжить;	
		КонецЕсли;	
		
		Если СоответствиеПутейИИменПроверяемыхРеквизитов.Свойство(КлючЗначение.Ключ) Тогда
			Если Не ЗначениеЗаполнено(КлючЗначение.Значение) Тогда
				
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Сотрудник %1: %2';uk='Співробітник %1: %2'"), ДанныеДляПроверки.СотрудникНаименование, ПредставленияПроверяемыхРеквизитов[КлючЗначение.Ключ]);
				
				Если НЕ СоответствиеРеквизитовОткрываемымОбъектам.Свойство(КлючЗначение.Ключ, ОткрываемыйОбъект) Тогда
					ОткрываемыйОбъект = ДанныеДляПроверки.Сотрудник;
				КонецЕсли;	
				
				Если (СтруктураПроверяемыхДанных.Свойство(КлючЗначение.Ключ + "ВСвидетельстве", ЗначениеДанныхСвидетельства) И ЗначениеДанныхСвидетельства <> Неопределено) Или Прав(КлючЗначение.Ключ, 14) = "ВСвидетельстве" Тогда
					ОткрываемыйОбъект = Ссылка;
				Иначе
					ОткрываемыйОбъект = ДанныеДляПроверки.Сотрудник;
				КонецЕсли;	
				Если ВыводитьСообщения Тогда
					ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки, ОткрываемыйОбъект, СоответствиеРеквизитовФормеОбъекта[КлючЗначение.Ключ], СоответствиеРеквизитовПутиВФормеОбъекта[КлючЗначение.Ключ], Отказ);
				Иначе
					Отказ = Истина;
				КонецЕсли;	
			КонецЕсли;
			МассивНепроверяемыхРеквизитов.Добавить(СоответствиеПутейИИменПроверяемыхРеквизитов[КлючЗначение.Ключ]);
		КонецЕсли;				
	КонецЦикла;	
	
КонецПроцедуры	

Процедура ПроверитьМестоРождения(СтруктураПроверяемыхДанных, СоответствиеРеквизитовОткрываемымОбъектам, ДанныеДляПроверки, ВыводитьСообщения = Истина, Отказ = Ложь)
	Перем ОткрываемыйОбъект;
	
	Если СтруктураПроверяемыхДанных.Свойство("МестоРождения") Тогда
		
		Если Не СоответствиеРеквизитовОткрываемымОбъектам.Свойство("МестоРождения", ОткрываемыйОбъект) Тогда
			ОткрываемыйОбъект = ДанныеДляПроверки.Сотрудник;
		КонецЕсли;	
		
		Если ЗначениеЗаполнено(ДанныеДляПроверки.МестоРождения) Тогда 
			Если СокрЛП(СтрЗаменить(ДанныеДляПроверки.МестоРождения,",","")) = "" 
				или СокрЛП(СтрЗаменить(ДанныеДляПроверки.МестоРождения,",","")) = "0" Тогда
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Сотрудник %1: не заполнено место рождения!';uk='Співробітник %1: не заповнено місце народження!'"), ДанныеДляПроверки.СотрудникНаименование);
				Если ВыводитьСообщения Тогда
					ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки, ОткрываемыйОбъект, "ФизическоеЛицоМестоРождения", "ЭтаФорма",Отказ);
				Иначе
					Отказ = Истина;
				КонецЕсли;	
			КонецЕсли; 
		КонецЕсли;	

	КонецЕсли;		
КонецПроцедуры	

Процедура ПроверитьДанныеУдостоверенийЛичности(Ссылка, Дата, СтруктураПроверяемыхДокументов, ДанныеДляПроверки, СоответствиеПутейИИменПроверяемыхРеквизитов, СоответствиеРеквизитовФормеОбъекта, СоответствиеРеквизитовПутиВФормеОбъекта, ПредставленияПроверяемыхРеквизитов,СоответствиеРеквизитовОткрываемымОбъектам, МассивНепроверяемыхРеквизитов, ВыводитьСообщения = Истина, Отказ = Истина)
	Перем ОткрываемыйОбъект;
	Для Каждого КлючЗначение Из СтруктураПроверяемыхДокументов Цикл
		Если КлючЗначение.Значение = Неопределено Тогда 
			Продолжить;	
		КонецЕсли;	
		
		Если СоответствиеПутейИИменПроверяемыхРеквизитов.Свойство(КлючЗначение.Ключ) Тогда
			Если Не ЗначениеЗаполнено(КлючЗначение.Значение) Тогда
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Сотрудник %1: %2';uk='Співробітник %1: %2'"), ДанныеДляПроверки.СотрудникНаименование, ПредставленияПроверяемыхРеквизитов[КлючЗначение.Ключ]);
				
				Если Не СоответствиеРеквизитовОткрываемымОбъектам.Свойство(КлючЗначение.Ключ) Тогда
					ОткрываемыйОбъект = ДанныеДляПроверки.Сотрудник;
				КонецЕсли;	
				
				Если ВыводитьСообщения Тогда
					ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки, ОткрываемыйОбъект, СоответствиеРеквизитовФормеОбъекта[КлючЗначение.Ключ], СоответствиеРеквизитовПутиВФормеОбъекта[КлючЗначение.Ключ], Отказ);
				Иначе
					Отказ = Истина;
				КонецЕсли;	
			КонецЕсли;
			МассивНепроверяемыхРеквизитов.Добавить(СоответствиеПутейИИменПроверяемыхРеквизитов[КлючЗначение.Ключ]);
		КонецЕсли;				
	КонецЦикла;	
	
	//Проверка правильности заполнения документа, удостоверяющего личность
	Если СтруктураПроверяемыхДокументов.Свойство("ВидДокумента") Тогда	
		Если ЗначениеЗаполнено(СтруктураПроверяемыхДокументов.ВидДокумента) Тогда
			Если СтруктураПроверяемыхДокументов.Свойство("ДатаВыдачи") Тогда
				Если Не СоответствиеРеквизитовОткрываемымОбъектам.Свойство("ДатаВыдачи") Тогда
					ОткрываемыйОбъект = ДанныеДляПроверки.Сотрудник;
				КонецЕсли;
				
				Если СтруктураПроверяемыхДокументов.ДатаВыдачи <> Неопределено И СтруктураПроверяемыхДокументов.ДатаВыдачи > Дата Тогда
					ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Сотрудник %1: дата выдачи документа не может быть больше даты подачи сведений!';uk='Співробітник %1: дата видачі документа не може бути більше дати подання відомостей!'"), ДанныеДляПроверки.СотрудникНаименование);
					Если ВыводитьСообщения Тогда
						ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки, ОткрываемыйОбъект, СоответствиеРеквизитовФормеОбъекта.ДатаВыдачи, СоответствиеРеквизитовПутиВФормеОбъекта.ДатаВыдачи ,Отказ);
					Иначе
						Отказ = Истина;
					КонецЕсли;	
				КонецЕсли;
			КонецЕсли;	
			
			Если СтруктураПроверяемыхДокументов.Свойство("СерияДокумента") Тогда 
				Если ЗначениеЗаполнено(ДанныеДляПроверки.СерияДокумента) Тогда
					
					Если Не СоответствиеРеквизитовОткрываемымОбъектам.Свойство("СерияДокумента") Тогда
						ОткрываемыйОбъект = ДанныеДляПроверки.Сотрудник;
					КонецЕсли;
					
					ТекстОшибкиСерия = "";
					Если НЕ ФизическиеЛицаКлиентСервер.СерияДокументаУказанаПравильно(ДанныеДляПроверки.ВидДокумента, ДанныеДляПроверки.СерияДокумента, ТекстОшибкиСерия) Тогда
						Если ВыводитьСообщения Тогда
							ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Сотрудник %1: %2!';uk='Співробітник %1: %2!'"), ДанныеДляПроверки.СотрудникНаименование, ТекстОшибкиСерия);
							ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки, ОткрываемыйОбъект, СоответствиеРеквизитовФормеОбъекта.СерияДокумента, СоответствиеРеквизитовПутиВФормеОбъекта.СерияДокумента, Отказ);
						Иначе
							Отказ = Истина;
						КонецЕсли;	
					КонецЕсли;	
				КонецЕсли;	
			КонецЕсли;	
				
			Если СтруктураПроверяемыхДокументов.Свойство("НомерДокумента") Тогда 
				Если ЗначениеЗаполнено(ДанныеДляПроверки.НомерДокумента) Тогда
					Если Не СоответствиеРеквизитовОткрываемымОбъектам.Свойство("НомерДокумента") Тогда
						ОткрываемыйОбъект = ДанныеДляПроверки.Сотрудник;
					КонецЕсли;
					
					ТекстОшибкиНомер = "";
					Если НЕ ФизическиеЛицаКлиентСервер.НомерДокументаУказанПравильно(ДанныеДляПроверки.ВидДокумента, ДанныеДляПроверки.НомерДокумента, ТекстОшибкиНомер) Тогда 
						Если ВыводитьСообщения Тогда
							ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Сотрудник %1: %2!';uk='Співробітник %1: %2!'"), ДанныеДляПроверки.СотрудникНаименование, ТекстОшибкиНомер);
							ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки, ОткрываемыйОбъект, СоответствиеРеквизитовФормеОбъекта.НомерДокумента, СоответствиеРеквизитовПутиВФормеОбъекта.НомерДокумента, Отказ);
						Иначе
							Отказ = Истина;
						КонецЕсли;	
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;	
		КонецЕсли;	
	КонецЕсли;	
КонецПроцедуры	

Процедура ПроверитьЗаполнениеАдресов(СтруктураПроверяемыхДанных, СоответствиеРеквизитовОткрываемымОбъектам, ДанныеДляПроверки, ВыводитьСообщения = Истина, Отказ = Ложь)
Перем ОткрываемыйОбъект;
	
	Если СтруктураПроверяемыхДанных.Свойство("АдресРегистрации") И ЗначениеЗаполнено(СтруктураПроверяемыхДанных.АдресРегистрации) Тогда
		АдресРегистрации = СтруктураПроверяемыхДанных.АдресРегистрации;
		
		Если НЕ СоответствиеРеквизитовОткрываемымОбъектам.Свойство("АдресРегистрации", ОткрываемыйОбъект) Тогда
			ОткрываемыйОбъект = ДанныеДляПроверки.Сотрудник;
		КонецЕсли;
	ИначеЕсли СтруктураПроверяемыхДанных.Свойство("Адрес") И ЗначениеЗаполнено(СтруктураПроверяемыхДанных.Адрес) Тогда
		АдресРегистрации = СтруктураПроверяемыхДанных.Адрес;
		Если НЕ СоответствиеРеквизитовОткрываемымОбъектам.Свойство("Адрес", ОткрываемыйОбъект) Тогда
			ОткрываемыйОбъект = ДанныеДляПроверки.Сотрудник;
		КонецЕсли;
	Иначе
		АдресРегистрации = "";
	КонецЕсли;
	
	Если ЗначениеЗаполнено(АдресРегистрации) Тогда 
		МассивОшибок = УправлениеКонтактнойИнформацией.ПроверитьАдрес(АдресРегистрации);
		Если МассивОшибок.Количество() <> 0 Тогда
			Если ВыводитьСообщения Тогда
				СообщенияПроверки = "";
				Для каждого СтруктураОшибки Из МассивОшибок Цикл
					СообщенияПроверки = СообщенияПроверки + СтруктураОшибки.Сообщение + Символы.ПС;
				КонецЦикла;
				СтроковыеФункцииКлиентСервер.УдалитьПоследнийСимволВСтроке(СообщенияПроверки, 1);
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Сотрудник %1: - поле ""Адрес регистрации"":';uk='Співробітник %1: - поле ""Адреса реєстрації"":'"), ДанныеДляПроверки.СотрудникНаименование);
				ТекстОшибки = ТекстОшибки + Символы.ПС + СообщенияПроверки;
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки,ОткрываемыйОбъект, ,,Отказ);
			Иначе
				Отказ = Истина;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если СтруктураПроверяемыхДанных.Свойство("АдресФактический") Тогда
		Если НЕ СоответствиеРеквизитовОткрываемымОбъектам.Свойство("АдресФактический", ОткрываемыйОбъект) Тогда
			ОткрываемыйОбъект = ДанныеДляПроверки.Сотрудник;
		КонецЕсли;
		Если ЗначениеЗаполнено(СтруктураПроверяемыхДанных.АдресФактический) Тогда 
			МассивОшибок = УправлениеКонтактнойИнформацией.ПроверитьАдрес(СтруктураПроверяемыхДанных.АдресФактический);
			Если МассивОшибок.Количество() <> 0 Тогда
				Если ВыводитьСообщения Тогда
					СообщенияПроверки = "";
					Для каждого СтруктураОшибки Из МассивОшибок Цикл
						СообщенияПроверки = СообщенияПроверки + СтруктураОшибки.Сообщение + Символы.ПС;
					КонецЦикла;
					СтроковыеФункцииКлиентСервер.УдалитьПоследнийСимволВСтроке(СообщенияПроверки, 1);
					ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Сотрудник %1: - поле ""Фактический адрес"":';uk='Співробітник %1: - поле ""Фактична адреса"":'"), ДанныеДляПроверки.СотрудникНаименование);
					ТекстОшибки = ТекстОшибки + Символы.ПС + СообщенияПроверки;
					ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки, ОткрываемыйОбъект, ,,Отказ);
				Иначе
					Отказ = Истина;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если СтруктураПроверяемыхДанных.Свойство("АдресДляИнформирования") Тогда
		Если НЕ СоответствиеРеквизитовОткрываемымОбъектам.Свойство("АдресДляИнформирования", ОткрываемыйОбъект) Тогда
			ОткрываемыйОбъект = ДанныеДляПроверки.Сотрудник;
		КонецЕсли;
		Если ЗначениеЗаполнено(СтруктураПроверяемыхДанных.АдресДляИнформирования) Тогда 
			МассивОшибок = УправлениеКонтактнойИнформацией.ПроверитьАдрес(СтруктураПроверяемыхДанных.АдресДляИнформирования);
			Если МассивОшибок.Количество() <> 0 Тогда
				Если ВыводитьСообщения Тогда
					СообщенияПроверки = "";
					Для каждого СтруктураОшибки Из МассивОшибок Цикл
						СообщенияПроверки = СообщенияПроверки + СтруктураОшибки.Сообщение + Символы.ПС;
					КонецЦикла;
					СтроковыеФункцииКлиентСервер.УдалитьПоследнийСимволВСтроке(СообщенияПроверки, 1);
					ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Сотрудник %1: - поле ""Адрес для информирования"":';uk='Співробітник %1: - поле ""Адреса для інформування"":'"), ДанныеДляПроверки.СотрудникНаименование);
					ТекстОшибки = ТекстОшибки + Символы.ПС + СообщенияПроверки;
					ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки, ОткрываемыйОбъект, ,,Отказ);
				Иначе
					Отказ = Истина;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////////////////////////
// Работа с личными данными физических лиц

Процедура ИзменитьНаименованиеФизическихЛиц(ДанныеФИО)
	
	Пока ДанныеФИО.Следующий() Цикл
		
		ФизЛицоОбъект = ДанныеФИО.ФизическоеЛицо.ПолучитьОбъект();
		
		СтруктураФИО = ФизическиеЛицаКлиентСервер.ФамилияИмяОтчество(ДанныеФИО.Наименование);
		НаименованиеФизЛица = СтруктураФИО.Фамилия + " " + СтруктураФИО.Имя + " " + СтруктураФИО.Отчество;
		
		Если СокрЛП(НаименованиеФизЛица) = КадровыйУчетКлиентСервер.ПолноеНаименованиеСотрудника(ДанныеФИО.Фамилия, ДанныеФИО.Имя, ДанныеФИО.Отчество, ДанныеФИО.УточнениеНаименования) Тогда
			Продолжить;
		КонецЕсли;
		
		Попытка 
			ФизЛицоОбъект.Заблокировать();
		Исключение
			Отказ = Истина;
			ТекстИсключенияЗаписи = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Не удалось изменить имя физического лица %1.
|Возможно, данные сотрудника редактируются другим пользователем';uk=""Не вдалося змінити ім'я фізичної особи, %1.
|Можливо, дані співробітника редагуються іншим користувачем"""),
			ФизЛицоОбъект.Наименование);
			ВызватьИсключение ТекстИсключенияЗаписи;
			
		КонецПопытки;
		
		ФизЛицоОбъект.Наименование = КадровыйУчетКлиентСервер.ПолноеНаименованиеСотрудника(
				ДанныеФИО.Фамилия,
				ДанныеФИО.Имя,
				ДанныеФИО.Отчество,
				ДанныеФИО.УточнениеНаименования);
		
		ФизЛицоОбъект.Записать();
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ИзменитьНаименованиеСотрудников(ДанныеФИО)
	
	Пока ДанныеФИО.Следующий() Цикл
		
		СтруктураФИО = ФизическиеЛицаКлиентСервер.ФамилияИмяОтчество(ДанныеФИО.СотрудникНаименование);
		НаименованиеСотрудника = СтруктураФИО.Фамилия + " " + СтруктураФИО.Имя + " " + СтруктураФИО.Отчество;
		
		ПолноеНаименованиеСотрудника  = КадровыйУчетКлиентСервер.ПолноеНаименованиеСотрудника(
				ДанныеФИО.Фамилия,
				ДанныеФИО.Имя,
				ДанныеФИО.Отчество,
				ДанныеФИО.УточнениеНаименованияФизЛица,
				ДанныеФИО.УточнениеНаименования);
		
		Если СокрЛП(НаименованиеСотрудника) = ПолноеНаименованиеСотрудника Тогда
			Продолжить;
		КонецЕсли;
		
		СотрудникОбъект = ДанныеФИО.Сотрудник.ПолучитьОбъект();
		
		Попытка 
			СотрудникОбъект.Заблокировать();
		Исключение
			Отказ = Истина;
			ТекстИсключенияЗаписи = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Не удалось изменить имя сотрудника %1.
|Возможно, данные сотрудника редактируются другим пользователем';uk=""Не вдалося змінити ім'я співробітника %1.
|Можливо, дані співробітника редагуються іншим користувачем"""),
			СотрудникОбъект.Наименование);
			ВызватьИсключение ТекстИсключенияЗаписи;
			
		КонецПопытки;
		
		СотрудникОбъект.Наименование = ПолноеНаименованиеСотрудника;
		
		СотрудникОбъект.Записать();
	КонецЦикла;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Прочие процедуры и функции

// Формирует временную таблицу с значениями ресурсов заданного регистра сведений
// Параметры:
//		МенеджерВременныхТаблиц
//
//		ТолькоРазрешенные - если истина, выбираются только разрешенные записи
//
//		ИмяРегистра - имя регистра сведений (не полное)
//
//		ИзмеренияДаты - таблица значений
//			Должна обязательно содержать колонку "Период"
//			Может содержать колонки с именами, совпадающими с именами 
//			измерений регистра сведений
//
//			Используется как фильтр - переданные в ней значения измерений "фильтруют" регистр.
//			В зависимости от значения параметра ВсеЗаписи строки ИзмеренияДаты используются 
//			не только как фильтр, но и как набор значений для дополнения результирующей 
//			временной таблицы.
//			Содержит даты получения последних значений ресурсов.
//			В предельном случае, когда нет колонок таблицы, соответствующих измерениям, 
//			(т.е. фильтрация по измерениям не выполняется), в таблице содержится одна строка 
//			с датой на которую нужно получить значения ресурсов.
//
//		Отбор - коллекция условий отбора, соединяемых по "И" и применяемых к регистру сведений
//			Коллекция строки которой имеют поля
//				ЛевоеЗначение - строка, имя поля регистра сведений
//				ВидСравнения - строка, вид сравнения, допустимый в языке запросов
//				ПравоеЗначение - значение для сравнения с полем ЛевоеЗначение
//
//		ВсеЗаписи - булево значение. 
//			Если Истина, то в результирующей временной таблице
//			должно быть столько же записей, сколько передано в параметре ИзмеренияДаты
//			Если Ложь, то временная таблица содержит записи только для тех 
//			значений измерений, для которых существуют данные в регистре
//			По умолчанию - Ложь
//	
//		ВключаяГраницу - булево значение.	
//			Если Истина, то записи на дату формирования среза учитываются
//			Если Ложь, то записи на дату формирования среза не учитываются
//			По умолчанию - Истина  
//
//		СрезПоследних - булево значение. 
//			Если Истина, во временную таблицу выбирется срез последних, иначе срез первых 
//			По умолчанию - Истина  
//			
// Создает в МенеджерВременныхТаблиц временную таблицу с именем ВТ<ИмяРегистра>СрезПоследних или ВТ<ИмяРегистра>СрезПервых.
// Например: ВТПлановыеНачисленияСрезПоследних
// Поля временной таблицы
//	- Период
//	- Все измерения (не только переданные в качестве фильтра, а все)
//	- Все ресурсы 
//	- Все реквизиты
//	- Все стандартные реквизиты
//
Процедура СоздатьПоТаблицеЗначенийВТИмяРегистраСрез(МенеджерВременныхТаблиц, ТолькоРазрешенные, ИмяРегистра, ИзмеренияДаты, Отбор, ВсеЗаписи, ВключаяГраницу, СрезПоследних)
	
	МассивИзмерений = Новый Массив;
	Для Каждого Колонка Из ИзмеренияДаты.Колонки Цикл
		МассивИзмерений.Добавить(Колонка.Имя);		
	КонецЦикла;	
	
	КоллекцииПолей = КоллекцииПолейДляПодготовкиТекстаЗапроса(ИмяРегистра, МассивИзмерений);
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ИзмеренияДаты", ИзмеренияДаты);
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	
	ИмяВТИзмеренияДаты = УникальноеИмяВременнойТаблицы("ВТИзмеренияДаты");
	
	ТекстЗапроса = 
	"ВЫБРАТЬ
	|	ИзмеренияДаты.Период";
	Для Каждого Измерение Из КоллекцииПолей.ИзмеренияФильтра Цикл
		ТекстЗапроса = ТекстЗапроса + ",
		|	ИзмеренияДаты." + Измерение;
	КонецЦикла;
	ТекстЗапроса = ТекстЗапроса + "
	|ПОМЕСТИТЬ " + ИмяВТИзмеренияДаты + "
	|ИЗ
	|	&ИзмеренияДаты КАК ИзмеренияДаты";
	
	Запрос.Текст = ТекстЗапроса;
	Запрос.Выполнить();
	
	ЗапросВТИмяРегистраСрез = ЗапросВТИмяРегистраСрез(ТолькоРазрешенные, КоллекцииПолей, ИмяРегистра, ИмяВТИзмеренияДаты, "", Отбор, ВсеЗаписи, ВключаяГраницу, СрезПоследних);
	ЗапросВТИмяРегистраСрез.МенеджерВременныхТаблиц = Запрос.МенеджерВременныхТаблиц;
	
	ДобавитьТекстУдаленияВременнойТаблицы(ЗапросВТИмяРегистраСрез.Текст, ИмяВТИзмеренияДаты);
	
	ЗапросВТИмяРегистраСрез.Выполнить();
	
КонецПроцедуры

// Формирует временную таблицу с значениями ресурсов заданного регистра сведений
// Параметры:
//		ПараметрыСреза - Структура, структура полученная функцией ПараметрыДляСоздатьПоВременнойТаблицеВТИмяРегистра
//						МенеджерВременныхТаблиц,
//						Содержит следующие поля:
//							ИмяВТИзмеренияДаты - имя временной таблицы с параметрами среза.
//												 Должна обязательно поле "Период"
//												 Используется как фильтр - переданные в ней значения измерений "фильтруют" регистр.
//												 В зависимости от значения параметра ВсеЗаписи строки ИзмеренияДаты используются 
//												 не только как фильтр, но и как набор значений для дополнения результирующей 
//												 временной таблицы.
//												 Содержит даты получения последних значений ресурсов.
//												 В предельном случае, когда нет колонок таблицы, соответствующих измерениям, 
//												 (т.е. фильтрация по измерениям не выполняется), в таблице содержится одна строка 
//												 с датой на которую нужно получить значения ресурсов.
//							Измерения - массив с именами измерений, по которым будет получен "Срез последних"
//										Может содержать колонки с именами, совпадающими с именами 
//										измерений регистра сведений
//						
//
//		ТолькоРазрешенные - если истина, выбираются только разрешенные записи
//
//		ИмяРегистра - имя регистра сведений (не полное)
//			
//		Отбор - коллекция условий отбора, соединяемых по "И" и применяемых к регистру сведений
//			Коллекция строки которой имеют поля
//				ЛевоеЗначение - строка, имя поля регистра сведений
//				ВидСравнения - строка, вид сравнения, допустимый в языке запросов
//				ПравоеЗначение - значение для сравнения с полем ЛевоеЗначение
//
//		ВсеЗаписи - булево значение. 
//			Если Истина, то в результирующей временной таблице
//			должно быть столько же записей, сколько передано в параметре ИзмеренияДаты
//			Если Ложь, то временная таблица содержит записи только для тех 
//			значений измерений, для которых существуют данные в регистре
//			По умолчанию - Ложь
//	
//		ВключаяГраницу - булево значение.	
//			Если Истина, то записи на дату формирования среза учитываются
//			Если Ложь, то записи на дату формирования среза не учитываются
//			По умолчанию - Истина  
//
//		СрезПоследних - булево значение. 
//			Если Истина, во временную таблицу выбирется срез последних, иначе срез первых 
//			По умолчанию - Истина  
//			
// Создает в МенеджерВременныхТаблиц временную таблицу с именем ВТ<ИмяРегистра>СрезПоследних или ВТ<ИмяРегистра>СрезПервых.
// Например: ВТПлановыеНачисленияСрезПоследних
// Поля временной таблицы
//	- Период
//	- Все измерения (не только переданные в качестве фильтра, а все)
//	Если ПолучениеСрезаПоследних = Истина, то
//	- Все ресурсы без постфикса ПоОкончании
//	Если ПолучениеСрезаПоследних = Ложь, то
//	- Все ресурсы
//	- Все реквизиты
//	- Все стандартные реквизиты
//
Процедура СоздатьПоВременнойТаблицеВТИмяРегистраСрез(ПараметрыСреза, ТолькоРазрешенные,  ИмяРегистра, Отбор, ВсеЗаписи, ВключаяГраницу, СрезПоследних)
	
	КоллекцииПолей = КоллекцииПолейДляПодготовкиТекстаЗапроса(ИмяРегистра, ПараметрыСреза.Измерения);
	
	ЗапросВТИмяРегистраСрез = ЗапросВТИмяРегистраСрез(ТолькоРазрешенные, КоллекцииПолей, ИмяРегистра, ПараметрыСреза.ИмяВТИзмеренияДаты, "", Отбор, ВсеЗаписи, ВключаяГраницу, СрезПоследних);
	ЗапросВТИмяРегистраСрез.МенеджерВременныхТаблиц = ПараметрыСреза.МенеджерВременныхТаблиц;
	
	ЗапросВТИмяРегистраСрез.Выполнить();
	
КонецПроцедуры

Функция КоличествоНеОпределенныхЗначений(ЗаполняемыеЗначения)
	
	Количество = 0;
	
	Для Каждого КлючЗначение Из ЗаполняемыеЗначения Цикл
		Если НЕ ЗначениеЗаполнено(КлючЗначение.Значение) Тогда
			Количество = Количество + 1;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Количество;
	
КонецФункции

Функция ЭтоРегистрСведенийСЗаписьюПоУмолчанию(ИмяРегистра) Экспорт
	
	Возврат (Найти("ГражданствоФизическихЛиц,СтатусФизическихЛицКакНалогоплательщиковНДФЛ,СтатусыЗастрахованныхФизическихЛиц", ИмяРегистра) > 0);
	
КонецФункции

Функция ЗаписьРегистраСведенийПоУмолчанию(ИмяРегистра, СтруктураОтборов) Экспорт
	
	ЗаписьПоУмолчанию = РегистрыСведений[ИмяРегистра].ЗаписьПоУмолчанию();
		
	Для каждого ЭлементОтбора Из СтруктураОтборов Цикл
		ЗаписьПоУмолчанию.Вставить(ЭлементОтбора.Ключ, ЭлементОтбора.Значение);
	КонецЦикла;
		
	Возврат ЗаписьПоУмолчанию;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Универсальные процедуры и функции

Процедура УстановитьОтборВЗапросеПоПараметрам(Запрос, ТекстУсловийОтбора, Параметры)
	
	Если Параметры.Отбор.Количество() > 0 Тогда
		
		Для каждого ЭлементОтбора Из Параметры.Отбор Цикл
			
			Если ТипЗнч(ЭлементОтбора.Значение) = Тип("ФиксированныйМассив") Тогда
				
				УсловиеСПравымЗначением = " В (&Отбор" + ЭлементОтбора.Ключ + ")";
				
			Иначе
				
				УсловиеСПравымЗначением = " = (&Отбор" + ЭлементОтбора.Ключ + ")";
				
			КонецЕсли; 
			
			ТекстУсловийОтбора = ТекстУсловийОтбора + "
				|	И СписокСправочника." + ЭлементОтбора.Ключ + УсловиеСПравымЗначением;
				
			Запрос.УстановитьПараметр("Отбор" + ЭлементОтбора.Ключ, ЭлементОтбора.Значение);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ТекстУсловийОтбора) Тогда
		ТекстУсловийОтбора = "ГДЕ
			|	" + ТекстУсловийОтбора;
	КонецЕсли; 
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ГДЕ &ТекстУсловийОтбора", ТекстУсловийОтбора);
	
КонецПроцедуры

#Область ДляВызоваИзДругихПодсистем

// СтандартныеПодсистемы.РаботаВМоделиСервиса.ОчередьЗаданий

// См. ОчередьЗаданийПереопределяемый.ПриПолученииСпискаШаблонов.
Процедура ПриПолученииСпискаШаблоновОчередиЗаданий(Шаблоны) Экспорт
	
	ЗарплатаКадрыВнутренний.ПриПолученииСпискаШаблоновОчередиЗаданий(Шаблоны);
	
КонецПроцедуры

// См. ОчередьЗаданийПереопределяемый.ПриОпределенииПсевдонимовОбработчиков.
Процедура ПриОпределенииПсевдонимовОбработчиков(СоответствиеИменПсевдонимам) Экспорт
	
	ЗарплатаКадрыВнутренний.ПриОпределенииПсевдонимовОбработчиков(СоответствиеИменПсевдонимам);
	
КонецПроцедуры

// Конец СтандартныеПодсистемы.РаботаВМоделиСервиса.ОчередьЗаданий

// СтандартныеПодсистемы.Печать

// См. УправлениеПечатьюПереопределяемый.ПриОпределенииОбъектовСКомандамиПечати.
Процедура ПриОпределенииОбъектовСКомандамиПечати(СписокОбъектов) Экспорт
	
	ЗарплатаКадрыВнутренний.ПриОпределенииОбъектовСКомандамиПечати(СписокОбъектов);
	
КонецПроцедуры

// См. УправлениеПечатьюПереопределяемый.ПриПолученииНастроекСпискаКомандПечати.
Процедура ПриПолученииНастроекСпискаКомандПечати(НастройкиСписка) Экспорт
	
	ЗарплатаКадрыВнутренний.ПриПолученииНастроекСпискаКомандПечати(НастройкиСписка);
	
КонецПроцедуры

// Конец СтандартныеПодсистемы.Печать

// СтандартныеПодсистемы.Пользователи

// См. ПользователиПереопределяемый.ПриОпределенииНазначенияРолей.
Процедура ПриОпределенииНазначенияРолей(НазначениеРолей) Экспорт
	ЗарплатаКадрыВнутренний.ПриОпределенииНазначенияРолей(НазначениеРолей)
КонецПроцедуры

// Конец СтандартныеПодсистемы.Пользователи

// СтандартныеПодсистемы.РассылкаОтчетов

// См. РассылкаОтчетовПереопределяемый.ПереопределитьТаблицуТиповПолучателей.
Процедура ПриПереопределенииТаблицыТиповПолучателей(ТаблицаТипов, ДоступныеТипы) Экспорт
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РассылкаОтчетов") Тогда
		// Параметры справочника "Физические лица".
		НастройкиТипа = Новый Структура;
		НастройкиТипа.Вставить("ГруппаКИ",			Справочники.ВидыКонтактнойИнформации.СправочникФизическиеЛица);
		НастройкиТипа.Вставить("ОсновнойВидКИ",		Справочники.ВидыКонтактнойИнформации.EMailФизическиеЛица);
		НастройкиТипа.Вставить("ОсновнойТип",		Тип("СправочникСсылка.ФизическиеЛица"));
		МодульРассылкаОтчетов = ОбщегоНазначения.ОбщийМодуль("РассылкаОтчетов");
		МодульРассылкаОтчетов.ДобавитьЭлементВТаблицуТиповПолучателей(ТаблицаТипов, ДоступныеТипы, НастройкиТипа);
	КонецЕсли;
	
КонецПроцедуры

// Конец СтандартныеПодсистемы.РассылкаОтчетов

// СтандартныеПодсистемы.УправлениеДоступом

// См. УправлениеДоступомПереопределяемый.ПриЗаполненииСписковСОграничениемДоступа.
Процедура ПриЗаполненииСписковСОграничениемДоступа(Списки) Экспорт
	
	ЗарплатаКадрыВнутренний.ПриЗаполненииСписковСОграничениемДоступа(Списки);
	
КонецПроцедуры

// См. УправлениеДоступомПереопределяемый.ПриЗаполненииОграниченияДоступа.
Процедура ПриЗаполненииОграниченияДоступа(Список, Ограничение) Экспорт
	
	ЗарплатаКадрыВнутренний.ПриЗаполненииОграниченияДоступа(Список, Ограничение);
	
КонецПроцедуры

// См. УправлениеДоступомПереопределяемый.ПриЗаполненииВидовДоступа.
Процедура УправлениеДоступомЗаполнитьСвойстваВидаДоступа(ВидыДоступа) Экспорт
	
	ЗарплатаКадрыВнутренний.УправлениеДоступомЗаполнитьСвойстваВидаДоступа(ВидыДоступа);
	
КонецПроцедуры

// См. УправлениеДоступомПереопределяемый.ПриЗаполненииИспользованияВидаДоступа.
Процедура УправлениеДоступомЗаполнитьИспользованиеВидаДоступа(ИмяВидаДоступа, Использование) Экспорт
	
	ЗарплатаКадрыВнутренний.УправлениеДоступомЗаполнитьИспользованиеВидаДоступа(ИмяВидаДоступа, Использование);
	
КонецПроцедуры

// См. УправлениеДоступомПереопределяемый.ПриЗаполненииВидовОграниченийПравОбъектовМетаданных.
Процедура ПриЗаполненииВидовОграниченийПравОбъектовМетаданных(Описание) Экспорт
	
	ЗарплатаКадрыВнутренний.ПриЗаполненииВидовОграниченийПравОбъектовМетаданных(Описание);
	
КонецПроцедуры

// Конец СтандартныеПодсистемы.УправлениеДоступом

#КонецОбласти
